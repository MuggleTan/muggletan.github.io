<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Apache配置反向代理</title>
    <url>/2020/07/23/Apache%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>为了让自己的spring boot项目能被域名直接访问，而不是IP:端口号的形式访问，需要用到反向代理，简单来讲就是把一个程序运行的地址映射到域名上，实现直接用域名访问。网上很多教程都是针对nignx的，而我用的是apache，也不想折腾把apache换成nignx，找了很久才找到一个可以用的，这里记录一下，方便下次使用。</p>
</blockquote>
<h1 id="1-开启Apache的代理模块"><a href="#1-开启Apache的代理模块" class="headerlink" title="1.开启Apache的代理模块"></a>1.开启Apache的代理模块</h1><p>在确保Apache安装好之后，通过<code>a2enmod proxy proxy_balancer proxy_http</code>开启Apache的代理模块。</p>
<p>我用的是Ubuntu的Apache和centos下的Apache目录结构似乎有点不一样。</p>
<span id="more"></span>

<h1 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2.修改配置文件"></a>2.修改配置文件</h1><p>切换到 <code>/etc/apache2/sites-enabled</code> 目录下，打开需要修改网站对应的配置</p>
<img data-src="/images/Apache配置反向代理/image-20200723085537548.png" alt="image-20200723085537548" style="zoom:80%;" />

<p>没有的话就新建一个对应的配置文件，文件的名字是二级域名的前缀.conf，比如我的域名是steventan.top，</p>
<p>那么test.conf对应的网站是test.steventan.top，这个好像也只是一个命名的习惯，不一样也没多大问题，这样主要是方便管理。</p>
<p>旧版Apache：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line"></span><br><span class="line">	ServerName autoclock.steventan.top <span class="comment">#这里填代理服务器的IP或域名</span></span><br><span class="line">	ProxyRequests off <span class="comment">#off表示开启反向代理  on表示开启正向代理</span></span><br><span class="line">	ProxyPass / http://localhost:8080/  <span class="comment">#被代理的网站，中间的那个/千万别少了，少了的话重启报错</span></span><br><span class="line">	ProxyPassReverse / http://localhost:8080/  <span class="comment">#被代理的网站</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"># RewriteEngine on</span></span><br><span class="line">	<span class="comment"># RewriteCond   %&#123;HTTPS&#125; !=on</span></span><br><span class="line">	<span class="comment"># RewriteRule   ^(.*)  https://%&#123;SERVER_NAME&#125;$1 [L,R]</span></span><br><span class="line"></span><br><span class="line">	ErrorLog <span class="variable">$&#123;APACHE_LOG_DIR&#125;</span>/error.log</span><br><span class="line">	CustomLog <span class="variable">$&#123;APACHE_LOG_DIR&#125;</span>/access.log combined</span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>

<p>新版Apache：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line"></span><br><span class="line">	ServerAdmin webmaster@localhost</span><br><span class="line">	</span><br><span class="line">	&lt;Proxy *&gt;</span><br><span class="line">		Order Deny,Allow</span><br><span class="line">		Allow from all</span><br><span class="line">	&lt;/Proxy&gt;</span><br><span class="line"></span><br><span class="line">	ServerName 10.100.128.8</span><br><span class="line">	ProxyRequests off</span><br><span class="line">	ProxyPass /api http://localhost:8080/</span><br><span class="line">	ProxyPassReverse /api http://localhost:8080/</span><br><span class="line">  	</span><br><span class="line"></span><br><span class="line">	ErrorLog <span class="variable">$&#123;APACHE_LOG_DIR&#125;</span>/error.log</span><br><span class="line">	CustomLog <span class="variable">$&#123;APACHE_LOG_DIR&#125;</span>/access.log combined</span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>上面的配置是将本地的8080端口运行的程序映射到autoclock.steventan.top这个域名上，这就达到了我的目的，服务器上运行的spring boot项目，能通过域名直接在公网访问。</p>
<h1 id="3-重启apache生效配置"><a href="#3-重启apache生效配置" class="headerlink" title="3.重启apache生效配置"></a>3.重启apache生效配置</h1><p>通过<code>service apache2 restart</code> 重启Apache，让配置文件生效。 </p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian安装与配置Redis</title>
    <url>/2023/08/26/Debian%E4%B8%AD%E5%AE%89%E8%A3%85Redis/</url>
    <content><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><h2 id="1-进入Redis官网"><a href="#1-进入Redis官网" class="headerlink" title="1. 进入Redis官网"></a>1. 进入Redis<a href="https://redis.io/">官网</a></h2><p>进入下载页面，找到下载按钮，右键复制下载链接</p>
<h2 id="2-下载Redis"><a href="#2-下载Redis" class="headerlink" title="2. 下载Redis"></a>2. 下载Redis</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/redis/redis/archive/7.2.0.tar.gz -O redis.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="3-解压压缩包"><a href="#3-解压压缩包" class="headerlink" title="3. 解压压缩包"></a>3. 解压压缩包</h2><p>解压压缩包到opt目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf redis.tar.gz -C /opt</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="1-编译环境准备"><a href="#1-编译环境准备" class="headerlink" title="1. 编译环境准备"></a>1. 编译环境准备</h2><p>安装gcc和make：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install gcc make</span><br></pre></td></tr></table></figure>

<p>安装好之后<code>gcc -v</code>看一下是否安装成功</p>
<h2 id="2-编译安装"><a href="#2-编译安装" class="headerlink" title="2. 编译安装"></a>2. 编译安装</h2><p>安装好后进入redis目录，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>如果没报错，并看到下图字样表示安装成功</p>
<p><img data-src="/../images/Debian%E4%B8%AD%E5%AE%89%E8%A3%85Redis/image-20230826151045812.png" alt="image-20230826151045812"></p>
<h2 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3. 修改配置文件"></a>3. 修改配置文件</h2><p>编辑redis目录下面的redis.config文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano redis.conf</span><br></pre></td></tr></table></figure>

<ul>
<li><p>绑定地址修改	</p>
<p>默认bind 127.0.0.1       直接注释掉(默认bind 127.0.0.1只能本机访问)或改成本机IP地址，否则影响远程IP连接</p>
</li>
<li><p>静默启动</p>
<p>默认daemonize no       改为 daemonize yes</p>
</li>
<li><p>关闭保护模式</p>
<p>默认protected-mode yes   改为 protected-mode no</p>
</li>
<li><p>设置密码</p>
<p>添加redis密码           改为 requirepass 你自己设置的密码</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>HDA学习总结</title>
    <url>/2024/07/19/HDA%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="开发背景"><a href="#开发背景" class="headerlink" title="开发背景"></a>开发背景</h1><p>随着业务系统的运行，伴随的业务数据也会日积月累的越来越多，占用的数据库空间也会越来越大，如果不及时清理，会降低系统数据的读写速度，影响系统的性能。而当系统性能下降到一定程度，就会影响到系统的正常运行，导致业务处理能力下降，甚至导致业务中断无法运行。</p>
<p>因此，系统需要一个通用的、相对独立的数据归档工具来定期清理业务数据，减小系统在线数据的大小，维持系统的运行效率。</p>
<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>HDA全称是Historical Data Archive。</p>
<p>HDA归档主要主要包含两个数据表，一个是归档配置表另一个是归档日志表。归档任务是通过定时任务定时来触发的，定时的具体时间是在Apollo中进行配置的(<code>task.deadline.time</code>)。到定时时间了，系统就会自动触发归档，来查询归档配置对数据进行归档。归档配置表主要包含表名、表的所属用户、数据库名、归档标志、清理标志、基准时间字段、归档数据间隔天数等。</p>
<p>通过配置表的这些字段可以判断出那些表的那些数据需要进行归档，需要注意的是归档数据只支持分区表，因为非分区表中保存的一般为状态类型的数据，通常情况不需要使用工具进行清理，如果有清理需求由运维人员进行手动清理。</p>
<p>业务数据的生命周期如下图：</p>
<span id="more"></span>

<p><img data-src="/../images/HDA%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/IMG-20240719201950942.png"></p>
<p>对于归档的数据按照数据库、表名和归档时间分目录存放，数据支持本地存储、通过sftp上传到指定的文件服务器或上传到指定的对象存储服务器。</p>
<p>总体流程图下图：<br><img data-src="/../images/HDA%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/IMG-20240719202005304.png"></p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>执行之前有一个防并发的判断，因为该接口也可以手动调用，为了防止多次同时调用触发归档任务，所以有一个防并发的判断，然后初始化一些必要的参数，比如任务id，数据源配置，线程池配置，文件存储的配置，全局截止时间的获取等。</p>
<p>然后查询归档配置表的数据，得到所有要归档和清理的表，使用<code>CountDownLatch</code>作为一个全局标志，判断是不是所有的任务都执行完毕了。这里构造<code>CountDownLatch</code>的参数是所有任务的数量，将构造好的<code>CountDownLatch</code>对象传入每个任务中去，任务执行完后调用该对象的<code>countDown</code>方法，可以将其<code>count</code>值减一，当<code>count</code>值减到0之后代表所有的任务都执行完毕了。</p>
<p>然后将这些任务按服务进行分组，以服务名称作为区分，为其分配不同的线程池来执行归档或清理任务，然后再将这一个服务中的所有任务添加到一个list中，遍历这个list就可以启动对应的归档或清理任务了。</p>
<p><img data-src="/../images/HDA%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/IMG-20240719202022037.png"></p>
<p>这里的任务主要分为两种，分别是归档任务和清理任务，这两个任务类基于模板设计的，用一个抽象类作为模板，两个子类分别继承该抽象类补充其中的关键步骤。</p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><ol>
<li><p>归档工具未能在业务闲时运行完，影响了业务的正常运行，为避免这种情况，需要对归档工具设置截止时间，包括全局截止时间和优雅退出时间，均在配置文件中可以根据需求进行配置。</p>
<ul>
<li>全局截止时间是绝对的时间，例如5:00或6:00。表示到该时间后不能再开启新的归档或清理任务，并将正在进行的归档后清理任务进行优雅停止。</li>
<li>优雅退出时间为时间间隔，单位是分钟，例如设置30分钟。表示系统达到全局截止时间+优雅推出时间时，如果仍有任务未完成，则需要强制执行结束动作。</li>
</ul>
<p> 具体实现：<br> 在每个原子任务中，都需要检查是否到了全局截止时间：如果没到，继续进行当前任务；如果已经到了全局截止时间，则不再开启新的任务，当前正在进行的任务执行优雅退出。<br> 另外，需要起一个监控线程，监控归档和清理任务是否已结束。当系统时间到达“全局截止时间+优雅退出余时间”时，还仍有归档或清理任务没有结束，则执行强制结束动作。</p>
</li>
<li><p>归档时间范围确定<br>通过日志确定上次归档的日期，从上次的日期一直到要归档的时间开始，都是需要归档的数据</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Debian中注册自定义服务</title>
    <url>/2024/01/19/Debian%E4%B8%AD%E6%B3%A8%E5%86%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="编辑自定义的-service文件"><a href="#编辑自定义的-service文件" class="headerlink" title="编辑自定义的.service文件"></a>编辑自定义的.service文件</h1><p>在<code>/etc/systemd/system/ </code>目录下创建自定义的<code>.service</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=sun-panel		<span class="comment"># 服务描述</span></span><br><span class="line">After=syslog.target</span><br><span class="line">After=network.target		<span class="comment"># 等待网络启动之后再启动此服务</span></span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">RestartSec=3s						<span class="comment"># 失败后等待 3 秒再尝试重启</span></span><br><span class="line">Type=simple							</span><br><span class="line">User=root								<span class="comment"># 以指定的用户身份运行服务</span></span><br><span class="line">Group=root</span><br><span class="line">ExecStart=/root/sun-panel/sun-panel <span class="comment"># 启动命令 </span></span><br><span class="line">WorkingDirectory=/root/sun-panel    <span class="comment"># 启动程序所在目录</span></span><br><span class="line">Restart=always</span><br><span class="line">Environment=USER=root HOME=/root/</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<h1 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h1><p>在系统中注册你的服务，这样系统每次开机都会自动启动你的服务，并且可以通过service命令来启动、停止和查看你的服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> your-service-name.service</span><br></pre></td></tr></table></figure>

<h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start your-service <span class="comment"># 两种都可以</span></span><br><span class="line">service your-service start  </span><br></pre></td></tr></table></figure>

<h1 id="监听配置文件"><a href="#监听配置文件" class="headerlink" title="监听配置文件"></a>监听配置文件</h1><p>当需要频繁修改配置文件时，每次手动重启麻烦，可以添加自动监听配置文件，修改之后自动重启</p>
<ol>
<li><p>修改或创建 <code>.path</code> 文件 <code>/etc/systemd/system/fancontrol-monitor.path</code></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Monitor fancontrol config file for changes</span><br><span class="line"></span><br><span class="line"><span class="section">[Path]</span></span><br><span class="line"><span class="attr">PathModified</span>=/etc/fancontrol</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改或创建 <code>.service</code> 文件 <code>/etc/systemd/system/fancontrol-monitor.service</code></p>
<p>注意要和<code>.path</code>的文件名保持一致</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Restart fancontrol service <span class="literal">on</span> config change</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=<span class="literal">on</span>eshot</span><br><span class="line"><span class="attr">ExecStart</span>=/bin/systemctl restart fancontrol</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用并启动 <code>.path</code> 文件</p>
<p>确保 <code>.path</code> 文件和 <code>.service</code> 文件名称匹配，然后执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> fancontrol-config-monitor.path</span><br><span class="line">systemctl start fancontrol-config-monitor.path</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这样，当 <code>/etc/fancontrol</code> 文件修改时，<code>fancontrol</code> 服务将自动重启。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>I217-V在openwrt下大流量断网问题</title>
    <url>/2022/07/15/I217-V%E5%9C%A8openwrt%E8%BD%AF%E8%B7%AF%E7%94%B1%E4%B8%8B%E5%A4%A7%E6%B5%81%E9%87%8F%E6%96%AD%E7%BD%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近跟着up司波图在玩一个AIO（All In One）服务器，也就是将软路由，NAS系统以及影音系统都集成到一个物理系统中，我用的是之前买的一个M73的小主机，里面的mini-PCIE插槽扩展了一个螃蟹RTL8111的千兆网卡，主机自带的是Intel的I217-V千兆网卡。</p>
<p>经过一天的使用下来发现每次大流量下载或上传时，openwrt都会断一下，开始还以为是openwrt系统的问题，后来经过一番资料搜索，发现是pve下面的这张Intel网卡有问题，查看了pve系统的日志，发现了如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pve kernel: e1000e 0000:00:19.0 eno1: Detected Hardware Unit Hang:</span><br></pre></td></tr></table></figure>
<p>这和搜索到的情况一样，于是就确定是这张Intel网卡的问题。</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>造成该问题的原因是Intel网卡固件的bug</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>在pve虚拟机下关掉网卡的offload功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ethtool -K &lt;网卡编号&gt; tx off rx off &gt;/tmp/e1000e.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>为了方便，不需要每次重启虚拟机之后都手动来关掉，这里设置了一个自启动脚本，原理是pve虚拟机每次启动的呃时候都会扫描<code>/etc/profile.d</code>下面的<code>.sh</code>文件，所以办法很简单，在改文件夹下面新建一个e1000e.sh的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/profile.d/e1000e.sh</span><br></pre></td></tr></table></figure>
<p>然后填入上面的命令即可</p>
<p>参考链接：</p>
<p><a href="https://blog.csdn.net/wudics/article/details/124402110">解决在x86平台装openwrt旁路由大流量断网问题（intel网卡驱动bug问题）</a></p>
<p><a href="https://blog.csdn.net/sxyllxy/article/details/110631505">openWRT在M93p上出现的Detected Hardware Unit Hang</a></p>
]]></content>
      <categories>
        <category>软路由</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>软路由</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP常见面试问题</title>
    <url>/2022/08/02/HTTP%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h1><h2 id="HTTP是什么"><a href="#HTTP是什么" class="headerlink" title="HTTP是什么"></a>HTTP是什么</h2><p>HTTP全称为超文本传输协议（HyperText Transfer Protocol）。</p>
<ol>
<li><p>超文本</p>
<p>如HTTP名字中所说的，其传输的是超文本，超文本从字面上理解是超过了普通的文本文字，也就是还包括文字以外的内容，如图片、视频、超链接等，超文本	就是这些内容的混合体。</p>
<p>HTML（<strong>H</strong>yper <strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage）就是最常见的超文本了，它本身只是纯文字的文件，但是内部用很多标签定义了图片、视频的链接，经过浏览器解释之后，呈现给我们的就是一个有文字、有图片和视频的网页了。</p>
</li>
<li><p>传输</p>
<p>所谓“传输”，就是将东西从一个地方搬到另一个地方。</p>
<p>HTTP协议是一个双向协议。</p>
<p>我们上网的时候，浏览器是请求方A，访问的网站就是应答方B，双方约定使用HTTP协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染出来显示在屏幕上。</p>
<img data-src="/images/HTTP常见面试问题/5-请求应答.png" alt="请求-应答"  />

<span id="more"></span>

<p>虽然数据是在A点和B点传输，但是中间也允许有中转或接力。</p>
<p>这就好比传纸条，第一排的同学传到最后面一排的同学，传递的过程中就要经过好多同学（中间人），而在HTTP里，需要中间人遵从HTTP协议，只要不打扰基本的数据传输，就可以任意添加额外的东西。</p>
</li>
<li><p>协议</p>
<p>我们生活中的协议，本质上和计算机中的协议是相同的，协议的特点：</p>
<ul>
<li>协：代表需要有两个及以上的参与者。例如：三方协议里的参与者包括（你、公司、学校）；租房协议里面包括（你和房东）。</li>
<li>议：代表是对参与者的一种行为约定和规范。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限，每月租金金额、违约如何处理等。</li>
</ul>
<p>针对HTTP协议，我们可以这么理解，HTTP就是一个用在计算机世界里的协议，他是用计算机能够理解的语言建立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式（行为约定和规范）。</p>
</li>
</ol>
<p>所以，总结以上说的三点，“超文本传输协议”就可以表述为：HTTP是一个用在计算机世界里专门在两点之间传输文字、图片、视频、音频等超文本数据的约定和规范。</p>
<blockquote>
<p>那 HTTP是用于从互联网服务器传输到本地浏览器的协议，这种说法正确吗？</p>
</blockquote>
<p>这种说法并不完全正确，也可以是从服务器传输到服务器的协议，所以用两点之间更加的准确。</p>
<h2 id="HTTP常见的状态码有哪些"><a href="#HTTP常见的状态码有哪些" class="headerlink" title="HTTP常见的状态码有哪些"></a>HTTP常见的状态码有哪些</h2><img data-src="/images/HTTP常见面试问题/6-五大类HTTP状态码.png" alt=" 五大类 HTTP 状态码 "  />

<p><code>1XX</code>不详细描述了，如上图所述。</p>
<p><code>2XX</code>这类状态码表示服务器成功处理了客户端的请求。</p>
<ul>
<li><code>200 OK</code> 是最常见的成功状态码，表示一切正常。如果是非<code>HEAD</code>请求，服务器返回的响应头都会有body数据。</li>
<li><code>204 No Content</code>也是一个比较常见的成功状态码，与200 OK基本相同，但是响应头没有body数据。</li>
<li><code>206 Partial Content</code>是应用于HTTP分块下载或断点重传的，表示响应返回的body数据并不是资源的全部，而只是其中的一部分，也是服务器处理成功的状态。</li>
</ul>
<p><code>3XX</code>这类状态码表示客户端请求的资源发生了变动，需要客户端用新的URL重新发送请求获取资源，也就是重定向</p>
<ul>
<li><p><code>301 Moved Permanently</code>表示永久重定向，说明请求的资源已经不存在了，需要用心的URL再次访问。</p>
</li>
<li><p><code>302 Found</code>表示临时的重定向，说明请求的资源还在，但是需要另一个URL来访问</p>
<p>301和302都会在响应头中使用<code>Location</code>字段，指明后续需要跳转的URL，浏览器会自动重定向新的URL。</p>
</li>
</ul>
<ul>
<li><code>304 Not Modified</code>不具有跳转含义，表示资源未修改，重定向已存在的缓存文件，也称为缓存重定向，也就是告诉客户端缓存资源没有过期，可以继续使用。</li>
</ul>
<p><code>4XX</code>这类状态码表示客户端发送的报文有误，服务器无法处理。</p>
<ul>
<li><code>4000 Bad Request</code>表示客户端请求的报文有错误，但只是一个笼统的错误。</li>
<li><code>403 Forbidden</code>表示服务器禁止访问资源，客户端请求未出错。</li>
<li><code>404 Not Found</code>表示请求的资源在服务器上不存在，或未找到，所以无法提供给客户端。</li>
</ul>
<p><code>5XX</code>这类状态码表示客户端请求报文没问题，但是服务器处理时内部发生了错误，属于服务器端的错误码</p>
<ul>
<li><code>500 Internal Service Error</code>和400类型相似，是一个笼统通用的错误码，服务器端发生的具体错误并没有提示出来。</li>
<li><code>501 Not Implemented</code>表示客户端请求的功能还不支持，类似于“即将业务，敬请期待”的意思。</li>
<li><code>502 Bad Gateway</code>通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li><code>503 Service Unavailable</code>表示服务器当前很忙，无法响应客户端，类似于“网络正忙，请稍后重试”。</li>
</ul>
<h2 id="HTTP常见的字段"><a href="#HTTP常见的字段" class="headerlink" title="HTTP常见的字段"></a>HTTP常见的字段</h2><ol>
<li><p>Host字段</p>
<p>客户端发请求时用来指定服务器的域名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host: www.baidu.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>Content-Length字段</p>
<p>服务器返回数据时，会带有该字段，表名本次回应数据的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Length: 1000</span><br></pre></td></tr></table></figure>

<p>如上就是告诉浏览器，本次服务器回应的数据长度是1000个字节，后面的字节就属于下一个回应了。</p>
</li>
<li><p>Connection字段</p>
<p>该字段最常用于客户端要求服务器使用TCP持久连接，以便其他请求复用。</p>
<p>HTTP&#x2F;1.1版本的默认连接都是持久连接，但是为了兼容老版本的HTTP，需要指定<code>Connection</code>首部字段的值为<code>Keep-Alive</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
</li>
<li><p>Content-Type字段</p>
<p>该字段用于服务器回应时告诉客户端，本次数据是什么格式。</p>
<img data-src="/images/HTTP常见面试问题/10-content-type字段.png" alt="img" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>

<p>上面的类型表名发送的是网页，而且编码是UTF-8。</p>
<p>客户端请求的时候可以试用<code>Accept</code>字段声明自己可以接受那些数据格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept: */*</span><br></pre></td></tr></table></figure>

<p>上面代码中，客户端声明自己可以接受任何格式的数据。</p>
</li>
<li><p>Content-Encoding 字段</p>
<p>该字段说明了数据的压缩方法，表名服务器返回的数据使用了上面压缩格式。</p>
<img data-src="/images/HTTP常见面试问题/11-content-encoding字段.png" alt="img"  />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>

<p>上面表示服务器返回的数据采用了gzip的压缩方式，告知客户端需要用此方法来解压数据。</p>
<p>和<code>Content-Type</code>类似，客户端在请求时，可以用<code>Accept-Encoding</code>来说明自己可以接受那些压缩方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h1><h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h2><ul>
<li><p>GET</p>
<p>根据RFC规范，GET的语义是从服务器获取指定的资源，这个资源可以是静态的文本、页面、图片、视频等。GET请求参数的位置一般是写在URL当中，URL规定只能支持ASCII，所以GET请求的参数只允许ASCII字符，而且浏览器会对URL的长度有限制（HTTP协议本上对URL长度没有做规定）。</p>
</li>
<li><p>POST</p>
<p>根据RFC规范，POST请求的语义是根据请求负荷（报文body）对指定资源做出处理，处理的具体方式视资源类型而不同、POST请求携带数据的位置一般是在报文body中，body中的数据可以是任意格式的数据，只要客户端与服务器协商好即可，并且浏览器不会对body大小做限制。</p>
<p>比如，在我文章底部的评论区留言后，点击提交，浏览器就会执行一次POST请求，把你们的留言文字放进报文body里，然后拼接好POST请求头，通过TCP协议发送到服务器。</p>
</li>
</ul>
<h2 id="GET和POST方法是否都安全和幂等"><a href="#GET和POST方法是否都安全和幂等" class="headerlink" title="GET和POST方法是否都安全和幂等"></a>GET和POST方法是否都安全和幂等</h2><p>首先说明一下安全和幂等的概念：</p>
<ul>
<li>在HTTP协议中，所谓的安全试制请求方法会不会破坏服务器上的资源。</li>
<li>所谓的幂等，是指多次执行相同的操作，结果是否都是相同的。</li>
</ul>
<p>如果从RFC规范定义的语义来说：</p>
<ul>
<li>GET方法是安全且幂等的，因为他是只读操作，无论操作多少次，服务器上的数据都是安全的，并且每次的结果也是相同的。所以，可以对GET方法请求的数据做缓存，这个缓存可以放到浏览器上，也可以放到代理上（如Nginx）。</li>
<li>POST方法因为是新增或修改数据操作，会修改服务器上的资源，所以是不安全的，而且多次提交数据就会创建多个资源所以不是幂等的。</li>
</ul>
<p>需要注意的，上面说的都是基于RFC规范定义的语义来分析的，实际开发中，开发者不一定会按照规范来实现GET和POST方法，比如：</p>
<ul>
<li>可以使用GET方法来实现新增或删除数据的请求，这样GET方法就是不安全、不幂等的。</li>
<li>可以使用POST方法来实现数据查询的请求，这样POST方法就是安全和幂等的。</li>
</ul>
<blockquote>
<p>有一个笑话，有人写了个博客，删除博客用的是GET请求，他觉得没人访问就连鉴权都没做。</p>
<p>然后Google服务器爬虫爬了一遍，他所有博文就没了。&amp;#x1F602;</p>
</blockquote>
<h1 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h1><h2 id="HTTP缓存的实现方式"><a href="#HTTP缓存的实现方式" class="headerlink" title="HTTP缓存的实现方式"></a>HTTP缓存的实现方式</h2><p>对于一些重复性的HTTP请求，比如每次请求得到的数据都一样，我们可以把这对「请求-响应」的数据缓存到本地，那么下一次请求就可以直接读取本地的数据了，不需要通过网络获取服务器的响应，这样的话HTTP&#x2F;1.1的性能会有肉眼可见的提升。</p>
<p>所以避免发送同样HTTP请求的方法就是通过缓存技术，HTTP设计者早在之前就考虑到了这点，所以HTTP协议的头部有不少字段都是针对缓存设计的。</p>
<p>HTTP缓存的实现方式总体上可以分为两种，分别是强制缓存和协商缓存。</p>
<h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>前置缓存指的是只要浏览器判断缓存没过期，则直接使用浏览器本地的缓存，决定是否使用缓存的主动性在浏览器。</p>
<p>如下图，返回的状态码是200，但是括号中的标识是赖在内存缓存，也就是使用了强制缓存。</p>
<img data-src="/images/HTTP常见面试问题/image-20220803210210198.png" alt="image-20220803210210198"  />

<p>强制缓存是利用下面这两个HTTP响应头部（Response Header）字段来实现的，他们都用来表示资源在客户端缓存的有效期：</p>
<ul>
<li><code>Cache-Control</code>，是一个相对时间；</li>
<li><code>Expires</code>，是一个绝对时间；</li>
</ul>
<p>如果HTTP响应头同时有这两个字段的话，<strong>Cache-Controle的优先级高于Expire</strong>。</p>
<p>Cache-Control的选项更多一些，设置更加精细，所以建议使用Cache-Control来实现强缓存。具体实现流程如下：</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在Response头中加上Cache-Control这个字段，该字段中设置了资源过期时间的长度。</li>
<li>当浏览器再次请求该资源时，会先通过请求该资源的时间与Cache-Control中设置过期的时间大小来计算出该资源是否过期，如果没有，则使用改缓存，否则重新请求服务器。</li>
<li>当资源过期后，服务器再次收到请求，会重复上述步骤。</li>
</ul>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当我们在浏览器使用开发者工具的时候，可能看到过某些请求的响应码是<code>304</code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种服务端告知客户端是否可用使用缓存的方式被称为协商缓存。</p>
<p>协商缓存可以基于两种头部字段来实现。</p>
<ol>
<li>基于请求头中的<code>If-Modified-Since</code>字段与响应头部中的<code>Last-Modified</code>字段实现<ul>
<li>响应头中的<code>Last-Modified</code>：表示这个响应资源最后修改的时间，服务器给客户端返回资源的时候会带上。</li>
<li>请求头中的<code>If-Modified-Since</code>：当需要再次请求服务器该资源的时候，客户端会将该资源的修改时间作为<code>If-Midified-Since</code>的值放到请求头，一起发送给服务器，服务器收到后返现有<code>If-Modified-Since</code>，则将该资源的最后修改时间与之对比，若最后修改时间较新，则说明资源又被修改过，则返回新资源，HTTP 200 OK；如果最后修改时间较旧，则返回HTTP 304，浏览器继续使用本地缓存。</li>
</ul>
</li>
<li>请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段<ul>
<li>响应头中的<code>Etag</code>：唯一标识响应资源。</li>
<li>请求头中的<code>If-None-Match</code>：当资源过期时，浏览器发现该资源的响应头中有Etag，则再次向服务器发起请求时，会将请求头中的If-None-Match的值设为Etag的值。服务器收到请求后就行对比，如果资源没有变化则返回HTTP 304，如果变化了则返回新的资源，HTTP 200 OK。</li>
</ul>
</li>
</ol>
<p>下图就是一个<code>Etag</code>协商的过程。</p>
<img data-src="/images/HTTP常见面试问题/缓存etag.png" alt="img"  />

<p>第一种方式是基于时间来实现的，而第二种方式是基于一个位移标识来实现的，相对来说后者可以更加准确地判断出文件内容是否被修改该，避免时间被篡改而导致的不可靠问题。</p>
<p>如果HTTP响应头同时有Etag和Last-Modified字段的时候，Etag的优先级更高，就是先会通过判断Etag是否变化了，如果未发生变化，再看Last-Modified。</p>
<p>注意：协商缓存这两种方法都需要配合强制缓存中的Cache-Control字段来使用，只有在未命中强制缓存的时候，才可以发起带有协商缓存字段的请求。</p>
<p>下图是浏览器判断缓存是否过期的完整流程。</p>
<img data-src="/images/HTTP常见面试问题/d92026ce085b401c95cf02b7ce9b7fae.png" alt="img"  />

<h1 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h1><h2 id="HTTP-x2F-1-1的优点"><a href="#HTTP-x2F-1-1的优点" class="headerlink" title="HTTP&#x2F;1.1的优点"></a>HTTP&#x2F;1.1的优点</h2><p>HTTP最突出的优点是「简单、灵活和易于扩展、应用广泛和快平台」。</p>
<ol>
<li><p>简单</p>
<p>HTTP报文基本格式就是<code>header + body</code>，头部信息也是<code>key-value</code>的简单文本形式，易于理解，降低了学习和使用的门槛。</p>
</li>
<li><p>灵活和易于扩展</p>
<p>HTTP协议里的各类请求方法、URI&#x2F;URL、状态码、头部字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。</p>
<p>同时HTTP由于是工作在应用层（OSI第七层），则他下层可以随意变化。</p>
<p>HTTPS也就是在HTTP与TCP层之间增加了SSL&#x2F;TLS安全创术层，HTTP&#x2F;3甚至吧TCP层换成基于UDP的QUIC。</p>
</li>
<li><p>应用广泛和跨平台</p>
<p>互联网发展至今，HTTP的应用范围非常的广阔，从台式机的浏览器到手机上的各种APP，HTTP的应用遍地开花，同时具有跨平台的优越性。</p>
</li>
</ol>
<h2 id="HTTP-x2F-1-1的缺点"><a href="#HTTP-x2F-1-1的缺点" class="headerlink" title="HTTP&#x2F;1.1的缺点"></a>HTTP&#x2F;1.1的缺点</h2><p>HTTP协议里有优缺点一题的双刃剑，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。</p>
<ol>
<li><p>无状态双刃剑</p>
<p>无状态的<strong>好处</strong>，因为服务器不需要去记忆HTTP的状态，所以不需要额外的资源来记录状态信息，这可以减轻服务器的负担，能够把更多的CPU和内存来对外提供服务。</p>
<p>无状态的<strong>坏处</strong>，没有记忆的服务器，在完成一些关联性的操作时会非常麻烦，例如：登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这一系列操作都要知道用户的身份才行。单服务器不知道这些请求是有关联的，每次都要问一遍身份信息，这就显得非常的“不聪明”。</p>
<p>对于无状态的问题，解决方案也有多种，比较简单的方式是使用<strong>Cookie</strong>技术，通过在请求和响应报文中写入Cookie信息来控制客户端的状态。</p>
<p>Cookie就相当于一个“小贴纸”， 在客户端第一次请求后，服务器会下发一个装有客户信息的“小贴纸”，后续客户端请求服务器的时候，带上“小贴纸”，服务器就认识这是谁了。</p>
<img data-src="/images/HTTP常见面试问题/14-cookie技术.png" alt="Cookie 技术"  />
</li>
<li><p>明文双刃剑</p>
<p>明文意味着在传输的过程中不需要对信息进行加密和解密，可以在一定程度上减少客户端和服务器的性能消耗。</p>
<p>但也正是这样，HTTP所有的信息都暴露在光天化日之下，相当于信息裸奔了，在明文传输的漫长过程中，很容易就会被别人窃取，如果里面有你的账号密码信息，那就相当于号没了。</p>
</li>
<li><p>不安全</p>
<p>HTTP比较严重的缺点就是不安全：</p>
<ul>
<li>明文通信，内容可能被窃听。比如上面说的<strong>号没了</strong>。</li>
<li>不验证通信方的身份，可能会遭遇伪装。比如访问假的淘宝、京东，那<strong>钱没了</strong>。</li>
<li>无法验证报文的完整性，有可能内容会被篡改。比如在网页上植入垃圾广告，视觉污染，<strong>眼没了</strong>。</li>
</ul>
<p>HTTP的安全问题可以用HTTPS的方式来解决，也就是通过引入SSL&#x2F;TLS层，使得安全性可靠。</p>
</li>
</ol>
<h2 id="HTTP-x2F-1-1性能"><a href="#HTTP-x2F-1-1性能" class="headerlink" title="HTTP&#x2F;1.1性能"></a>HTTP&#x2F;1.1性能</h2><p>HTTP是基于<strong>TCP&#x2F;IP</strong>，并且使用了「<strong>请求 - 应答</strong>」的通信模式，所以性能关键就在这两点。</p>
<ol>
<li><p>长连接</p>
<p>早起的HTTP&#x2F;1.0性能上有一个比较大的问题，那就是每次发起一个请求，都要新建一次TCP连接（三次握手），而且是串行请求，做了很多无谓的TCP连接建立和断开，增加了通信开销。</p>
<p>为了解决上述问题，HTTP&#x2F;1.1提出了长连接的通信方式，也叫持久连接，这种方式的好处在于减少了TCP连接的重复建立和断开所带来的的额外开销，减轻了服务器端的负载。</p>
<p>持久连接的特点是，只要任意一端没有明确要断开连接，就保持TCP连接的状态。</p>
<img data-src="/images/HTTP常见面试问题/16-短连接与长连接.png" alt="短连接与长连接"  />

<p>当然如果HTTP长连接超过一定时间没有数据交互，服务器就会主动断开这个连接。</p>
</li>
<li><p>管道网络传输</p>
<p>HTTP&#x2F;1.1采用了长连接的方式，这使得管道（pipeline）网络传输称为可能。</p>
<p>也就是在同一个TCP连接中，客户端可以发起多个请求，主要第一个请求发出去了，不需要邓起返回，就可以发出第二个请求，可以减少真题的响应时间。</p>
<p>煮个栗子，客户端需要请求两个资源，之前的做法是，在同一个TCP连接里面先发送A请求，然后等服务器做出回应，收到后在发出B请求。那么，管道机制是允许浏览器同时发出A请求和B请求。</p>
<p>但是服务器必须按照接收请求的顺序发送这些请求的响应。</p>
<p>这就会出现一种情况，如果服务器在处理A请求时耗时比较长，那么后续的请求处理都会被阻塞，这被称为「队头阻塞」。所以HTTP&#x2F;1.1解决了请求的队头阻塞，但是没有解决响应的队头阻塞。</p>
<p>注意：实际上HTTP&#x2F;1.1管道化技术不是默认开启的，而且浏览器基本都没有支持，所以后面讨论HTTP&#x2F;1.1都是建立在没有使用管道化的前提。</p>
</li>
<li><p>对头阻塞</p>
<p>「请求 - 应答」的模式加剧了HTTP的性能问题。</p>
<p>因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也同样被阻塞了，会导致客户端一直请求不到数据，这就是队头阻塞。</p>
<img data-src="/images/HTTP常见面试问题/18-队头阻塞.png" alt="队头阻塞"  /></li>
</ol>
<p>总之，HTTP&#x2F;1.1的性能比较一般，后续的HTTP&#x2F;2和HTTP&#x2F;3就是在优化HTTP的性能。</p>
<h1 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h1><h2 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h2><ol>
<li>HTTP是超文本传输协议，信息是明文传输的，存在安全风险问题，HTTPS则解决了HTTP不安全的缺陷，在TCP和HTTP层之间加入了SSL&#x2F;TLS安全协议，使得报文可以加密传输。</li>
<li>HTTP建立连接相对简单，TCP三次握手之后就可以进行HTTP报文的传输。而HTTPS在TCP三次握手之后，还需要进行SSL&#x2F;TLS的握手，才可以进行报文加密传输。</li>
<li>HTTP的默认端口号是80，HTTPS则是443.</li>
<li>HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ol>
<h2 id="HTTPS解决了HTTP的哪些问题"><a href="#HTTPS解决了HTTP的哪些问题" class="headerlink" title="HTTPS解决了HTTP的哪些问题"></a>HTTPS解决了HTTP的哪些问题</h2><p>众所周知，HTTP是明文传输，所以安全上存在一下三点风险：</p>
<ul>
<li>窃听风险，在通信连路上可以获取通信的内容。</li>
<li>篡改风险，在通信链路上可以被强行植入垃圾广告。</li>
<li>冒充风险，冒充淘宝等购物网站。</li>
</ul>
<img data-src="/images/HTTP常见面试问题/19-HTTPS与HTTP.png" alt="HTTP 与 HTTPS 网络层" />

<p>而HTTP<strong>S</strong>在HTTP与TCP层之间加入了<code>SSL/TLS</code>协议，可以很好的解决上述的风险：</p>
<ul>
<li>信息加密：通过混合加密算法对交互的信息进行加密，中间人无法窃取通信内容，保证通信内容的机密性，解决了窃听风险。</li>
<li>校验机制：通过摘要算法生成通信内容的数字签名，通过该签名可以判断通信的内容是否被篡改，保证通信内容的完整性，解决了篡改风险。</li>
<li>身份证书：通过数字证书来保证我们使用的公钥不是冒充的，解决了冒充风险。</li>
</ul>
<p>下面详细介绍这三项解决措施：</p>
<ol>
<li><p>混合加密</p>
<img data-src="/images/HTTP常见面试问题/20-混合加密.png" alt="混合加密" />

<p>HTTPS采用的是对称加密和非对称加密结合的混合加密方式：</p>
<ul>
<li>在通信建立之前采用非对称加密的方式来交换会话秘钥，后续就不再使用非对称加密。</li>
<li>在通信过程中全部使用会话秘钥来进行对称加密通信，减轻系统的性能消耗。</li>
</ul>
<p>采用混合加密的原因：</p>
<ul>
<li><strong>对称加密</strong>只使用一个秘钥，运算速度快，但是秘钥必须保密，无法做到安全的秘钥交换。</li>
<li><strong>非对称加密</strong>使用两个秘钥，一个公钥一个私钥，公钥可以任意分发而私钥必须保密，解决了秘钥交换问题但速度较慢。</li>
</ul>
</li>
<li><p>摘要算法+数字签名</p>
<p>为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方，对方收到数据后，也对内容计算出一个「指纹」，然后更发送方的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断内容被篡改过。</p>
<img data-src="/images/HTTP常见面试问题/摘要算法.png" alt="img"/>

<p>在计算机中，会使用摘要算法（哈希函数）来计算内容的哈希值，也就是内容的「指纹」，这个哈希值是唯一的，且无法通过哈希值推导出内容，也就是哈希的过程是不可逆的。</p>
<p>通过摘要算法虽然可以保证内容不会被篡改，但是并不能保证内容和哈希值不会被一起修改掉，因为这里缺少对客户端收到的消息是否来源于服务器的证明。</p>
<p>为了避免这种情况的发生，这里通常会使用<strong>非对称加密</strong>算法来解决，非对称加密的两个秘钥可以双向加密和解密，比如用公钥加密，私钥解密，也可以用私钥加密，公钥解密，这两种不同的做法，目的也完全不同：</p>
<ul>
<li><strong>公钥加密，私钥解密</strong>：这个目的是为了保证传输内容的安全，因为公钥加密的内容其他人是无法解密的，只有持有私钥的人才可以解密出实际内容。</li>
<li><strong>私钥加密，公钥解密</strong>：这是为了确保消息没有被冒充，因为私钥是保密的，如果公钥可以正常解密出私钥加密的内容，说明这个消息是来自于持有私钥身份的人发送的。</li>
</ul>
<p>一般我们不会使用非对称加密来解密实际的传输内容，因为非对称加密比较耗费性能。非对称加密一般是通过「私钥加密，公钥解密」的方式，来确认消息的身份，数字签名算法，就是采用这种方式，不过私钥加密的内容不是内容本身，而是对内容的哈希值加密。</p>
<p>到这里，完整的流程如下图：</p>
<img data-src="/images/HTTP常见面试问题/数字签名.png" alt="img" />

<p>私钥是有服务端保管，然后服务端会向客户端分发对应的公钥，如果客户端收到的信息能被公钥解密，就说明该消息是由服务器发送的。</p>
</li>
<li><p>数字证书</p>
<p>通过前面我们知道：</p>
<ul>
<li>可以通过哈希算法来保证消息的完整性；</li>
<li>可以通过数字签名来保证消息来源的可靠性（确认消息是持有私钥的一方发送的）</li>
</ul>
<p>但还是存在存在着一个漏洞，缺少了对公钥的验证，万一公钥是被伪造的，那前面的这些加密都白搭。</p>
<p>所以还需要一个权威机构来证明公钥的身份，这个全为机构就是CA（数字证书认证机构），将服务器公钥放在数字证书（数字证书认证机构颁发）中，只要证明证书可信的，那公钥就是可信的。</p>
<p>数字证书的工作流程如下图：</p>
<img data-src="/images/HTTP常见面试问题/22-数字证书工作流程.png" alt="22-数字证书工作流程" />

<p>通过数字证书的方式可以保证服务器公钥的身份，解决冒充的风险。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS建立的过程</title>
    <url>/2022/08/10/HTTPS%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="SSL-x2F-TLS协商基本流程"><a href="#SSL-x2F-TLS协商基本流程" class="headerlink" title="SSL&#x2F;TLS协商基本流程"></a>SSL&#x2F;TLS协商基本流程</h1><ol>
<li>客户端向服务器索要并验证服务器公钥</li>
<li>双方协商产生「对话秘钥」</li>
<li>双方使用「会话秘钥」进行加密通信</li>
</ol>
<p>前面两步是SSL&#x2F;TLS的建立过程，也就是TLS握手阶段，SSL&#x2F;TLS「握手阶段」设计的四次通信，如下图所示：</p>
<img data-src="/images/HTTPS建立的过程/23-HTTPS工作流程.png" alt="HTTPS 连接建立过程"  />

<span id="more"></span>

<p>SSL&#x2F;TLS协议建立的详细流程：</p>
<ol>
<li><p>Client Hello</p>
<p>首先，客户端向服务器发起加密通信的请求，也就是Client Hello请求。</p>
<p>这一步，客户端向服务器发送如下信息：</p>
<ul>
<li>客户端支持的TLS版本，如TLS1.2版本。</li>
<li>客户端产生的随机数（Client Random），后面用于生成「会话秘钥」条件之一。</li>
<li>客户端支持的加密套件列表。</li>
</ul>
</li>
<li><p>Server Hello</p>
<p>服务器收到客户端请求后，向客户端发出响应，也就是<code>Server Hello</code>，服务器回应内容如下：</p>
<ul>
<li>确认SSL&#x2F;TLS协议版本，如果浏览器不支持，则关闭加密协议</li>
<li>服务器产生随机数（Server Random），用于后面生成「会话秘钥」的条件之一</li>
<li>确认加密套件列表</li>
<li>服务器的数字证书</li>
</ul>
</li>
<li><p>客户端回应</p>
<p>客户端收到服务器的回应之后，首先通过浏览器或操作系统中的CA公钥，确认服务器证书的真实性。</p>
<p>若证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：</p>
<ul>
<li>一个随机数（pre-master key），该随机数使用服务器公钥加密。</li>
<li>加密通信算法改变通知，表示之后的信息都使用会话秘钥进行加密通信。</li>
<li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有发送的数据做一个摘要，用来给服务器校验。</li>
</ul>
<p>服务端和客户端共有了三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的会话秘钥。</p>
</li>
<li><p>服务器的回应</p>
<p>服务器收到客户端的第三个随机数（per-master key）之后，通过协商的加密算法，计算本次通信的「会话秘钥」。</p>
<p>然后向客户端发送最后的信息：</p>
<ul>
<li>加密通信算法改变的通知，表示之后的信息都会使用「会话秘钥」加密通信。</li>
<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有发送的内容做一个摘要，供客户端校验。</li>
</ul>
<p>至此，整个SSL&#x2F;TLS握手的阶段全部结束，接下来客户端和服务器进入加密通信，任然使用HTTP协议，但是内容会使用「会话秘钥」进行加密。</p>
</li>
</ol>
<p>补充一个数字证书签发和验证的流程：</p>
<img data-src="/images/HTTPS建立的过程/证书的校验.png" alt="img" />



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.xiaolincoding.com/network/2_http/http_interview.html#https-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84-%E5%85%B6%E9%97%B4%E4%BA%A4%E4%BA%92%E4%BA%86%E4%BB%80%E4%B9%88"> 小林coding-HTTPS 是如何建立连接的？其间交互了什么？</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中看似简单实际很坑的题目</title>
    <url>/2020/05/04/Java%E4%B8%AD%E7%9C%8B%E4%BC%BC%E7%AE%80%E5%8D%95%E5%AE%9E%E9%99%85%E5%BE%88%E5%9D%91%E7%9A%84%E9%A2%98/</url>
    <content><![CDATA[<h3 id="第一题（貌似是考察方法的参数传递）"><a href="#第一题（貌似是考察方法的参数传递）" class="headerlink" title="第一题（貌似是考察方法的参数传递）"></a>第一题（貌似是考察方法的参数传递）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line">    method(a,b);//在调用method()方法之后输出a = 100,b = 200</span><br><span class="line">    System.out.println(&quot;a = &quot; + a);</span><br><span class="line">    System.out.println(&quot;b = &quot; + b);</span><br><span class="line">  &#125;</span><br><span class="line">  static void method(int a,int b)&#123;</span><br><span class="line">    //代码编写处</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在method中直接写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 100;</span><br><span class="line">b = 200;</span><br></pre></td></tr></table></figure>

<p>这个样子会直接被别人鄙视</p>
<p>其实这是一个脑筋急转弯的题目，直接像上面这样把一个基本数据类型的变量，作为形参传入函数，等于是直接把值赋给了函数中的实参，改变函数中的实参并不会影响主函数中a和b的值，在method()方法调用完之后，方法中的实参a和b就出栈了，此时在主函数输出的仍然是10和20。</p>
<span id="more"></span>

<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>机智的方法，调用完method()方法之后就直接退出程序，不让他执行主函数中的print方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void method(int a,int b)&#123;</span><br><span class="line">  a = 100;</span><br><span class="line">  b = 200;</span><br><span class="line">  System.out.println(&quot;a = &quot; + a);</span><br><span class="line">  System.out.println(&quot;b = &quot; + b);</span><br><span class="line">  System.exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void method(int a,int b)&#123;</span><br><span class="line">  PrintStream ps = new PrintStream(System.out)&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void println(String x)&#123;</span><br><span class="line">            if(&quot;a = 10&quot;.equals(x))&#123;</span><br><span class="line">                x = &quot;a = 100&quot;;</span><br><span class="line">            &#125;else if(&quot;b = 10&quot;.equals(x))&#123;</span><br><span class="line">                x = &quot;b = 200&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            super.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.setOut(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法用的是重写，当要调用println()这个方法分时候不是调用Java库中的println()方法，而是调用这里自己写的这个，就把要输出的“a &#x3D; 10”替换成了”a &#x3D; 100”。</p>
<h3 id="第二题（微软面试题）"><a href="#第二题（微软面试题）" class="headerlink" title="第二题（微软面试题）"></a>第二题（微软面试题）</h3><blockquote>
<p> 定义一个int型的数组: int[] arr &#x3D; new int]{12,3,3,34,56,77,432};让数组的每个位置上的值去除以首位置的元素,得到的结果,作为该位置上的新值。遍历新的数组。 </p>
</blockquote>
<p>这个题其实很简单，但是一不小心就会出错，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i = 0;i &lt; arr.length;i++)</span><br><span class="line">  arr[i] = arr[i]/arr[0];</span><br></pre></td></tr></table></figure>

<p>自己一顿操作之后以为稳了，实际上结果和原数组是一样的。这样从前面向后面遍历，数组第一个值在第一次就变成1了，之后每次除的arr[0]都是1，所以后面的值都没有发生变化。</p>
<p>所以简单的题不要掉以轻心。</p>
<p>正确的写法很简单也不止一种方法，可以从后向前遍历数组，也可以把数组的第一个值赋给一个临时变量，后面的数都除以这个临时变量。</p>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    int[] arr1 = new int[]&#123;1,2,3&#125;;</span><br><span class="line">    System.out.println(arr1);</span><br><span class="line"></span><br><span class="line">    char[] arr2 = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span><br><span class="line">    System.out.println(arr2); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问输出的分别是什么？</p>
<p>正确答案是arr1输出的是地址值，arr2输出的是abc。</p>
<p>这其实考的是一个很细的知识点，了解过后就会感觉这个题很low，简直是在是在侮辱自己的智商，不了解的话可能就认为两个都是输出一个地址值。</p>
<p>这里涉及到了Java中方法的重载，同一个函数名，但是传的参数个数或者参数类型不同的话，他调的方法是不一样的。</p>
<p>第一个整型的数组，传入的是object类型，调用的是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void println(Object x) &#123;</span><br><span class="line">  String s = String.valueOf(x);</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    print(s);</span><br><span class="line">    newLine();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个字符型的数组，传入的是char型的数组，调用的是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void println(char x[]) &#123;</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    print(x);</span><br><span class="line">    newLine();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><blockquote>
<p> 如下两个题目输出结果相同吗？各是什么： </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object o1 = true ? new Integer(1) : new Double(2.0);</span><br><span class="line">System.out.println(o1);</span><br><span class="line"></span><br><span class="line">Object o2;</span><br><span class="line">if (true)</span><br><span class="line">    o2 = new Integer(1);</span><br><span class="line">else</span><br><span class="line">    o2 = new Double(2.0);</span><br><span class="line">System.out.println(o2);</span><br></pre></td></tr></table></figure>

<p>正确答案：</p>
<p>o1输出的是1.0，o2输出的是1</p>
<p>这个题是看似在考Object类中的方法，但是实际上，这里的三元运算符涉及到一个自动类型提升的问题</p>
<p>(表达式1)?(表达式2):(表达式3)</p>
<p>三元运算的最后结果是这三个表达式中的类型“最高”的一种，在计算的过程个中会有自动类型提升</p>
<h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void method1() &#123;</span><br><span class="line">  Integer i = new Integer(1);</span><br><span class="line">  Integer j = new Integer(1);</span><br><span class="line">  System.out.println(i == j);</span><br><span class="line">  Integer m = 1;</span><br><span class="line">  Integer n = 1;</span><br><span class="line">  System.out.println(m == n);//</span><br><span class="line">  Integer x = 128;</span><br><span class="line">  Integer y = 128;</span><br><span class="line">  System.out.println(x == y);//</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个输出为false，第二个输出为true，第三个输出为false。</p>
<p>Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[],保存了从-128<del>127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在 -128</del>127范围内时，可以直接使用数组中的元素，不用再去new了。目的：提高效率。</p>
<p>Integer类中的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static class IntegerCache &#123;</span><br><span class="line">  static final int low = -128;</span><br><span class="line">  static final int high;</span><br><span class="line">  static final Integer cache[];</span><br><span class="line">  static &#123;</span><br><span class="line">    // high value may be configured by property</span><br><span class="line">    int h = 127;</span><br><span class="line">    String integerCacheHighPropValue =</span><br><span class="line">      sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">    if (integerCacheHighPropValue != null) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">        i = Math.max(i, 127);</span><br><span class="line">        // Maximum array size is Integer.MAX_VALUE</span><br><span class="line">        h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">      &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">        // If the property cannot be parsed into an int, ignore it.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = new Integer[(high - low) + 1];</span><br><span class="line">    int j = low;</span><br><span class="line">    for(int k = 0; k &lt; cache.length; k++)</span><br><span class="line">      cache[k] = new Integer(j++);</span><br><span class="line"></span><br><span class="line">    // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">    assert IntegerCache.high &gt;= 127;</span><br><span class="line">  &#125;</span><br><span class="line">  private IntegerCache() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的栈和队列</title>
    <url>/2024/08/01/Java%E4%B8%AD%E7%9A%84%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>先进后出（FILO）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// push 操作</span></span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// peek 操作</span></span><br><span class="line">System.out.println(<span class="string">&quot;栈顶元素: &quot;</span> + stack.peek()); <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pop 操作</span></span><br><span class="line">System.out.println(<span class="string">&quot;弹出元素: &quot;</span> + stack.pop()); <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前栈顶元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;新的栈顶元素: &quot;</span> + stack.peek()); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>push</strong>: 将元素压入栈顶。</li>
<li><strong>pop</strong>: 移除并返回栈顶元素。</li>
<li><strong>peek</strong>: 返回栈顶元素但不移除它。</li>
</ul>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>先进先出（FIFO）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// offer 操作</span></span><br><span class="line">queue.offer(<span class="number">1</span>);</span><br><span class="line">queue.offer(<span class="number">2</span>);</span><br><span class="line">queue.offer(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// peek 操作</span></span><br><span class="line">System.out.println(<span class="string">&quot;队列头部元素: &quot;</span> + queue.peek()); <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// poll 操作</span></span><br><span class="line">System.out.println(<span class="string">&quot;移除的元素: &quot;</span> + queue.poll()); <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前队列头部元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;新的队列头部元素: &quot;</span> + queue.peek()); <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列是否为空</span></span><br><span class="line">System.out.println(<span class="string">&quot;队列是否为空: &quot;</span> + queue.isEmpty()); <span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列的大小</span></span><br><span class="line">System.out.println(<span class="string">&quot;队列的大小: &quot;</span> + queue.size()); <span class="comment">// 输出 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>offer</strong>: 将元素添加到队列尾部。</li>
<li><strong>poll</strong>: 移除并返回队列头部的元素。</li>
<li><strong>peek</strong>: 返回队列头部的元素但不移除它。</li>
</ul>
<h2 id="双端队列（Deque）"><a href="#双端队列（Deque）" class="headerlink" title="双端队列（Deque）"></a>双端队列（Deque）</h2><p>双端队列（Deque, Double Ended Queue）是允许在两端进行插入和删除操作的队列。Java中的<code>ArrayDeque</code>类是<code>Deque</code>接口的一个实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在队列头部和尾部添加元素</span></span><br><span class="line">deque.addFirst(<span class="number">1</span>);</span><br><span class="line">deque.addLast(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在队列头部和尾部移除元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;移除头部元素: &quot;</span> + deque.removeFirst()); <span class="comment">// 输出 1</span></span><br><span class="line">System.out.println(<span class="string">&quot;移除尾部元素: &quot;</span> + deque.removeLast()); <span class="comment">// 输出 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础之多线程</title>
    <url>/2020/05/17/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="程序、进程、线程的基本概念"><a href="#程序、进程、线程的基本概念" class="headerlink" title="程序、进程、线程的基本概念"></a>程序、进程、线程的基本概念</h1><h2 id="程序（program）"><a href="#程序（program）" class="headerlink" title="程序（program）"></a>程序（program）</h2><p>是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。</p>
<h2 id="进程（process）"><a href="#进程（process）" class="headerlink" title="进程（process）"></a>进程（process）</h2><p>是程序的一次执行过程，或是正在运行的一个程序。是一个动态 的过程：有它自身的产生、存在和消亡的过程。</p>
<ul>
<li>如：运行中的QQ，运行中的MP3播放器 </li>
<li>程序是静态的，进程是动态的 </li>
<li>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</li>
</ul>
<span id="more"></span>

<h2 id="线程（thread）"><a href="#线程（thread）" class="headerlink" title="线程（thread）"></a>线程（thread）</h2><p>进程可进一步细化为线程，是一个程序内部的一条执行路径。若一个进程同一时间并行执行多个线程，就是支持多线程的。线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销比进程小。一个进程中的多个线程共享相同的内存单元&#x2F;内存地址空间 -&gt; 它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。</p>
<h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事</p>
<p>并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。</p>
<h1 id="线程的创建和使用"><a href="#线程的创建和使用" class="headerlink" title="线程的创建和使用"></a>线程的创建和使用</h1><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ol>
<li>Thread()：创建新的Thread对象</li>
<li>Thread(String threadName)：创建线程，并指定线程实例</li>
<li>Thread(Runnable target)：指定创建线程的目标对象，他实现了Runnable接口中的run方法</li>
<li>Thread(Runnable target, String name)：创建新的Thread对象</li>
</ol>
<h3 id="常见的方法"><a href="#常见的方法" class="headerlink" title="常见的方法"></a>常见的方法</h3><ol>
<li>void start(): 启动线程，并执行对象的run()方法 </li>
<li>run(): 线程在被调度时执行的操作 </li>
<li>String getName(): 返回线程的名称 </li>
<li>void setName(String name):设置该线程名称 </li>
<li>static Thread currentThread(): 返回当前线程，在Thread子类中就 是this</li>
<li>static void yield()：线程让步，暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程</li>
<li>join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止，优先级比当前线程低的线程也可以获取到执行权</li>
<li>static void sleep(long millis)：(指定时间:毫秒) ，令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队，此方法抛出了InterruptedException。</li>
</ol>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><h3 id="方式一：继承Thread类"><a href="#方式一：继承Thread类" class="headerlink" title="方式一：继承Thread类"></a>方式一：继承Thread类</h3><p>具体步骤：</p>
<ol>
<li>定义子类继承Thread类</li>
<li>子类重写Thread类中的run()方法</li>
<li>创建Thread子类对象，即创建线程的对象</li>
<li>启动线程，调用线程对象的start()方法</li>
</ol>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTest</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    t1.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(currentThread().getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。</li>
<li>run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。</li>
<li>想要启动多线程，必须调用start方法。</li>
<li>一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出异常 “IllegalThreadStateException”。</li>
</ol>
<h3 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h3><p>具体步骤：</p>
<ol>
<li>定义子类，实现Runnable接口</li>
<li>子类重写Runnable接口中的run()方法</li>
<li>通过Thread类含参构造器创建线程对象，将Runnable接口的子类对象作为实际参数传递给Thread类的构造器</li>
<li>调用Thread类的start()方法</li>
</ol>
<h3 id="继承方式与实现方式的区别"><a href="#继承方式与实现方式的区别" class="headerlink" title="继承方式与实现方式的区别"></a>继承方式与实现方式的区别</h3><ol>
<li>继承Thread类：线程代码存放在Thread子类run()方法中</li>
<li>实现Runnable：线程代码存放在接口子类的run() 方法中</li>
<li>实现的方法避免了单继承的局限性</li>
<li>多个线程可以共享同一个接口实现类的对象，比较适合多个线程来处理同一份资源</li>
</ol>
<h2 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h2><p>java中线程的调度策略是抢占式的，高优先级的线程抢占CPU</p>
<p>java中线程的调度方法：</p>
<ul>
<li>同优先级线程组成先进先出队列（先到先服务），使用时间片策略</li>
<li>对高优先级，使用优先调度的抢占式策略</li>
</ul>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><h3 id="线程的优先等级"><a href="#线程的优先等级" class="headerlink" title="线程的优先等级"></a>线程的优先等级</h3><ul>
<li>MAX_PRIORITY：10  最高优先级</li>
<li>MIN _PRIORITY：1  最低优先级</li>
<li>NORM_PRIORITY：5  默认优先级</li>
</ul>
<h4 id="相关的方法"><a href="#相关的方法" class="headerlink" title="相关的方法"></a>相关的方法</h4><ol>
<li>getPriority()：获取线程的优先等级</li>
<li>setPriority()：设置线程的优先级</li>
</ol>
<p>说明：</p>
<ul>
<li>线程创建时继承父线程的优先级</li>
<li>低优先级只是获得调度的概率低，并不一定是在高优先级的线程之后才被调用</li>
</ul>
<h3 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h3><p>Java中的线程分为两类：一种是守护线程，一种是用户线程</p>
<p>它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。守护线程是用来服务用户线程的，通过在start()方法前调用 thread.setDaemon(true)可以把一个用户线程变成一个守护线程。Java垃圾回收就是一个典型的守护线程。若JVM中都是守护线程，当前JVM将退出。 </p>
<p>形象理解：兔死狗烹，鸟尽弓藏</p>
<h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p><strong>JDK中用Thread.State类定义了线程的几种状态</strong></p>
<p>要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：</p>
<ul>
<li>新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建 状态</li>
<li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源 </li>
<li>运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能 </li>
<li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态 </li>
<li>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>
</ul>
<img data-src="/images/Java基础之多线程/image-20200518193548122.png" alt="image-20200518193548122" style="zoom:80%;" />

<h1 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h1><p>多个线程操作同一个共享的数据会出现线程的安全问题，为了解决这一问题，就引入了线程的同步</p>
<p>比如：如果两个人同时操作一个银行账户，进行取钱操作，如果账户里面有一千元，甲要取1000，乙也要取1000，如果甲进入到取钱的操作里面（进入取钱之前有个判断，如果取的钱小于账户余额才能进入），但是还没有按下最后的取钱按钮（账户余额还是没变），这个时候乙也进入到取钱的页面了（现在余额还是1000，所以可以进入），最后两个人都按下取钱的按钮，银行账户就会出现-1000元的情况。显然，这是不合理的。</p>
<p>再举个例子：模拟火车站售票程序，同时开启三个售票窗口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tick</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + </span><br><span class="line">                           <span class="string">&quot;售出车票，tick号为：&quot;</span> + tick--);</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Ticket</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">    t1.setName(<span class="string">&quot;t1窗口&quot;</span>);</span><br><span class="line">    t2.setName(<span class="string">&quot;t2窗口&quot;</span>);</span><br><span class="line">    t3.setName(<span class="string">&quot;t3窗口&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上这种写法也是存在线程不安全问题，举一个最简单的情况，当tick为1时，如果线程1进入到if判断里面，但是还没有执行tick–，这个时候线程2也是可以进入到if判断里面的，但是最后输出的时候就会出现票号为0的票。如果在线程1还没将tick–之前，线程3也进入到if里面了，那最后会输出一个-1号票，这就是线程的不安全问题。</p>
<p>用个图来直观的表示：</p>
<img data-src="/images/Java基础之多线程/image-20200518203236660.png" alt="image-20200518203236660" style="zoom:80%;" />

<p>很显然，这里出现的线程安全问题是因为：当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。</p>
<p>要解决这个问题也很简单，就是在同一个时间内只让一个线程操作与共享数据相关的代码，在这部分代码没执行完之前，其他进程不能执行这部分代码。</p>
<h2 id="Synchronized的使用方法"><a href="#Synchronized的使用方法" class="headerlink" title="Synchronized的使用方法"></a>Synchronized的使用方法</h2><ul>
<li>Java对于多线程的安全问题提供了专业的解决方式：同步机制</li>
</ul>
<p>有两种方式来使用这个同步机制：</p>
<ol>
<li><p>同步代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象)&#123;<span class="comment">//这个对象是用来充当同步监视器的，俗称锁</span></span><br><span class="line">	<span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>synchronized还可以放在方法声明中，表示整个方法为同步方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="同步机制中的锁"><a href="#同步机制中的锁" class="headerlink" title="同步机制中的锁"></a>同步机制中的锁</h3><blockquote>
<p>在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。</p>
</blockquote>
<p>synchronized的锁是什么？</p>
<ul>
<li>任意对象都可以作为同步锁。所有对象都自动含有单一的锁（同步监视器）</li>
<li>同步方法的锁：静态方法（类名.class）、非静态方法（this） </li>
<li>同步代码块：自己指定，很多时候也是指定为this或类名.class</li>
</ul>
<p>注意：</p>
<ol>
<li>必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则任然无法保证共享资源的安全</li>
<li>一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this），同步代码块（指定需谨慎）</li>
</ol>
<h2 id="同步范围的确定"><a href="#同步范围的确定" class="headerlink" title="同步范围的确定"></a>同步范围的确定</h2><p>判断代码是否存在线程安全问题：</p>
<ol>
<li>明确哪些代码是被多线程执行的</li>
<li>多个线程之间是否存在共享数据</li>
<li>多线程运行代码中是否有多条语句操作共享数据</li>
</ol>
<p>注意：</p>
<p>同步代码范围太大：没有发挥出多线程的功能</p>
<p>同步代码范围太小：不能解决存在的安全问题</p>
<h2 id="线程释放锁的操作"><a href="#线程释放锁的操作" class="headerlink" title="线程释放锁的操作"></a>线程释放锁的操作</h2><ol>
<li>当前线程的同步方法、同步代码块执行结束。 </li>
<li>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。 </li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。 </li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。</li>
</ol>
<p>注意：</p>
<ol>
<li>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法当前线程不会释放锁</li>
<li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁</li>
</ol>
<p>讲到这里，我们解决一下上面火车票售票那个示例和之前单例模式的懒汉式的线程不安全问题</p>
<p>火车售票</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tick</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + </span><br><span class="line">                             <span class="string">&quot;售出车票，tick号为：&quot;</span> + tick--);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Ticket</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">    t1.setName(<span class="string">&quot;t1窗口&quot;</span>);</span><br><span class="line">    t2.setName(<span class="string">&quot;t2窗口&quot;</span>);</span><br><span class="line">    t3.setName(<span class="string">&quot;t3窗口&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例设计模式之懒汉式(线程安全)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;<span class="comment">//加上这个判断可以提高运行的效率</span></span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">          instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125; </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Singleton s1=Singleton.getInstance();</span><br><span class="line">    Singleton s2=Singleton.getInstance();</span><br><span class="line">    System.out.println(s1==s2);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程的死锁问题"><a href="#线程的死锁问题" class="headerlink" title="线程的死锁问题"></a>线程的死锁问题</h2><ul>
<li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁 </li>
<li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">StringBuffer</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">          s2.append(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">          <span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">            s2.append(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            System.out.print(s1);</span><br><span class="line">            System.out.print(s2);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">          s2.append(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">          <span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">            s1.append(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">            System.out.print(s2);</span><br><span class="line">            System.out.print(s1);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="Lock(锁)"></a>Lock(锁)</h2><p>在JDK5.0之后，Java提供了更强大的线程同步机制——通过显示的定义同步锁对象来实现同步，这里的同步锁用Lock对象充当。</p>
<p>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p>
<p>ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和 内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReenTrantLock</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">//保证线程安全的代码;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果同步代码有异常，要将unlock()写入finally语句块</p>
<h2 id="synchronized-与-Lock-的对比"><a href="#synchronized-与-Lock-的对比" class="headerlink" title="synchronized 与 Lock 的对比"></a>synchronized 与 Lock 的对比</h2><ol>
<li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放 </li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁 </li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li>
</ol>
<h1 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h1><p>先介绍几种线程通信要用到的几种方法：</p>
<ul>
<li><p>wait():</p>
<p>令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。</p>
</li>
<li><p>notify():</p>
<p>唤醒正在排队等待同步资源的线程中优先级最高的</p>
</li>
<li><p>notifyAll():</p>
<p>唤醒正在排队等待同步资源的所有线程</p>
</li>
</ul>
<p>注意：</p>
<ol>
<li>这三个方法只有在synchronized方法或代码块中才能使用，否则会报java.lang.IllegalMonitorStateException</li>
<li>因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁，因此这三个方法只能在Object类中声明</li>
</ol>
<h2 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait()方法"></a>wait()方法</h2><p>在当前线程中调用方法： 对象名.wait() </p>
<p>使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出notify (或notifyAll) 为止。 </p>
<p>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁） </p>
<p>调用此方法后，当前线程将释放对象监控权 ，然后进入等待 </p>
<p>在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。</p>
<h2 id="notify-x2F-notifyAll"><a href="#notify-x2F-notifyAll" class="headerlink" title="notify()&#x2F;notifyAll()"></a>notify()&#x2F;notifyAll()</h2><p>在当前线程中调用方法： 对象名.notify() </p>
<p>功能：唤醒等待该对象监控权的一个&#x2F;所有线程。 </p>
<p>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</p>
<h1 id="JDK5-0新增线程创建方式"><a href="#JDK5-0新增线程创建方式" class="headerlink" title="JDK5.0新增线程创建方式"></a>JDK5.0新增线程创建方式</h1><h2 id="新增方式一：实现Callable接口"><a href="#新增方式一：实现Callable接口" class="headerlink" title="新增方式一：实现Callable接口"></a>新增方式一：实现Callable接口</h2><p>与使用Runnable相比， Callable功能更强大些 </p>
<ul>
<li>相比run()方法，可以有返回值 </li>
<li>方法可以抛出异常 </li>
<li>支持泛型的返回值 </li>
<li>需要借助FutureTask类，比如获取返回结果</li>
</ul>
<p>Future接口 </p>
<ul>
<li><p>可以对具体Runnable、Callable任务的执行结果进行取消、查询是 否完成、获取结果等。 </p>
</li>
<li><p>FutrueTask是Futrue接口的唯一的实现类 </p>
</li>
<li><p>FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</p>
</li>
</ul>
<h2 id="新增方式二：使用线程池"><a href="#新增方式二：使用线程池" class="headerlink" title="新增方式二：使用线程池"></a>新增方式二：使用线程池</h2><p>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程， 对性能影响很大。 </p>
<p>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完 放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交 通工具。 </p>
<p>好处： </p>
<ol>
<li>提高响应速度（减少了创建新线程的时间） </li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建） </li>
<li>便于线程管理 <ul>
<li>corePoolSize：核心池的大小 </li>
<li>maximumPoolSize：最大线程数 </li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
</ul>
</li>
</ol>
<h3 id="线程池相关API"><a href="#线程池相关API" class="headerlink" title="线程池相关API"></a>线程池相关API</h3><p>JDK 5.0起提供了线程池相关API：ExecutorService 和 Executors </p>
<p>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor </p>
<ul>
<li><p>void execute(Runnable command) ：执行任务&#x2F;命令，没有返回值，一般用来执行 Runnable </p>
</li>
<li><p>Future submit(Callable task)：执行任务，有返回值，一般又来执行 Callable </p>
</li>
<li><p>void shutdown() ：关闭连接池</p>
</li>
</ul>
<p>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</p>
<ul>
<li><p>Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池 </p>
</li>
<li><p>Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池 </p>
</li>
<li><p>Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池 </p>
</li>
<li><p>Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运 行命令或者定期地执行。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础之泛型</title>
    <url>/2020/06/28/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h1><h2 id="设计背景"><a href="#设计背景" class="headerlink" title="设计背景"></a>设计背景</h2><p>集合容器类在设计阶段&#x2F;声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection&lt;E&gt;，List&lt;E&gt;，ArrayList&lt;E&gt; 这个就&lt;E&gt;是类型参数，即泛型。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如， 继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实 际的类型参数，也称为类型实参）。</p>
<p>从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念， 允许我们在创建集合时指定集合元素的类型，正如：List&lt;String&gt;，这表明该List只能保存字符串类型的对象。</p>
<p>JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参。</p>
<span id="more"></span>

<h2 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h2><ol>
<li>解决元素存储的安全性问题，好比商品、药品标签，不会弄错。 </li>
<li>解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别。</li>
</ol>
<img data-src="/images/Java基础之泛型/image-20200628145513962.png" alt="image-20200628145513962" style="zoom:80%;" />

<p><img data-src="/images/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B/image-20200628145525503.png" alt="image-20200628145525503"></p>
<p><img data-src="/images/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B/image-20200628145525503.png" alt="image-20200628145525503"></p>
<p>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。</p>
<h1 id="在集合中使用泛型"><a href="#在集合中使用泛型" class="headerlink" title="在集合中使用泛型"></a>在集合中使用泛型</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//类型推断</span></span><br><span class="line">list.add(<span class="number">78</span>);</span><br><span class="line">list.add(<span class="number">88</span>);</span><br><span class="line">list.add(<span class="number">77</span>);</span><br><span class="line">list.add(<span class="number">66</span>);</span><br><span class="line"><span class="comment">//遍历方式一：</span></span><br><span class="line"><span class="keyword">for</span>(Integer i : list)&#123;</span><br><span class="line"><span class="comment">//不需要强转</span></span><br><span class="line">System.out.println(i);</span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//遍历方式二：</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">  System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line">map.put(<span class="string">&quot;Tom1&quot;</span>,<span class="number">34</span>);</span><br><span class="line">map.put(<span class="string">&quot;Tom2&quot;</span>,<span class="number">44</span>);</span><br><span class="line">map.put(<span class="string">&quot;Tom3&quot;</span>,<span class="number">33</span>);</span><br><span class="line">map.put(<span class="string">&quot;Tom4&quot;</span>,<span class="number">32</span>);</span><br><span class="line"><span class="comment">//添加失败</span></span><br><span class="line"><span class="comment">//map.put(33, &quot;Tom&quot;);</span></span><br><span class="line">Set&lt;Entry&lt;String,Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String,Integer&gt;&gt; iterator = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">  Entry&lt;String,Integer&gt; entry = iterator.next();</span><br><span class="line">  System.out.println(entry.getKey() + <span class="string">&quot;---&gt;&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自定义泛型结构"><a href="#自定义泛型结构" class="headerlink" title="自定义泛型结构"></a>自定义泛型结构</h1><ol>
<li><p>泛型的声明</p>
<p>interface List&lt;T&gt;和class GenTest&lt;K,V&gt;</p>
<p>其中T、K、V不代表值，而是代表类型，使用任意字母都可以。</p>
<p>常用T表示（Type）</p>
</li>
<li><p>泛型的实例化</p>
<p>一定要在类名后面指定类型参数的值（类型）。 如：<br>List&lt;String&gt; strList &#x3D; new ArrayList&lt;String&gt;();<br>Iterator&lt;Customer&gt; iterator &#x3D; customers.iterator();</p>
</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>T只能是类名，不能用基本数据类型填充，可以用包装类填充。</li>
<li><strong>把一个集合中的内容限制为一个特定的数据类型，这就是generics背后的核心思想</strong></li>
</ul>
<p>使用泛型的主要一个有点就是能够在编译时而不是在运行时检测错误。</p>
<h2 id="泛型类、泛型接口"><a href="#泛型类、泛型接口" class="headerlink" title="泛型类、泛型接口"></a>泛型类、泛型接口</h2><ol>
<li><p>泛型类堪忧多个参数，此时应将多个参数一起放到尖括号内，例如：&lt;E1,E2,E3&gt;</p>
</li>
<li><p>泛型类的构造器：public GenericClass(){}  错误写法：public GenericClass&lt;E&gt;(){}</p>
</li>
<li><p>实例化之后，操作原来泛型位置的结构必须与指定的泛型结构一致</p>
</li>
<li><p>泛型不同的引用不能互相赋值</p>
</li>
<li><p>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价 于Object。</p>
<p>泛型要使用一路都用。要不用，一路都不要用。</p>
</li>
<li><p>jdk1.7，泛型的简化操作：ArrayList&lt;Fruit&gt; flist &#x3D; new ArrayList&lt;&gt;();</p>
</li>
<li><p>泛型的指定中不能使用基本数据类型，可以使用包装类代替</p>
</li>
<li><p>不能使用new E[]。但是可以：E[] elements &#x3D; (E[])new Object[capacity]; </p>
<p>参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。</p>
</li>
<li><p>父类有泛型，子类可以选择保留泛型，也可以选择指定的泛型类型</p>
<p>子类不保留父类的泛型：按需实现，子类没有指定泛型类型的话，默认为Object</p>
<p>子类保留弗雷德泛型：泛型子类</p>
<p>结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)没有类型 擦除</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;<span class="comment">// 等价于class Son extends Father&lt;Object,Object&gt;&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)具体类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, String&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)全部保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>&lt;T1, T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)部分保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)没有类型 擦除</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>&lt;A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;<span class="comment">//等价于class Son extends Father&lt;Object,Object&gt;&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)具体类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>&lt;A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, String&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)全部保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>&lt;T1, T2, A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)部分保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2, A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, T2&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>方法，也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。</p>
<p>泛型方法格式：[访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出的异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fromArrayToCollection</span><span class="params">(T[] a, Collection&lt;T&gt; c)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (T o : a) &#123;</span><br><span class="line">    c.add(o);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  Object[] ao = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">  Collection&lt;Object&gt; co = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">  fromArrayToCollection(ao, co);</span><br><span class="line">  String[] sa = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">20</span>];</span><br><span class="line">  Collection&lt;String&gt; cs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  fromArrayToCollection(sa, cs);</span><br><span class="line">  Collection&lt;Double&gt; cd = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 下面代码中T是Double类，但sa是String类型，编译错误。</span></span><br><span class="line">  <span class="comment">// fromArrayToCollection(sa, cd);</span></span><br><span class="line">  <span class="comment">// 下面代码中T是Object类型，sa是String类型，可以赋值成功。</span></span><br><span class="line">  fromArrayToCollection(sa, co);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Creature</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Creature</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T t)</span>&#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">Man</span>());</span><br><span class="line">    <span class="comment">//The method test(T) in the type PersonTest is not</span></span><br><span class="line">    <span class="comment">//applicable for the arguments (Creature)</span></span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">Creature</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型在继承上的体现"><a href="#泛型在继承上的体现" class="headerlink" title="泛型在继承上的体现"></a>泛型在继承上的体现</h1><p>如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，G&lt;B&gt;并不是G的子类型&lt;A&gt;</p>
<p>比如：String是Object的子类，但是List&lt;String&gt;并不是List&lt;Object&gt;的子类。</p>
<h1 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h1><ul>
<li><p>使用类型通配符：“？” </p>
<p>比如：List&lt;?&gt; ，Map&lt;?,?&gt; </p>
<p>List&lt;?&gt;是List&lt;String&gt;、List&lt;Object&gt;等各种泛型List的父类。</p>
</li>
<li><p>读取List&lt;?&gt;的对象list中的元素时，永远是安全的，因为不管list的真实类型是什么，它包含的都是Object。</p>
</li>
<li><p>不能向list写入元素，因为我们不知道c的元素类型，我们不能向其中添加对象，唯一的例外是null，它是所有类型的成员</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line">  list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">  list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Double&gt;();</span><br><span class="line">  <span class="comment">// list.add(3);//编译不通过</span></span><br><span class="line">  list.add(<span class="literal">null</span>);</span><br><span class="line">  List&lt;String&gt; l1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">  List&lt;Integer&gt; l2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">  l1.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">  l2.add(<span class="number">15</span>);</span><br><span class="line">  read(l1);</span><br><span class="line">  read(l2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">    System.out.println(o);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>编译错误：不能用在泛型方法声明上，返回值类型前面的&lt;&gt;不能使用“?”，例如：</p>
<p>public static &lt;?&gt; void test(ArrayList list){}</p>
</li>
<li><p>编译错误：不能用在泛型类的声明上</p>
<p>class GenericTypeClass &lt;?&gt;{}</p>
</li>
<li><p>编译错误：不能用在创建对象上，右边属于创建集合对象</p>
<p>ArrayList&lt;?&gt; list2 &#x3D; new ArrayList&lt;?&gt;();</p>
</li>
</ol>
<h2 id="有限制的通配符"><a href="#有限制的通配符" class="headerlink" title="有限制的通配符"></a>有限制的通配符</h2><ul>
<li><p>通配符指定上限 </p>
<p>上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;&#x3D; </p>
</li>
<li><p>通配符指定下限 </p>
<p>下限super：使用时指定的类型不能小于操作的类，即&gt;&#x3D;</p>
</li>
<li><p>举例：</p>
<ul>
<li><p>&lt;? extends Number&gt;   (无穷小, Number]</p>
<p>只允许泛型为Number及Number子类的引用调用</p>
</li>
<li><p>&lt;? super Number&gt;   [Number, 无穷大)</p>
<p>只允许泛型为Number及其父类的引用调用</p>
</li>
<li><p>&lt;? entends Conparable&gt;</p>
<p>只允许泛型为实现Comparable接口的实现类的引用调用</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printCollection3</span><span class="params">(Collection&lt;? extends Person&gt; coll)</span> &#123;</span><br><span class="line">  <span class="comment">//Iterator只能用Iterator&lt;?&gt;或Iterator&lt;? extends Person&gt;.why?</span></span><br><span class="line">  Iterator&lt;?&gt; iterator = coll.iterator();</span><br><span class="line">  <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printCollection4</span><span class="params">(Collection&lt;? <span class="built_in">super</span> Person&gt; coll)</span> &#123;</span><br><span class="line">  <span class="comment">//Iterator只能用Iterator&lt;?&gt;或Iterator&lt;? super Person&gt;.why?</span></span><br><span class="line">  Iterator&lt;?&gt; iterator = coll.iterator();</span><br><span class="line">  <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型嵌套举例"><a href="#泛型嵌套举例" class="headerlink" title="泛型嵌套举例"></a>泛型嵌套举例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  HashMap&lt;String, ArrayList&lt;Citizen&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, ArrayList&lt;Citizen&gt;&gt;();</span><br><span class="line">  ArrayList&lt;Citizen&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Citizen&gt;();</span><br><span class="line">  list.add(<span class="keyword">new</span> <span class="title class_">Citizen</span>(<span class="string">&quot;刘恺威&quot;</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> <span class="title class_">Citizen</span>(<span class="string">&quot;杨幂&quot;</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> <span class="title class_">Citizen</span>(<span class="string">&quot;小糯米&quot;</span>));</span><br><span class="line">  map.put(<span class="string">&quot;刘恺威&quot;</span>, list);</span><br><span class="line">  Set&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">  Iterator&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; iterator = entrySet.iterator();</span><br><span class="line">  <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Entry&lt;String, ArrayList&lt;Citizen&gt;&gt; entry = iterator.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    ArrayList&lt;Citizen&gt; value = entry.getValue();</span><br><span class="line">    System.out.println(<span class="string">&quot;户主：&quot;</span> + key);</span><br><span class="line">    System.out.println(<span class="string">&quot;家庭成员：&quot;</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础之集合框架</title>
    <url>/2020/06/16/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Java-集合框架概述"><a href="#Java-集合框架概述" class="headerlink" title="Java 集合框架概述"></a>Java 集合框架概述</h1><blockquote>
<p>一方面， 面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。另一方面，使用Array存储对象方面具有一些弊端，而Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中。</p>
</blockquote>
<ul>
<li><p>数组在内存中存储方面的特点：</p>
<p>​	数组初始化之后，长度就确定了，不能更改了</p>
<p>​	数组声明的类型，就决定了元素初始化时候的类型</p>
</li>
<li><p>数组在存储方面的弊端：</p>
<p>​	数组初始化之后，长度就不能改变了，不便于扩展</p>
<p>​	数组中提供的属性和方法较少，不便于进行增删改查插入等操作，且效率不高。数组无法直接获取存储元素的个数</p>
<p>​	数组存储的数据是有序的，可以重复的，存储的特点单一</p>
</li>
</ul>
<p>Java 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。</p>
<p>Java 集合可分为 Collection 和 Map 两种体系 ：</p>
<p>Collection接口：单列数据，定义了存取一组对象的方法的集合 </p>
<p>​	List：元素有序、可重复的集合 </p>
<p>​	Set：元素无序、不可重复的集合 </p>
<p>Map接口：双列数据，保存具有映射关系“key-value对”的集合</p>
<span id="more"></span>

<p>Collection接口继承树：</p>
<img data-src="/images/Java基础之集合框架/image-20200617143455167.png" alt="image-20200617143455167" style="zoom:67%;" />

<p>Map接口继承树：</p>
<img data-src="/images/Java基础之集合框架/image-20200617143554774.png" alt="image-20200617143554774" style="zoom:67%;" />

<h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>Collection 接口是 List、Set 和 Queue 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。</li>
<li>JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。</li>
<li>在 Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都 当成 Object 类型处理；从 JDK 5.0 增加了泛型以后，Java 集合可以记住容器中对象的数据类型。</li>
</ol>
<h2 id="Collection接口中的方法"><a href="#Collection接口中的方法" class="headerlink" title="Collection接口中的方法"></a>Collection接口中的方法</h2><ol>
<li><p>添加</p>
<p>add(Object obj)</p>
<p>addAll(Collection coll)</p>
</li>
<li><p>获取有效元素的个数</p>
<p>int size()</p>
</li>
<li><p>清空集合</p>
<p>void clear()</p>
</li>
<li><p>判断是否为空</p>
<p>boolean isEmpty()</p>
</li>
<li><p>判断是否包含某个元素</p>
<p>boolean contains(Object obj)   是通过元素的equals方法来判断是否是同一个对象</p>
<p>boolean contains(Collection coll)   也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。</p>
</li>
<li><p>删除</p>
<p>boolean remove(Object obj)   通过元素的equals方法判断是否存在该元素，再将其删除，但是只会删除找到的第一个匹配的元素</p>
<p>boolean removeAll(Collection coll)   取两个集合的差集</p>
</li>
<li><p>取两个集合的交集</p>
<p>boolean retainAll(Collection c)   把交集的结果存在当前集合中，c不会改变</p>
</li>
<li><p>集合是否相等</p>
<p>boolean equals(Object obj)</p>
</li>
<li><p>转换成对象数组</p>
<p>Object[] toArray()</p>
</li>
<li><p>获取集合对象的哈希值</p>
<p>hashCode()</p>
</li>
<li><p>遍历</p>
<p>iterator()  返回迭代器对象，用于遍历集合</p>
</li>
</ol>
<h3 id="Iterator迭代器接口"><a href="#Iterator迭代器接口" class="headerlink" title="Iterator迭代器接口"></a>Iterator迭代器接口</h3><ul>
<li><p>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。 </p>
</li>
<li><p>GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。 </p>
</li>
<li><p>Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了 Iterator接口的对象。 </p>
</li>
<li><p>Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。 </p>
</li>
<li><p>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</p>
</li>
</ul>
<h4 id="Iterator接口中的方法"><a href="#Iterator接口中的方法" class="headerlink" title="Iterator接口中的方法"></a>Iterator接口中的方法</h4><p>Collection集合常用下图所示方法遍历:</p>
<img data-src="/images/Java基础之集合框架/image-20200617152119103.png" alt="image-20200617152119103" style="zoom:67%;" />

<ol>
<li>boolean hasNext()  判断迭代器是否还有下一个元素</li>
<li>next()  将迭代器的指针移向下一个元素</li>
<li>remove()  移除一个元素</li>
</ol>
<p>注意：</p>
<ol>
<li>在调用next()方法之前，若果不用hasNext()进行检测，则可能会出现NoSuchElementException异常</li>
<li>Iterator删除集合的元素，是在遍历过程中通过迭代器对象的remove方法删除，而不是集合对象的remove()方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> coll.iterator();<span class="comment">//回到起点</span></span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iter.next();</span><br><span class="line">  <span class="keyword">if</span>(obj.equals(<span class="string">&quot;Tom&quot;</span>))&#123;</span><br><span class="line">    iter.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面这种用迭代器遍历集合的方法，还可以用foreach（又叫增强for循环）来遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object obj: coll)&#123;</span><br><span class="line">  System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者直接用Collection中的forEach()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">coll.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h2 id="Collection子接口：List接口"><a href="#Collection子接口：List接口" class="headerlink" title="Collection子接口：List接口"></a>Collection子接口：List接口</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>List集合类中元素有序、可以重复，集合中每个元素都有其对应的顺序索引，每个元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。List接口的实现类常用的有：ArrayList、LinkedList和Vector。</p>
<h3 id="List接口中的方法"><a href="#List接口中的方法" class="headerlink" title="List接口中的方法"></a>List接口中的方法</h3><p>List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。</p>
<ul>
<li>void add(int index, Object elem)  在index位置插入elem元素</li>
<li>boolean addAll(int index, Collection eles)  从index位置开始将eles中的所有元素添加进来</li>
<li>Object get(int index)  获取指定index位置的元素</li>
<li>int indexOf(Object obj)  返回obj在集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj)  返回obj在当前集合中末次出现的位置</li>
<li>Object remove(int index)  移除指定index位置的元素，并返回此元素</li>
<li>Object set(int index, Object elem):设置指定index位置的元素为elem</li>
<li>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</li>
</ul>
<h3 id="List的主要实现类：ArrayList"><a href="#List的主要实现类：ArrayList" class="headerlink" title="List的主要实现类：ArrayList"></a>List的主要实现类：ArrayList</h3><p>ArrayList的底层还是通过数组来实现的</p>
<p>在JDK1.7中ArrayList像饿汉式，在创建List对象的时候就直接创建了一个初始容量为10的数组；</p>
<p>在JDK1.8中ArrayList像懒汉式，创建对象的时候创建一个长度为0的数组，当添加第一个元素的时候再创建一个容量为10的数组。</p>
<p>注意：Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合</p>
<h3 id="List实现类之二：LinkedList"><a href="#List实现类之二：LinkedList" class="headerlink" title="List实现类之二：LinkedList"></a>List实现类之二：LinkedList</h3><p>因为LinkedList底层是用链表实现的，所以插入和删除的效率比ArrayList要高，对于频繁的插入和删除，建议使用LinkedList。</p>
<p>LinkedList中的方法：</p>
<ul>
<li><p>void addFirst(Object obj) </p>
</li>
<li><p>void addLast(Object obj) </p>
</li>
<li><p>Object getFirst() </p>
</li>
<li><p>Object getLast() </p>
</li>
<li><p>Object removeFirst() </p>
</li>
<li><p>Object removeLast()</p>
</li>
</ul>
<p>具体的底层实现：</p>
<p>LinkedList底层是用双向链表实现的，内部定义了Node类型的first和last，用于记录首末元素。同时定义内部类Node，作为LinkedList保存数据的基本结构，Node除了保存数据还定义了两个变量：</p>
<ul>
<li>prev变量记录前一个元素的位置</li>
<li>next变量记录下一个元素的位置</li>
</ul>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">  E item;</span><br><span class="line">  Node&lt;E&gt; next;</span><br><span class="line">  Node&lt;E&gt; prev;</span><br><span class="line">  Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">    <span class="built_in">this</span>.item = element;</span><br><span class="line">    <span class="built_in">this</span>.next = next;</span><br><span class="line">    <span class="built_in">this</span>.prev = prev;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="/images/Java基础之集合框架/image-20200617204129667.png" alt="image-20200617204129667" style="zoom:67%;" />

<h3 id="List-实现类之三：Vector"><a href="#List-实现类之三：Vector" class="headerlink" title="List 实现类之三：Vector"></a>List 实现类之三：Vector</h3><p>Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。</p>
<p>新增方法:</p>
<p>void addElement(Object obj) </p>
<p>void insertElementAt(Object obj,int index) </p>
<p>void setElementAt(Object obj,int index) </p>
<p>void removeElement(Object obj) </p>
<p>void removeAllElements()</p>
<h3 id="ArrayList-x2F-LinkedList-x2F-Vector的异同"><a href="#ArrayList-x2F-LinkedList-x2F-Vector的异同" class="headerlink" title="ArrayList&#x2F;LinkedList&#x2F;Vector的异同"></a>ArrayList&#x2F;LinkedList&#x2F;Vector的异同</h3><ul>
<li><p>ArrayList和LinkedList的异同 </p>
<p>二者都线程不安全，相对线程安全的Vector，执行效率高。此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。</p>
</li>
<li><p>ArrayList和Vector的区别</p>
<p>Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用 ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。</p>
</li>
</ul>
<h2 id="Collection子接口：Set接口"><a href="#Collection子接口：Set接口" class="headerlink" title="Collection子接口：Set接口"></a>Collection子接口：Set接口</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul>
<li>Set接口是Collection的子接口，set接口没有提供额外的方法。</li>
<li>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set集合中，则添加操作失败。</li>
<li>Set 判断两个对象是否相同不是使用 &#x3D;&#x3D; 运算符，而是根据 equals() 方法</li>
</ul>
<h3 id="Set主要实现类：HashSet"><a href="#Set主要实现类：HashSet" class="headerlink" title="Set主要实现类：HashSet"></a>Set主要实现类：HashSet</h3><p>HashSet 按 Hash 算法来存储集合中的元素，具有很好的存取、查找、删除性能。</p>
<h4 id="HashSet特点"><a href="#HashSet特点" class="headerlink" title="HashSet特点"></a>HashSet特点</h4><ol>
<li>无序性，不能保证元素的排列顺序</li>
<li>不可重复性，HashSet中不能有两个相同的元素</li>
<li>线程不安全</li>
<li>集合元素可以为null</li>
</ol>
<p> HashSet判断两个元素相同的标准：</p>
<p>两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。</p>
<p><strong>注意：</strong></p>
<p>对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。</p>
<h4 id="向HashSet中添加元素的过程"><a href="#向HashSet中添加元素的过程" class="headerlink" title="向HashSet中添加元素的过程"></a>向HashSet中添加元素的过程</h4><p>​		首先会调用该对象的HashCode()方法，来得到该对象的HashCode值，然后根据HashCode的值，通过某种散列函数决定该对象在HashSet底层数组中的存储位置（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好）。</p>
<p>​		如果该位置没有存储其他元素，那么就直接添加成功；如果已经有元素了，则比较两个元素的HashCode值。</p>
<p>​		如果两个元素的哈希值不相等，那么就可以通过链表的方式将添加的元素和原来有的元素链接起来；如果两个元素的哈希值相等，就要调用equals() 方法比较两个元素是否一样了。</p>
<p>​		如果equals() 方法返回true，则添加失败，如果返回false，则添加成功，该元素通过链表的方式和原来链接的元素链接在一起。</p>
<p>HashSet的底层实现实际上是HashMap，如下图所示：</p>
<img data-src="/images/Java基础之集合框架/image-20200618104823685.png" alt="image-20200618104823685" style="zoom:80%;" />

<h3 id="Set实现类之二：LinkedHashSet"><a href="#Set实现类之二：LinkedHashSet" class="headerlink" title="Set实现类之二：LinkedHashSet"></a>Set实现类之二：LinkedHashSet</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>LinkedHashSet 是 HashSet 的子类</p>
<p>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，<strong>这使得元素看起来是以插入顺序保存的</strong>。</p>
<p>LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</p>
<img data-src="/images/Java基础之集合框架/image-20200618105842213.png" alt="image-20200618105842213" style="zoom:80%;" />

<h3 id="Set实现类之三：TreeSet"><a href="#Set实现类之三：TreeSet" class="headerlink" title="Set实现类之三：TreeSet"></a>Set实现类之三：TreeSet</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。TreeSet底层使用红黑树结构存储数据。</p>
<p>新增的方法如下： (了解) </p>
<ul>
<li>Comparator comparator() </li>
<li>Object first() </li>
<li>Object last() </li>
<li>Object lower(Object e) </li>
<li>Object higher(Object e) </li>
<li>SortedSet subSet(fromElement, toElement) </li>
<li>SortedSet headSet(toElement) </li>
<li>SortedSet tailSet(fromElement)</li>
</ul>
<img data-src="/images/Java基础之集合框架/image-20200618110742069.png" alt="image-20200618110742069" style="zoom:80%;" />

<h4 id="自然排序"><a href="#自然排序" class="headerlink" title="自然排序"></a>自然排序</h4><p>TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列。</p>
<p>注意：如果要把一个对象添加到TreeSet中，则该对象的类必须实现Comparable接口。实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。</p>
<p>向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。</p>
<p>因为只有相同类的两个实例才能比较，所以向 TreeSet 中添加的应该是同一个类的对象。</p>
<p>对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通 过 compareTo(Object obj) 方法比较返回值。</p>
<h4 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h4><p>TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来实现。需要重写compare(T o1,T o2)方法。</p>
<p>利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</p>
<p>注意：</p>
<ol>
<li>要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。</li>
<li>在这里仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异 常。</li>
<li>使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。</li>
</ol>
<p>面试题：</p>
<p>其中Person类中重写了hashCode()和equal()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">set.remove(p1);</span><br><span class="line">System.out.println(set);<span class="comment">//输出两个</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>));</span><br><span class="line">System.out.println(set);<span class="comment">//输出三个</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>));</span><br><span class="line">System.out.println(set);<span class="comment">//输出四个</span></span><br></pre></td></tr></table></figure>

<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p>Map接口继承树：</p>
<img data-src="/images/Java基础之集合框架/image-20200618153453173.png" alt="image-20200618153453173" style="zoom:67%;" />

<h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>Map与Collection并列存在。用于保存具有映射关系的数据:key-value&gt;</p>
</li>
<li><p>Map 中的 key 和 value 都可以是任何引用类型的数据</p>
</li>
<li><p>Map 中的 key 用Set来存放，不允许重复，即同一个 Map 对象所对应的类，必须重写hashCode()和equals()方法</p>
</li>
<li><p>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value</p>
</li>
<li><p>Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和 Properties。其中，HashMap是 Map 接口使用频率最高的实现类</p>
</li>
</ul>
<h2 id="Map接口的常用方法"><a href="#Map接口的常用方法" class="headerlink" title="Map接口的常用方法"></a>Map接口的常用方法</h2><h3 id="增删改相关方法"><a href="#增删改相关方法" class="headerlink" title="增删改相关方法"></a>增删改相关方法</h3><p>Object put(Object key,Object value)    将指定key-value添加到(或修改)当前map对象中 </p>
<p>void putAll(Map m)   将m中的所有key-value对存放到当前map中 </p>
<p>Object remove(Object key)   移除指定key的key-value对，并返回value </p>
<p>void clear()   清空当前map中的所有数据</p>
<h3 id="查询相关方法"><a href="#查询相关方法" class="headerlink" title="查询相关方法"></a>查询相关方法</h3><p>Object get(Object key)   获取指定key对应的value </p>
<p>boolean containsKey(Object key)  是否包含指定的key </p>
<p>boolean containsValue(Object value)：是否包含指定的value </p>
<p>int size()   返回map中key-value对的个数 </p>
<p>boolean isEmpty()   判断当前map是否为空 </p>
<p>boolean equals(Object obj)   判断当前map和参数对象obj是否相等</p>
<h3 id="元视图操作的相关方法"><a href="#元视图操作的相关方法" class="headerlink" title="元视图操作的相关方法"></a>元视图操作的相关方法</h3><p>Set keySet()   返回所有key构成的Set集合 </p>
<p>Collection values()   返回所有value构成的Collection集合 </p>
<p>Set entrySet()：返回所有key-value对构成的Set集合</p>
<h2 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//map.put(..,..)省略</span></span><br><span class="line">System.out.println(<span class="string">&quot;map的所有key:&quot;</span>);</span><br><span class="line"><span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> map.keySet();<span class="comment">// HashSet</span></span><br><span class="line"><span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">  System.out.println(key + <span class="string">&quot;-&gt;&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;map的所有的value：&quot;</span>);</span><br><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> values.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">  System.out.println(iter.next());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;map所有的映射关系：&quot;</span>);</span><br><span class="line"><span class="comment">// 映射关系的类型是Map.Entry类型，它是Map接口的内部接口</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">mappings</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Object mapping : mappings) &#123;</span><br><span class="line">  Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) mapping;</span><br><span class="line">  System.out.println(<span class="string">&quot;key是：&quot;</span> + entry.getKey() + <span class="string">&quot;，value是：&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map的主要实现类：HashMap"><a href="#Map的主要实现类：HashMap" class="headerlink" title="Map的主要实现类：HashMap"></a>Map的主要实现类：HashMap</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><ul>
<li>允许使用null键和null值，与HashSet一样，不保证映射的顺序。</li>
<li>所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写：equals()和hashCode()</li>
<li>所有的value构成的集合是Collection:无序的、可以重复的。所以，value所在的类要重写：equals()</li>
<li>一个key-value构成一个entry</li>
<li>所有的entry构成的集合是Set:无序的、不可重复的</li>
<li>HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true，hashCode 值也相等； 判断两个 value相等的标准是：两个 value 通过 equals() 方法返回 true。</li>
</ul>
<h3 id="HashMap的存储结构"><a href="#HashMap的存储结构" class="headerlink" title="HashMap的存储结构"></a>HashMap的存储结构</h3><p>JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法) </p>
<p>JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。</p>
<img data-src="/images/Java基础之集合框架/image-20200619171812979.png" alt="image-20200619171812979" style="zoom:80%;" />

<img data-src="/images/Java基础之集合框架/image-20200619171905874.png" alt="image-20200619171905874" style="zoom:80%;" />

<h3 id="HashMap源码中的重要常量"><a href="#HashMap源码中的重要常量" class="headerlink" title="HashMap源码中的重要常量"></a>HashMap源码中的重要常量</h3><p>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16 </p>
<p>MAXIMUM_CAPACITY： HashMap的最大支持容量，2^30^</p>
<p>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子，0.75</p>
<p>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树，8</p>
<p>UNTREEIFY_THRESHOLD：Bucket中红黑树存储的Node小于该默认值，转化为链表 </p>
<p>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量，64（当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4 倍） </p>
<p>table：存储元素的数组，总是2的n次幂 </p>
<p>entrySet：存储具体元素的集 </p>
<p>size：HashMap中存储的键值对的数量 </p>
<p>modCount：HashMap扩容和结构改变的次数。 </p>
<p>threshold：扩容的临界值 &#x3D; 容量 * 加载因子 </p>
<p>loadFactor：加载因子  </p>
<h3 id="HashMap底层实现（JDK8）"><a href="#HashMap底层实现（JDK8）" class="headerlink" title="HashMap底层实现（JDK8）"></a>HashMap底层实现（JDK8）</h3><p>HashMap的内部存储结构其实是<strong>数组+链表+红黑树</strong>。当实例化一个HashMap时，系统会创建一个长度为Capacity的Node数组（JDK8中没添加元素之前为0，在第一次add操作之后才会创建一个实际长度为16），这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</p>
<p>每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带 一个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，每一个TreeNode对象 可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last，或树的叶子结点。</p>
<h4 id="添加元素的过程"><a href="#添加元素的过程" class="headerlink" title="添加元素的过程"></a>添加元素的过程</h4><p>向HashMap中添加entry1(key，value)，需要首先计算entry1中key的哈希值(根据 key所在类的hashCode()计算得到)，此哈希值经过处理以后，得到在底层Node[]数组中要存储的位置i。</p>
<p>如果位置i上没有元素，则entry1直接添加成功。如果位置i上已经存在entry2(或还有链表存在的entry3，entry4)，则需要通过循环的方法，依次比较entry1中key和其他的entry。</p>
<p>如果彼此hash值不同，则直接添加成功如果 hash值相同，继续调用二者的equals()方法，如果返回值为true，则使用entry1的value 去替换equals为true的entry的value。</p>
<p>如果遍历一遍以后，发现所有的equals返回都为false,则entry1仍可添加成功。</p>
<p>JDK8中添加的核心源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; </span><br><span class="line">  Node&lt;K,V&gt; p; </span><br><span class="line">  <span class="type">int</span> n, i;</span><br><span class="line">  <span class="comment">//判断数组是否已经创建，若没有创建调用resize()方法创建一个长度为16的数组</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) </span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">  <span class="comment">//判断该位置上数组是否已经存了数据，如果没有，就直接调用newNode()方法将新元素放到该位置</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">  <span class="comment">//如果该位置已经放了元素，就需要进行一系列的比较了</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="comment">//如果和第一个位置元素哈希值相等，并且key也是一样的，那么久直接将这个key对应的value替换掉</span></span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      e = p;</span><br><span class="line">    <span class="comment">//如果哈希值不相等，判断这个数组是不是属树形的结构，如果是就调用相关方法再比较</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="comment">//如果不是树形结构，接直接从这个链表的头部开始遍历</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="comment">//指向第一个元素的下一个节点为null，也就意味着将链表中的元素全部比较完了，并且都不一样</span></span><br><span class="line">        <span class="comment">//就将这个元素添加到这个链表后面</span></span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">          p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">          <span class="comment">//如果链表的长度大于默认值(8)，就讲其转换为红黑树</span></span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            <span class="comment">//要转换为红黑树，方法里面还会判断一下，数组的长度是不是大于64</span></span><br><span class="line">            <span class="comment">//大于的话才会转换为红黑树，否则只是进行一个扩容</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果哈希值一样，并且key也是一样的，就跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面是存在相同key的情况，只对其value进行更新</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">      <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++modCount;</span><br><span class="line">  <span class="comment">//判断是否需要扩容</span></span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line">  afterNodeInsertion(evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashMap的扩容"><a href="#HashMap的扩容" class="headerlink" title="HashMap的扩容"></a>HashMap的扩容</h4><p>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p>
<p>扩容核心源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  <span class="comment">//得到原来数组的容量</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">  <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">  <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//如果原来的容量大于0</span></span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//如果大于最大的容量，将临界值改为最大的整数</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就将其左移一位，也就是扩大一倍。</span></span><br><span class="line">    <span class="comment">//前提是扩容后的容量要小于最大容量，并且原来的容量要大于默认容量(16)</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果原来的容量为0且扩容临界值大于0，就将其赋给容量</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">	<span class="comment">//如果两者都为0</span></span><br><span class="line">  <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  threshold = newThr;</span><br><span class="line">  <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="literal">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容的时机：</p>
<p>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数 size) * loadFactor 时， 就会进行数 组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况 下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数 超过16 * 0.75&#x3D;12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把 数组的大小扩展为 (16 &lt;&lt; 2) &#x3D; 32，即扩大一倍，然后重新计算每个元素在数组中的位置， 而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数， 那么预设元素的个数能够有效的提高HashMap的性能。</p>
<p>树形化的条件：</p>
<p>当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后， 下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。</p>
<p><strong>小结：</strong></p>
<ol>
<li><p>HashMap map &#x3D; new HashMap();  &#x2F;&#x2F;默认情况下，先不创建长度为16的数组 </p>
</li>
<li><p>当首次调用map.put()时，再创建长度为16的数组 </p>
</li>
<li><p>数组为Node类型，在jdk7中称为Entry类型 </p>
</li>
<li><p>形成链表结构时，新添加的key-value对在链表的尾部（七上八下） </p>
</li>
<li><p>当数组指定索引位置的链表长度大于8时，且map中的数组的长度大于64时，此索引位置 上的所有key-value对使用红黑树进行存储。</p>
</li>
</ol>
<h4 id="负载因子的大小，对HashMap的影响"><a href="#负载因子的大小，对HashMap的影响" class="headerlink" title="负载因子的大小，对HashMap的影响"></a>负载因子的大小，对HashMap的影响</h4><ul>
<li>负载因子的大小决定了HashMap的数据密度。 </li>
<li>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长, 造成查询或插入时的比较次数增多，性能会下降。 </li>
<li>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内存空间。而且经常扩容也会影响性能，建 议初始化预设大一点的空间。 </li>
<li>按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此 时平均检索长度接近于常数。</li>
</ul>
<h2 id="Map实现类之二：LinkedHashMap"><a href="#Map实现类之二：LinkedHashMap" class="headerlink" title="Map实现类之二：LinkedHashMap"></a>Map实现类之二：LinkedHashMap</h2><p>LinkedHashMap是HashMap的子类，LinkedHashMap在HashMap的存储基础上，使用了一对双向链表来记录添加元素的顺序。</p>
<p>HashMap中的内部类：Node</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  V value;</span><br><span class="line">  Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap中的内部类：Entry</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">  Entry&lt;K,V&gt; before, after;</span><br><span class="line">  Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map实现类之三：TreeMap"><a href="#Map实现类之三：TreeMap" class="headerlink" title="Map实现类之三：TreeMap"></a>Map实现类之三：TreeMap</h2><p>TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序，TreeMap 可以保证所有的 Key-Value 对处于有序状态。TreeSet底层使用的是红黑树结构存储数据。</p>
<p>TreeMap 的 Key 的排序：</p>
<ul>
<li><p>自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException</p>
</li>
<li><p>定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口</p>
</li>
</ul>
<p>TreeMap判断两个key相等的标准：</p>
<p>​	两个key通过compareTo()方法或 者compare()方法返回0。</p>
<h2 id="Map实现类之四：Hashtable"><a href="#Map实现类之四：Hashtable" class="headerlink" title="Map实现类之四：Hashtable"></a>Map实现类之四：Hashtable</h2><p>Hashtable是个古老的 Map 实现类，JDK1.0就提供了，和HashMap的区别在于Hashtable是线程安全的，并且Hashtable 不允许使用 null 作为 key 和 value。Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。</p>
<h2 id="Map实现类之五：Properties"><a href="#Map实现类之五：Properties" class="headerlink" title="Map实现类之五：Properties"></a>Map实现类之五：Properties</h2><p>Properties 类是 Hashtable 的子类，该对象用于处理属性文件。由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型。</p>
<p>存取数据时，建议使用setProperty(String key,String value)方法和 getProperty(String key)方法。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pros.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc.properties&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>

<h1 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h1><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><p>Collections 是一个操作 Set、List 和 Map 等集合的工具类，Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作， 还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="排序操作：（均为static方法）"><a href="#排序操作：（均为static方法）" class="headerlink" title="排序操作：（均为static方法）"></a>排序操作：（均为static方法）</h3><ul>
<li><p>reverse(List)：反转 List 中元素的顺序 </p>
</li>
<li><p>shuffle(List)：对 List 集合元素进行随机排序 </p>
</li>
<li><p>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序 </p>
</li>
<li><p>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 </p>
</li>
<li><p>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</p>
</li>
</ul>
<h3 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h3><ul>
<li><p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 </p>
</li>
<li><p>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回 给定集合中的最大元素</p>
</li>
<li><p>Object min(Collection) </p>
</li>
<li><p>Object min(Collection，Comparator) </p>
</li>
<li><p>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数 </p>
</li>
<li><p>void copy(List dest,List src)：将src中的内容复制到dest中 </p>
</li>
<li><p>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</p>
</li>
</ul>
<h3 id="同步控制方法"><a href="#同步控制方法" class="headerlink" title="同步控制方法"></a>同步控制方法</h3><p>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识总结（上）</title>
    <url>/2020/04/14/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Java中的注释"><a href="#Java中的注释" class="headerlink" title="Java中的注释"></a>Java中的注释</h2><ol>
<li><p>单行注释   &#x2F;&#x2F;</p>
</li>
<li><p>多行注释  &#x2F;*   *&#x2F;</p>
<p>单行注释和多行注释的作用：</p>
<p>① 对所写的程序进行解释说明，增强可读性。方便自己，方便别人</p>
<p>② 调试所写的代码</p>
</li>
<li><p>文档注释  &#x2F;**   *&#x2F;</p>
<p>注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。</p>
<hr>
</li>
</ol>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ol>
<li><p>标识符：凡是自己可以起名字的地方都叫标识符。</p>
<p>  比如：类名、变量名、方法名、接口名、包名…</p>
</li>
<li><p>标识符的命名规则：–&gt; 如果不遵守如下的规则，编译不通过！</p>
<p>① 由26个英文字母大小写，0-9 ，_或 $ 组成 </p>
<p>②数字不可以开头。</p>
<p>③不可以使用关键字和保留字，但能包含关键字和保留字。</p>
<p>④Java中严格区分大小写，长度无限制。</p>
<p>⑤标识符不能包含空格。</p>
</li>
<li><p>Java中的名称命名规范： —&gt;如果不遵守如下的规范，编译可以通过！</p>
<p>包名：多单词组成时所有字母都小写：xxxyyyzzz</p>
<p>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz</p>
<p>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz</p>
<p>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</p>
</li>
<li><p>注意1：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。</p>
<p>注意2：java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用。 </p>
<hr>
</li>
</ol>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li><p>变量按照数据类型来分：</p>
<p>a. 基本数据类型：</p>
<p>   整型：byte \ short \ int \ long</p>
<p>   浮点型：float \ double</p>
<p>   字符型：char</p>
<p>   布尔型：boolean</p>
<p> b. 引用数据类型：</p>
<p>   类(class)</p>
<p>   接口(interface)</p>
<p>   数组(array)</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">占用存储空间</th>
<th align="center">表示数据范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">1字节&#x3D;8bit</td>
<td align="center">-128~127</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2字节</td>
<td align="center">$-2^{15}$ ~$2^{15} -1$</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4字节</td>
<td align="center">$-2^{31}$ ~ $2^{31} -1$</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">8字节</td>
<td align="center">$-2^{63}$ ~$2^{63} -1$</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4字节</td>
<td align="center">-3.403E38 ~ 3.403E38</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8字节</td>
<td align="center">-1.798E308 ~ 1.798E308</td>
</tr>
</tbody></table>
<ul>
<li><strong>java的整型常量默认为 int 型，声明long型常量须后加‘l’或‘L’</strong> </li>
<li><strong>java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long</strong></li>
</ul>
<p>转义字符：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\b</td>
<td>退格符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\“</td>
<td>双引号</td>
</tr>
<tr>
<td>\‘</td>
<td>单引号</td>
</tr>
<tr>
<td>\\</td>
<td>反斜线</td>
</tr>
</tbody></table>
<ol start="2">
<li><p>变量在类中声明的位置：</p>
<p>​    成员变量 vs 局部变量</p>
</li>
</ol>
<h3 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h3><ol>
<li><p>java定义变量的格式：数据类型 变量名 &#x3D; 变量值;</p>
</li>
<li><p>说明：</p>
<p>  ① 变量必须先声明，后使用</p>
<p>  ② 变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了</p>
<p>  ③ 同一个作用域内，不可以声明两个同名的变量</p>
</li>
</ol>
<h3 id="运算规则"><a href="#运算规则" class="headerlink" title="运算规则"></a>运算规则</h3><p>基本数据类型之间的运算规则：</p>
<p>前提：这里讨论只是7种基本数据类型变量间的运算。不包含boolean类型的。</p>
<ol>
<li><p>自动类型提升：</p>
<p> 结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。</p>
</li>
</ol>
<pre class="mermaid">graph LR
char --> int
byte --> int
short --> int --> long --> float --> double</pre>

<pre><code>特别的：byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。当byte、char、short三种类型的变量做运算时，结果为int型。
</code></pre>
<ol start="2">
<li><p>强制类型转换：</p>
<p>a.需要使用强转符：()</p>
<p>b.注意点：强制类型转换，可能导致精度损失。</p>
</li>
<li><p>说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量</p>
</li>
</ol>
<h3 id="String类型变量的使用"><a href="#String类型变量的使用" class="headerlink" title="String类型变量的使用"></a>String类型变量的使用</h3><ol>
<li><p>String属于引用数据类型,翻译为：字符串</p>
</li>
<li><p>声明String类型变量时，使用一对” “</p>
</li>
<li><p>String可以和8种基本数据类型变量做运算，且运算只能是连接运算：+</p>
</li>
<li><p>运算的结果仍然是String类型</p>
<hr>
</li>
</ol>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>太简单，不说了</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>介绍一个特别的：instanceof</p>
<p>作用是检查是否是类的对象，例如： “Hello” instanceof String &#x3D; true</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>&amp;—逻辑与         | —逻辑或       ！—逻辑非 </p>
<p>&amp;&amp; —短路与     || —短路或     ^ —逻辑异或</p>
<ul>
<li>“&amp;”和“&amp;&amp;”的区别： <ul>
<li>单&amp;时，左边无论真假，右边都进行运算； </li>
<li>双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。</li>
</ul>
</li>
<li>“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。</li>
</ul>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>格式： (表达式1)?表达式2：表达式3；</p>
<p>若表达式1的结果为真则执行<strong>表达式2</strong>，若为假则执行<strong>表达式3</strong></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li><p>表达式1,表达式2,表达式3的类型可以不同，进行自动类型转换（提升）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o1);<span class="comment">//1.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>条件表达式不能取代一般的if语句,仅当if语句中内嵌的语句为赋值语句(且两个分支都给同一变量赋值)时才能代替if语句，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line"> printf(<span class="string">&quot;even/n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> printf(<span class="string">&quot;odd/n&quot;</span>);</span><br><span class="line"><span class="comment">//不能写成</span></span><br><span class="line">(a%<span class="number">2</span>==<span class="number">0</span>)?printf(<span class="string">&quot;even/n&quot;</span>):printf(<span class="string">&quot;odd/n&quot;</span>);</span><br><span class="line"><span class="comment">//但是可以写成</span></span><br><span class="line">printf(<span class="string">&quot;%s/n&quot;</span>,(a%<span class="number">2</span>==<span class="number">0</span>?<span class="string">&quot;even&quot;</span>:<span class="string">&quot;odd&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><table>
<thead>
<tr>
<th align="center">运算顺序（从左往右或从右往左）</th>
<th align="center">运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">.    ()      {}      ;      ,</td>
</tr>
<tr>
<td align="center">R –&gt; L</td>
<td align="center">++  –  ~    !()</td>
</tr>
<tr>
<td align="center">L –&gt; R</td>
<td align="center">*      &#x2F;     %</td>
</tr>
<tr>
<td align="center">L –&gt; R</td>
<td align="center">&lt;&lt;  &gt;&gt;   &gt;&gt;&gt;</td>
</tr>
<tr>
<td align="center">L –&gt; R</td>
<td align="center">&lt;  &gt;  &lt;&#x3D;  &gt;&#x3D;    instanceof</td>
</tr>
<tr>
<td align="center">L –&gt; R</td>
<td align="center">&#x3D;&#x3D;      !&#x3D;</td>
</tr>
<tr>
<td align="center">L –&gt; R</td>
<td align="center">&amp;</td>
</tr>
<tr>
<td align="center">L –&gt; R</td>
<td align="center">^</td>
</tr>
<tr>
<td align="center">L –&gt; R</td>
<td align="center">|</td>
</tr>
<tr>
<td align="center">L –&gt; R</td>
<td align="center">&amp;&amp;</td>
</tr>
<tr>
<td align="center">L –&gt; R</td>
<td align="center">||</td>
</tr>
<tr>
<td align="center">R –&gt; L</td>
<td align="center">?    :</td>
</tr>
<tr>
<td align="center">R –&gt; L</td>
<td align="center">&#x3D;    *&#x3D;    &#x2F;&#x3D;   %&#x3D;</td>
</tr>
</tbody></table>
<hr>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括 基本数据类型和引用数据类型。</li>
<li>创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是 这块连续空间的首地址。 </li>
<li>数组的长度一旦确定，就不能修改。 </li>
<li>我们可以直接通过下标(或索引)的方式调用指定位置的元素，速度很快。</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><ol>
<li><p>一维数组的声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">type <span class="keyword">var</span>[] 或 type[] <span class="keyword">var</span>；</span><br></pre></td></tr></table></figure>

<p>Java语言中声明数组时不能指定其长度(数组中元素的数)， 例如： int a[5]; <strong>&#x2F;&#x2F;非法</strong></p>
</li>
<li><p>初始化</p>
<ul>
<li><p>动态初始化：数组声明且为数组元素分配空间与赋值的操作分开进行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">String names[];</span><br><span class="line">names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];</span><br><span class="line">names[<span class="number">0</span>] = “钱学森”;</span><br><span class="line">names[<span class="number">1</span>] = “邓稼先”;</span><br><span class="line">names[<span class="number">2</span>] = “袁隆平”;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>静态初始化：在定义数组的同时就为数组元素分配空间并赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123; <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">String names[] = &#123;</span><br><span class="line">“李四光”,“茅以升”,“华罗庚”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="数组元素的默认初始化值"><a href="#数组元素的默认初始化值" class="headerlink" title="数组元素的默认初始化值"></a>数组元素的默认初始化值</h3><table>
<thead>
<tr>
<th align="center">数组元素类型</th>
<th align="center">元素默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">0L</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">0.0F</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">0.0</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">0或‘\u0000’(表现为空)</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">应用类型</td>
<td align="center">null</td>
</tr>
</tbody></table>
<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><ol>
<li><p>声明和初始化</p>
<ul>
<li><p>格式1（动态初始化）：int[][] arr &#x3D; new int[3][2];</p>
<p>定义了名称为arr的二维数组 </p>
<p>二维数组中有3个一维数组 </p>
<p>每一个一维数组中有2个元素 一维数组的名称分别为arr[0], arr[1], arr[2] </p>
<p>给第一个一维数组1脚标位赋值为78写法是：arr[0][1] &#x3D; 78;</p>
</li>
<li><p>格式2（动态初始化）：int[][] arr &#x3D; new int[3][];</p>
<p>二维数组中有3个一维数组。 </p>
<p>每个一维数组都是默认初始化值null (注意：区别于格式1）</p>
<p> 可以对这个三个一维数组分别进行初始化 </p>
<p>arr[0] &#x3D; new int[3]; arr[1] &#x3D; new int[1]; </p>
<p>arr[2] &#x3D; new int[2];</p>
</li>
</ul>
<p><strong>注： int[][]arr &#x3D; new int[][3]; &#x2F;&#x2F;非法</strong></p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识总结（中）</title>
    <url>/2020/04/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
    <content><![CDATA[<h2 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h2><ul>
<li><p>面向过程(POP) 与 面向对象(OOP)</p>
<ul>
<li><p>二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，强调的 是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对 象，强调具备了功能的对象，以类&#x2F;对象为最小单位，考虑谁来做。</p>
</li>
<li><p>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如 抽象、分类、继承、聚合、多态等。</p>
<p><em>面向对象：Object Oriented Programming</em> </p>
<p><em>面向过程：Procedure Oriented Programming</em></p>
</li>
</ul>
</li>
<li><p>面向对象的三大特征</p>
<ul>
<li>封装（Encapsulation）</li>
<li>继承（Inheritance）</li>
<li>多态（Polymorphism）</li>
</ul>
<span id="more"></span></li>
</ul>
<p>煮个栗子：</p>
<img data-src="/images/Java基础知识总结（中）/YxauQKcO3TyLqmM.png" alt="image.png" style="zoom: 67%;" />

<!--more-->

<h2 id="Java中的基本元素：类和对象"><a href="#Java中的基本元素：类和对象" class="headerlink" title="Java中的基本元素：类和对象"></a>Java中的基本元素：类和对象</h2><h3 id="类的语法格式"><a href="#类的语法格式" class="headerlink" title="类的语法格式"></a>类的语法格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&#123;</span><br><span class="line">  属性声明;</span><br><span class="line">  方法申明;</span><br><span class="line">&#125;</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age ; <span class="comment">//声明私有变量 age</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAge</span><span class="params">(<span class="type">int</span> i)</span> &#123; <span class="comment">//声明方法showAge( )</span></span><br><span class="line">  	age = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象的创建和使用"><a href="#对象的创建和使用" class="headerlink" title="对象的创建和使用"></a>对象的创建和使用</h3><ul>
<li>创建对象语法：类名 对象名 &#x3D; new 类名();</li>
<li>用“对象名.对象成员”的方式就能访问对象成员</li>
</ul>
<p>内存解析：<img data-src="/images/Java基础知识总结（中）/JD1uqrjePf5HURc.png" alt="image.png" style="zoom: 67%;" /></p>
<h4 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h4><p>我们也可以不定义对象的句柄，而直接调用这个对象的方法。这 样的对象叫做匿名对象。 </p>
<p>如：new Person().shout(); </p>
<p>使用情况：如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。 我们经常将匿名对象作为实参传递给一个方法调用。</p>
<h3 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h3><h4 id="属性（field）"><a href="#属性（field）" class="headerlink" title="属性（field）"></a>属性（field）</h4><h5 id="语法格式：-修饰符-数据类型-属性名-x3D-初始化值"><a href="#语法格式：-修饰符-数据类型-属性名-x3D-初始化值" class="headerlink" title="语法格式： 修饰符 数据类型 属性名 &#x3D; 初始化值 ;"></a>语法格式： 修饰符 数据类型 属性名 &#x3D; 初始化值 ;</h5><ul>
<li>说明1: 修饰符 <ul>
<li>常用的权限修饰符有：private、缺省、protected、public </li>
<li>其他修饰符：static、final (暂不考虑)</li>
</ul>
</li>
<li>说明2：数据类型 <ul>
<li>任何基本数据类型(如int、Boolean) 或 任何引用数据类型。</li>
</ul>
</li>
<li>说明3：属性名 <ul>
<li>属于标识符，符合命名规则和规范即可。</li>
</ul>
</li>
</ul>
<p>举例： public class Person{ private int age; &#x2F;&#x2F;声明private变量 age public String name &#x3D; “Lila”; &#x2F;&#x2F;声明public变量 name }</p>
<h5 id="变量的分类（成员变量和局部变量）"><a href="#变量的分类（成员变量和局部变量）" class="headerlink" title="变量的分类（成员变量和局部变量）"></a>变量的分类（成员变量和局部变量）</h5><ul>
<li>在方法体外，类体内声明的变量称为成员变量。 </li>
<li>在方法体内部声明的变量称为局部变量。</li>
</ul>
<p>成员变量和局部变量区别：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">成员变量</th>
<th align="center">局部变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">声明的位置</td>
<td align="center">直接声明在类型中</td>
<td align="center">方法内部、代码块内、构造器内</td>
</tr>
<tr>
<td align="center">修饰符</td>
<td align="center">private、public、static等</td>
<td align="center">不能用权限修饰符，可以用final修饰</td>
</tr>
<tr>
<td align="center">初始化值</td>
<td align="center">有默认初始化值</td>
<td align="center">没有默认初始化值，必须要显示赋值</td>
</tr>
<tr>
<td align="center">内存加载位置</td>
<td align="center">堆空间或静态域内</td>
<td align="center">栈空间</td>
</tr>
</tbody></table>
<h4 id="方法（method）"><a href="#方法（method）" class="headerlink" title="方法（method）"></a>方法（method）</h4><h5 id="方法的声明格式："><a href="#方法的声明格式：" class="headerlink" title="方法的声明格式："></a>方法的声明格式：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数类型 形参<span class="number">1</span>, 参数类型 形参<span class="number">2</span>, ….）｛</span><br><span class="line">	方法体程序代码</span><br><span class="line">	<span class="keyword">return</span> 返回值;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>其中： 修饰符：public,缺省,private, protected等 返回值类型：</p>
<ul>
<li>没有返回值：void。 </li>
<li>有返回值，声明出返回值的类型。与方法体中“return 返回值”搭配使用 方法名：属于标识符，命名时遵循标识符命名规则和规范，“见名知意” 形参列表：可以包含零个，一个或多个参数。多个参数时，中间用“,”隔开 返回值：方法在执行完毕后返还给调用它的程序的数据。</li>
</ul>
<h5 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h5><img data-src="/images/Java基础知识总结（中）/sSNBGoyAzTU2xbp.png" alt="image.png" style="zoom: 67%;" />

<h5 id="方法的重载（overload）"><a href="#方法的重载（overload）" class="headerlink" title="方法的重载（overload）"></a>方法的重载（overload）</h5><p>1.定义：在同一个类中，允许存在一个以上的同名方法，只要它们的<strong>参数个数</strong>或者<strong>参数类型</strong>不同即可。</p>
<ul>
<li><p>“两同一不同”:同一个类、相同方法名</p>
</li>
<li><p>参数列表不同：参数个数不同，参数类型不同</p>
</li>
</ul>
<p>使用重载方法，可以为编程带来方便。 </p>
<p>例如，System.out.println()方法就是典型的重载方法，其内部的声 明形式如下： </p>
<p>public void println(byte x) </p>
<p>public void println(short x) </p>
<p>public void println(int x) </p>
<p>public void println(long x) </p>
<p>public void println(float x) </p>
<p>public void println(double x) </p>
<p>public void println(char x) </p>
<p>public void println(double x) </p>
<p>public void println()</p>
<p>……</p>
<h5 id="可变个数的形参"><a href="#可变个数的形参" class="headerlink" title="可变个数的形参"></a>可变个数的形参</h5><p>1.JavaSE 5.0 中提供了Varargs(variable number of arguments)机制，允许直接定 义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a ,String[] books)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a ,String … books)</span>;</span><br></pre></td></tr></table></figure>

<p>2.具体使用：</p>
<ul>
<li><p>2.1 可变个数形参的格式：数据类型 … 变量名</p>
</li>
<li><p>2.2 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，。。。</p>
</li>
<li><p>2.3 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</p>
</li>
<li><p>2.4 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。</p>
</li>
<li><p>2.5 可变个数形参在方法的形参中，必须声明在末尾</p>
</li>
<li><p>2.6 可变个数形参在方法的形参中,最多只能声明一个可变形参。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String[] msg)</span>&#123;</span><br><span class="line">	System.out.println(“含字符串数组参数的test方法 <span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">public void test1(String book)&#123;</span></span><br><span class="line"><span class="string">	System.out.println(“****与可变形参方法构成重载的test1方法****&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(String ... books)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;****形参长度可变的test1方法****&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">TestOverload</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestOverload</span>();</span><br><span class="line">  <span class="comment">//下面两次调用将执行第二个test方法</span></span><br><span class="line">  to.test1();</span><br><span class="line">  to.test1(<span class="string">&quot;aa&quot;</span> , <span class="string">&quot;bb&quot;</span>);</span><br><span class="line">  <span class="comment">//下面将执行第一个test方法</span></span><br><span class="line">  to.test(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;aa&quot;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法参数的值传递机制"><a href="#方法参数的值传递机制" class="headerlink" title="方法参数的值传递机制"></a>方法参数的值传递机制</h5><p>方法，必须由其所在类或对象调用才有意义。若方法含有参数： </p>
<ul>
<li>形参：方法声明时的参数</li>
<li>实参：方法调用时实际传给形参的参数值</li>
</ul>
<p>Java的实参值如何传入方法呢？</p>
<p>Java里方法的参数传递方式只有一种：<strong>值传递</strong>。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。</p>
<ul>
<li>形参是基本数据类型：将实参基本数据类型变量的“<strong>数据值</strong>”传递给形参 </li>
<li>形参是引用数据类型：将实参引用数据类型变量的“<strong>地址值</strong>”传递给形参</li>
</ul>
<img data-src="/images/Java基础知识总结（中）/RuJgS4FkPxGONo2.png" alt="image.png" style="zoom: 80%;" />

<img data-src="/images/Java基础知识总结（中）/FoCkBhuLtl5Vyjf.png" alt="image.png" style="zoom: 80%;" />

<img data-src="/images/Java基础知识总结（中）/1zWEMB2Iki7o6my.png" alt="image.png" style="zoom:80%;" />

<img data-src="/images/Java基础知识总结（中）/2ARmBoaSXKpV5Zr.png" alt="image.png" style="zoom:80%;" />

<img data-src="/images/Java基础知识总结（中）/XCNFBZkxrmYtuJP.png" alt="image.png" style="zoom:80%;" />

<p><img data-src="/images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AD%EF%BC%89/PHC8ReFzDhMfXwj.png"></p>
<p><img data-src="/images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AD%EF%BC%89/DHXK67YzpVJeOEm.webp"></p>
<h4 id="构造器（构造方法）"><a href="#构造器（构造方法）" class="headerlink" title="构造器（构造方法）"></a>构造器（构造方法）</h4><h5 id="构造器的特征"><a href="#构造器的特征" class="headerlink" title="构造器的特征"></a>构造器的特征</h5><ul>
<li>它具有与类相同的名称 </li>
<li>它不声明返回值类型。（与声明为void不同） </li>
<li>不能被static、final、synchronized、abstract、native修饰，不能有 return语句返回值</li>
</ul>
<h5 id="构造器的作用"><a href="#构造器的作用" class="headerlink" title="构造器的作用"></a>构造器的作用</h5><ul>
<li>创建对象</li>
<li>给对象进行初始化</li>
</ul>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p>根据参数不同，构造器可以分为如下两类： </p>
<ul>
<li>隐式无参构造器（系统默认提供） </li>
<li>显式定义一个或多个构造器（无参、有参）</li>
</ul>
<p>注意：</p>
<ol>
<li>Java语言中，每个类都至少有一个构造器 </li>
<li>默认构造器的修饰符与所属类的修饰符一致 </li>
<li>一旦显式定义了构造器，则系统不再提供默认构造器 </li>
<li>一个类可以创建多个重载的构造器 </li>
<li>父类的构造器不可被子类继承</li>
</ol>
<h5 id="构造器的重载"><a href="#构造器的重载" class="headerlink" title="构造器的重载"></a>构造器的重载</h5><p>构造器重载，参数列表必须不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, Date d)</span> &#123;<span class="built_in">this</span>(name,age);…&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;…&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, Date d)</span> &#123;…&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;…&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><p>JavaBean是一种Java语言写成的可重用组件。</p>
<p>所谓javaBean，是指符合如下标准的Java类： </p>
<ul>
<li>类是公共的 </li>
<li>有一个无参的公共的构造器 </li>
<li>有属性，且有对应的get、set方法</li>
</ul>
<p>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以 用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP 页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用 户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关 心任何改变。</p>
<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><img data-src="/images/Java基础知识总结（中）/hDmlsInjw7HBKuN.png" alt="image.png" style="zoom:80%;" />



<h2 id="面向对象的特征之一：封装"><a href="#面向对象的特征之一：封装" class="headerlink" title="面向对象的特征之一：封装"></a>面向对象的特征之一：封装</h2><h3 id="为什么需要封装？"><a href="#为什么需要封装？" class="headerlink" title="为什么需要封装？"></a>为什么需要封装？</h3><ul>
<li><p>封装的作用和含义？</p>
<ul>
<li>我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内 部的结构吗？有必要碰电动机吗？ </li>
<li>我要开车，…</li>
</ul>
</li>
<li><p>我们程序设计追求“高内聚，低耦合”。 </p>
<ul>
<li>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉； </li>
<li>低耦合 ：仅对外暴露少量的方法用于使用。 </li>
<li>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提 高系统的可扩展性、可维护性。通俗的说，<strong>把该隐藏的隐藏起来，该暴露的暴露出来</strong>。这就是封装性的设计思想。</li>
</ul>
</li>
</ul>
<p>使用者对类内部定义的属性(对象的成员变量)的直接操作会导致数据的错误、混乱或安全性问题</p>
<p>应该将legs属性保护起来， 防止乱用。 </p>
<p>保护的方式：信息隐藏</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> legs;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">  	System.out.println(<span class="string">&quot;Eating&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">  	System.out.println(<span class="string">&quot;Moving.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zoo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">xb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">    xb.legs = <span class="number">4</span>;</span><br><span class="line">    System.out.println(xb.legs);</span><br><span class="line">    xb.eat();</span><br><span class="line">    xb.move();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java中通过将数据声明为私有的(private)，再提供公共的（public） 方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的： </p>
<ul>
<li>隐藏一个类中不需要对外提供的实现细节； </li>
<li>使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑， 限制对属性的不合理操作；</li>
<li>便于修改，增强代码的可维护性；</li>
</ul>
<h3 id="四种权限修饰符"><a href="#四种权限修饰符" class="headerlink" title="四种权限修饰符"></a>四种权限修饰符</h3><table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">内部类</th>
<th align="center">同一个包</th>
<th align="center">不同的子包</th>
<th align="center">同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">（缺省）</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p>对于class的权限修饰只可以用public和default(缺省)。 </p>
<ul>
<li>public类可以在任意地方被访问。 </li>
<li>default类只可以被同一个包内部的类访问。</li>
</ul>
<h3 id="关键字this的使用"><a href="#关键字this的使用" class="headerlink" title="关键字this的使用"></a>关键字this的使用</h3><h3 id="在Java中，this关键字比较难理解，它的作用和其词义很接近。"><a href="#在Java中，this关键字比较难理解，它的作用和其词义很接近。" class="headerlink" title="在Java中，this关键字比较难理解，它的作用和其词义很接近。"></a>在Java中，this关键字比较难理解，它的作用和其词义很接近。</h3><ul>
<li>它在方法内部使用，即这个方法所属对象的引用； </li>
<li>它在构造器内部使用，表示该构造器正在初始化的对象</li>
</ul>
<h3 id="this-可以调用类的属性、方法和构造器"><a href="#this-可以调用类的属性、方法和构造器" class="headerlink" title="this 可以调用类的属性、方法和构造器"></a>this 可以调用类的属性、方法和构造器</h3><h3 id="什么时候可以用this关键字"><a href="#什么时候可以用this关键字" class="headerlink" title="什么时候可以用this关键字"></a>什么时候可以用this关键字</h3><p>当在方法内需要用到调用该方法的对象时，就用this。 具体的：我们可以用this来区分属性和局部变量。 比如：this.name &#x3D; name;</p>
<p><strong>调用属性和方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123; <span class="comment">// 定义Person类</span></span><br><span class="line">  <span class="keyword">private</span> String name ;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name ;</span><br><span class="line">    <span class="built_in">this</span>.age = age ; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;姓名：&quot;</span> + name) ;</span><br><span class="line">    <span class="built_in">this</span>.speak();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>&#123;</span><br><span class="line">  	System.out.println(“年龄：” + <span class="built_in">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当前正在操作本方法的对 象称为当前对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123; <span class="comment">// 定义Person类</span></span><br><span class="line">  String name;</span><br><span class="line">  Person(String name)&#123;</span><br><span class="line">  	<span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">  	System.out.println(<span class="string">&quot;Person类 --&gt; &quot;</span> + <span class="built_in">this</span>.name) ; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(Person p)</span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">this</span>.name==p.name;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">per1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>) ;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">per2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>) ;</span><br><span class="line">    per1.getInfo() ; <span class="comment">// 当前调用getInfo()方法的对象是per1</span></span><br><span class="line">    per2.getInfo() ; <span class="comment">// 当前调用getInfo()方法的对象是per2</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> per1.compare(per2);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用构造器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123; <span class="comment">// 定义Person类</span></span><br><span class="line">  <span class="keyword">private</span> String name ;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123; <span class="comment">// 无参构造器</span></span><br><span class="line">  	System.out.println(<span class="string">&quot;新对象实例化&quot;</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>(); <span class="comment">// 调用本类中的无参构造器</span></span><br><span class="line">    <span class="built_in">this</span>.name = name ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>(name) ; <span class="comment">// 调用有一个参数的构造器</span></span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;，年龄：&quot;</span> + age ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象的特征之二：继承"><a href="#面向对象的特征之二：继承" class="headerlink" title="面向对象的特征之二：继承"></a>面向对象的特征之二：继承</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">public</span> Date birthDate;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String school;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么要有继承？"><a href="#为什么要有继承？" class="headerlink" title="为什么要有继承？"></a>为什么要有继承？</h3><ul>
<li><p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中， 那么多个类无需再定义这些属性和行为，只要继承那个类即可。</p>
</li>
<li><p>此处的多个类称为子类(派生类)，单独的这个类称为父类(基类 或超类)。可以理解为:“子类 is a 父类”</p>
</li>
<li><p>类继承语法规则: class Subclass extends SuperClass{ }</p>
</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>继承的出现减少了代码冗余，提高了代码的复用性。 </li>
<li>继承的出现，更有利于功能的扩展。 </li>
<li>继承的出现让类与类之间产生了关系，<strong>提供了多态的前提</strong>。</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li><p>子类继承了父类，就继承了父类的方法和属性，</p>
<p>但是子类不能直接访问父类中私有的(private)的成员变量和方法。</p>
</li>
<li><p>在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和 方法。 </p>
</li>
<li><p>在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集， 而是对父类的“扩展”。</p>
</li>
<li><p>Java只支持单继承和多层继承，不允许多重继承 </p>
</li>
<li><p>一个子类只能有一个父类 </p>
<ul>
<li>一个父类可以派生出多个子类 </li>
<li>class SubDemo extends Demo{ } &#x2F;&#x2F;ok </li>
<li>class SubDemo extends Demo1,Demo2…&#x2F;&#x2F;error</li>
</ul>
</li>
</ol>
<h3 id="方法的重写（override-x2F-overwrite）"><a href="#方法的重写（override-x2F-overwrite）" class="headerlink" title="方法的重写（override&#x2F;overwrite）"></a>方法的重写（override&#x2F;overwrite）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="string">&quot;Name: &quot;</span>+ name + <span class="string">&quot;\n&quot;</span> +<span class="string">&quot;age: &quot;</span>+ age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String school;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123; <span class="comment">//重写方法</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="string">&quot;Name: &quot;</span>+ name + <span class="string">&quot;\nage: &quot;</span>+ age + <span class="string">&quot;\nschool: &quot;</span>+ school;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">    Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    s1.name=<span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">    s1.age=<span class="number">20</span>;</span><br><span class="line">    s1.school=<span class="string">&quot;school2&quot;</span>;</span><br><span class="line">    System.out.println(s1.getInfo()); <span class="comment">//Name:Bob age:20 school:school2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在子类中可以根据需要对从父类中继承来的方法进行改造，也称 为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。</p>
<h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><ol>
<li>子类重写的方法必须和父类被重写的方法具有<strong>相同的方法名称、参数列表</strong> </li>
<li>子类重写的方法的返回值类型<strong>不能大于</strong>父类被重写的方法的返回值类型 </li>
<li>子类重写的方法使用的访问权限<strong>不能小于</strong>父类被重写的方法的访问权限 <ul>
<li>子类不能重写父类中声明为private权限的方法</li>
</ul>
</li>
<li>子类方法抛出的异常不能大于父类被重写方法的异常</li>
</ol>
<h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h5><p>子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为 static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。</p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><ul>
<li><p><strong>在Java类中使用super来调用父类中的指定操作：</strong></p>
</li>
<li><p>super可用于访问父类中定义的属性</p>
</li>
<li><p>super可用于调用父类中定义的成员方法 </p>
</li>
<li><p>super可用于在子类构造器中调用父类的构造器</p>
</li>
<li><p><strong>注意</strong></p>
<ul>
<li>尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员 </li>
<li>super的追溯不仅限于直接父类 </li>
<li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存 空间的标识</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>; </span><br><span class="line">  <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">	  <span class="keyword">return</span> <span class="string">&quot;Name: &quot;</span> + name + <span class="string">&quot;\nage: &quot;</span> + age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">String</span> <span class="variable">school</span> <span class="operator">=</span> <span class="string">&quot;New Oriental&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getSchool</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> school;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getInfo() + <span class="string">&quot;\nschool: &quot;</span> + school;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用父类的构造器"><a href="#调用父类的构造器" class="headerlink" title="调用父类的构造器"></a>调用父类的构造器</h4><ul>
<li>子类中所有的构造器默认都会访问父类中的<strong>空参构造器</strong> </li>
<li>当父类中没有空参构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的 构造器。同时，只能”二选一” ，且必须放在构造器的首行</li>
<li>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又 没有无参的构造器，则编译出错</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> Date birthDate;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, Date d)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.birthDate = d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(name, age, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, Date d)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(name, <span class="number">30</span>, d);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(name, <span class="number">30</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String school;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String s)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age);</span><br><span class="line">    school = s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String s)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    school = s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String s)</span> &#123;<span class="comment">// 编译出错: no super(),系统将调用父类无参数的构造器。</span></span><br><span class="line">  	school = s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="子类对象的实例化过程"><a href="#子类对象的实例化过程" class="headerlink" title="子类对象的实例化过程"></a>子类对象的实例化过程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Creature</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Creature</span><span class="params">()</span> &#123;</span><br><span class="line">  	System.out.println(<span class="string">&quot;Creature无参数的构造器&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">extends</span> <span class="title class_">Creature</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">	  System.out.println(<span class="string">&quot;Animal带一个参数的构造器，该动物的name为&quot;</span> + name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(name);</span><br><span class="line">    System.out.println(<span class="string">&quot;Animal带两个参数的构造器，其age为&quot;</span> + age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wolf</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Wolf</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="built_in">super</span>(<span class="string">&quot;灰太狼&quot;</span>, <span class="number">3</span>);</span><br><span class="line">	  System.out.println(<span class="string">&quot;Wolf无参数的构造器&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  	<span class="keyword">new</span> <span class="title class_">Wolf</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象的特征之三：多态"><a href="#面向对象的特征之三：多态" class="headerlink" title="面向对象的特征之三：多态"></a>面向对象的特征之三：多态</h2><ul>
<li><p>多态性，是面向对象中最重要的概念，在Java中的体现</p>
<p>对象的多态性：父类的引用指向子类的对象 </p>
<ul>
<li>可以直接应用在抽象类和接口上</li>
</ul>
</li>
<li><p>Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简 称：编译时，看左边；运行时，看右边。 </p>
<ul>
<li><p>若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism) </p>
</li>
<li><p>多态情况下， “看左边” ：看的是父类的引用（父类中不具备子类特有的方法） </p>
<p>​						“看右边” ：看的是子类的对象（实际运行的是子类重写父类的方法）</p>
</li>
</ul>
</li>
<li><p>对象的多态 —在Java中,子类的对象可以替代父类的对象使用 </p>
<ul>
<li>一个变量只能有一种确定的数据类型 </li>
<li>一个引用类型变量可能指向(引用)多种不同类型的对象</li>
</ul>
</li>
</ul>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul>
<li>存在继承或者实现关系</li>
<li>有方法的重写</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();<span class="comment">//Object类型的变量o，指向Person类型的对象</span></span><br><span class="line">o = <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">//Object类型的变量o，指向Student类型的对象</span></span><br></pre></td></tr></table></figure>

<p>子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向 上转型(upcasting)。</p>
<ul>
<li><p>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，</p>
<p>那么该变量就不能再访问子类中特有的属性</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">m.school = “pku”; <span class="comment">//合法,Student类有school成员变量</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">e.school = “pku”; <span class="comment">//非法,Person类没有school成员变量</span></span><br></pre></td></tr></table></figure>

<p><strong>属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编 译错误。</strong></p>
<h3 id="虚拟方法调用"><a href="#虚拟方法调用" class="headerlink" title="虚拟方法调用"></a>虚拟方法调用</h3><p>正常的方法调用 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">e.getInfo();</span><br><span class="line"><span class="type">Student</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">e.getInfo();</span><br></pre></td></tr></table></figure>

<p>虚拟方法调用(多态情况下) :</p>
<p>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父 类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法 确定的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">e.getInfo(); <span class="comment">//调用Student类的getInfo()方法</span></span><br></pre></td></tr></table></figure>

<h3 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h3><p>x instanceof A：检验x是否为类A的对象，返回值为boolean型。</p>
<ul>
<li>要求x所属的类与类A<strong>必须是子类和父类的关系</strong>，否则编译错误</li>
<li>如果x属于类A的子类B，x instanceof A值也为true</li>
</ul>
<h3 id="对象类型转换（Casting）"><a href="#对象类型转换（Casting）" class="headerlink" title="对象类型转换（Casting）"></a>对象类型转换（Casting）</h3><p>基本数据类型的Casting：</p>
<ul>
<li>自动类型转换：小的数据类型可以自动转换成大的数据类型 <ul>
<li>如long g&#x3D;20; double d&#x3D;12.0f</li>
</ul>
</li>
<li>强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型 <ul>
<li>如 float f&#x3D;(float)12.0; int a&#x3D;(int)1200L</li>
</ul>
</li>
</ul>
<p>对Java对象的强制类型转换称为造型 </p>
<ul>
<li><p>从子类到父类的类型转换可以自动进行 </p>
</li>
<li><p>从父类到子类的类型转换必须通过造型(强制类型转换)实现 </p>
</li>
<li><p>无继承关系的引用类型间的转换是非法的 </p>
</li>
<li><p>在造型前可以使用instanceof操作符测试一个对象的类型</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConversionTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">13.4</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> (<span class="type">long</span>) d;<span class="comment">//基本数据类型的装换</span></span><br><span class="line">    System.out.println(l);</span><br><span class="line">    <span class="type">int</span> <span class="variable">in</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// boolean b = (boolean)in;</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">objStr</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">    System.out.println(objStr);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">objPri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 所以下面代码运行时引发ClassCastException异常</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) objPri;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Person e)</span> &#123; <span class="comment">// 设Person类中没有getschool() 方法</span></span><br><span class="line">    <span class="comment">// System.out.pritnln(e.getschool()); //非法,编译时错误</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">      <span class="type">Student</span> <span class="variable">me</span> <span class="operator">=</span> (Student) e; <span class="comment">// 将e强制转换为Student类型</span></span><br><span class="line">      System.out.pritnln(me.getschool());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    <span class="type">Student</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    t.method(m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img data-src="/images/Java基础知识总结（中）/KiTxoUjIpfJaCrN.png" alt="image.png" style="zoom:80%;" />

<p>继承成员变量和方法的区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">  	System.out.println(<span class="built_in">this</span>.count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">  	System.out.println(<span class="built_in">this</span>.count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldMethodTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Sub</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">    System.out.println(s.count);<span class="comment">//20</span></span><br><span class="line">    s.display();<span class="comment">//20</span></span><br><span class="line">    <span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> s;</span><br><span class="line">    System.out.println(b == s);<span class="comment">//true</span></span><br><span class="line">    System.out.println(b.count);<span class="comment">//10</span></span><br><span class="line">    b.display();<span class="comment">//20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类继承父类</p>
<ul>
<li>若子类重写了父类方法，就意味着子类里定义的方法<strong>彻底覆盖了</strong>父类里的同名方法，系统将不可能把父类里的方法转移到子类中。</li>
<li>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量。</li>
</ul>
<h3 id="Object类的使用"><a href="#Object类的使用" class="headerlink" title="Object类的使用"></a>Object类的使用</h3><ul>
<li>Object类是所有Java类的根父类</li>
<li>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">等价于：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Object类中的主要结构</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public Object()</td>
<td align="left">构造器</td>
<td align="left">构造器</td>
</tr>
<tr>
<td align="left">public boolean equals(Object obj)</td>
<td align="left">方法</td>
<td align="left">对象比较</td>
</tr>
<tr>
<td align="left">public int hashCode()</td>
<td align="left">方法</td>
<td align="left">获取Hash码</td>
</tr>
<tr>
<td align="left">public Sting toString()</td>
<td align="left">方法</td>
<td align="left">打印对象的信息</td>
</tr>
</tbody></table>
<h4 id="x3D-x3D-和equals-方法"><a href="#x3D-x3D-和equals-方法" class="headerlink" title="&#x3D;&#x3D;和equals()方法"></a>&#x3D;&#x3D;和equals()方法</h4><ul>
<li>&#x3D;&#x3D;<ul>
<li>基本类型比较值:只要两个变量的值相等，即为true。</li>
<li>引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，&#x3D;&#x3D;才返回true</li>
</ul>
</li>
</ul>
<p><strong>用“&#x3D;&#x3D;”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本 数据类型除外)，否则编译出错</strong></p>
<ul>
<li><p>equals()方法</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>equals()：所有类都继承了Object，也就获得了equals()方法。还可以重写。</p>
<p>只能比较引用类型，其作用与“&#x3D;&#x3D;”相同,比较是否指向同一个对象。</p>
<p>格式:obj1.equals(obj2)</p>
</li>
<li><p>特例：当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对 象； </p>
<p>原因：这些类型中重写了Object中的equals()方法</p>
</li>
<li><p>当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等。</p>
</li>
</ul>
</li>
</ul>
<h5 id="x3D-x3D-和equals-的区别"><a href="#x3D-x3D-和equals-的区别" class="headerlink" title="&#x3D;&#x3D;和equals()的区别"></a>&#x3D;&#x3D;和equals()的区别</h5><ol>
<li>&#x3D;&#x3D; 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址。</li>
<li>equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是&#x3D;&#x3D;，String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。</li>
<li>具体要看自定义类里有没有重写Object的equals方法来判断。</li>
<li>通常情况下，重写equals方法，会比较类中的相应属性的值是否都相等</li>
</ol>
<h4 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h4><ul>
<li><p>toString()方法在Object类中定义，其返回值是String类型，返回类名和它的引用地址。</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在进行String与其它类型数据的连接操作时，自动调用toString()方法</p>
<p>Date now&#x3D;new Date(); </p>
<p>System.out.println(“now&#x3D;”+now); 相当于 </p>
<p>System.out.println(“now&#x3D;”+now.toString());</p>
</li>
<li><p>可以根据需要在用户自定义类型中重写toString()方法 如String 类重写了toString()方法，返回字符串的值。</p>
</li>
</ul>
<h4 id="包装类的使用"><a href="#包装类的使用" class="headerlink" title="包装类的使用"></a>包装类的使用</h4><ul>
<li><p>针对八种基本数据类型定义相应的引用类型—包装类（封装类）</p>
</li>
<li><p>有了类的特点，就可以调用类中的方法，Java才是真正的面向对象</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Charater</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="基本数据类型包装成包装类的实例-—-gt-装箱"><a href="#基本数据类型包装成包装类的实例-—-gt-装箱" class="headerlink" title="基本数据类型包装成包装类的实例  —&gt;装箱"></a>基本数据类型包装成包装类的实例  —&gt;装箱</h5><ul>
<li><p>通过包装类的构造器实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">500</span>; </span><br><span class="line"><span class="type">Integer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br></pre></td></tr></table></figure>
</li>
<li><p>还可以通过字符串参数构造包装类对象：</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Float</span>(“<span class="number">4.56</span>”); </span><br><span class="line"><span class="type">Long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Long</span>(“asdf”); <span class="comment">//NumberFormatException</span></span><br></pre></td></tr></table></figure>

<h5 id="获得包装类对象中包装的基本类型变量-—-gt-拆箱"><a href="#获得包装类对象中包装的基本类型变量-—-gt-拆箱" class="headerlink" title="获得包装类对象中包装的基本类型变量 —&gt;拆箱"></a>获得包装类对象中包装的基本类型变量 —&gt;拆箱</h5><ul>
<li><p>调用包装类的.xxxValue()方法：</p>
<p> boolean b &#x3D; bObj.booleanValue();</p>
</li>
<li><p>JDK1.5之后，支持自动装箱，自动拆箱，但类型必须匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动装箱：基本数据类型 ---&gt;包装类</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">in1</span> <span class="operator">=</span> num2;<span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">b2</span> <span class="operator">=</span> b1;<span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱：包装类---&gt;基本数据类型</span></span><br><span class="line">System.out.println(in1.toString());</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> in1;<span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="字符串转换成基本数据类型"><a href="#字符串转换成基本数据类型" class="headerlink" title="字符串转换成基本数据类型"></a>字符串转换成基本数据类型</h5><ol>
<li>通过包装类的构造器实现： int i &#x3D; new Integer(“12”);</li>
<li>通过包装类的parseXxx(String s)静态方法实现： Float f &#x3D; Float.parseFloat(“12.1”);</li>
</ol>
<h5 id="基本数据类型转换成字符串"><a href="#基本数据类型转换成字符串" class="headerlink" title="基本数据类型转换成字符串"></a>基本数据类型转换成字符串</h5><ol>
<li>调用字符串重载的valueOf()方法： String fstr &#x3D; String.valueOf(2.34f);</li>
<li>更直接的方式： String intStr &#x3D; 5 + “”;</li>
</ol>
<p><img data-src="/images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AD%EF%BC%89/tS2914seKCUnAOl.png"></p>
<h4 id="包装类使用举例"><a href="#包装类使用举例" class="headerlink" title="包装类使用举例"></a>包装类使用举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"><span class="comment">//装箱：包装类使得一个基本数据类型的数据变成了类。</span></span><br><span class="line"><span class="comment">//有了类的特点，可以调用类中的方法。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> t.toString(); <span class="comment">// s = &quot;500&quot;,t是类，有toString方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> Integer.toString(<span class="number">314</span>); <span class="comment">// s1= &quot;314&quot; 将数字转换成字符串。</span></span><br><span class="line">String s2=“<span class="number">4.56</span>”;</span><br><span class="line"><span class="type">double</span> ds=Double.parseDouble(s2); <span class="comment">//将字符串转换成数字</span></span><br><span class="line"><span class="comment">//拆箱：将数字包装类中内容变为基本数据类型。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t.intValue(); <span class="comment">// j = 500，intValue取出包装类中的数据</span></span><br><span class="line"><span class="comment">//包装类在实际开发中用的最多的在于字符串变为基本数据类型。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;30&quot;</span> ;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;30.3&quot;</span> ;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Integer.parseInt(str1) ; <span class="comment">// 将字符串变为int型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> Float.parseFloat(str2) ; <span class="comment">// 将字符串变为int型</span></span><br></pre></td></tr></table></figure>

<h2 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h2><p>MVC是常用的设计模式之一，将整个程序分为三个层次：<strong>视图模型层，控制器层，与 数据模型层</strong>。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式 使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程 序的耦合性。</p>
<p>1.模型层 model 主要处理数据 </p>
<ul>
<li>数据对象封装 model.bean&#x2F;domain </li>
<li>数据库操作类 model.dao </li>
<li>数据库 model.db</li>
</ul>
<p>2.控制层 controller 处理业务逻辑</p>
<ul>
<li>应用界面相关 controller.activity </li>
<li>存放fragment controller.fragment </li>
<li>显示列表的适配器 controller.adapter </li>
<li>服务相关的 controller.service </li>
<li>抽取的基类 controller.base</li>
</ul>
<p>3.视图层 view 显示数据</p>
<ul>
<li>相关工具类 view.utils </li>
<li>自定义view view.ui</li>
</ul>
<h2 id="import关键字"><a href="#import关键字" class="headerlink" title="import关键字"></a>import关键字</h2><ol>
<li>在源文件中使用import显式的导入指定包下的类或接口 </li>
<li>声明在包的声明和类的声明之间</li>
<li>如果需要导入多个类或接口，那么就并列显式多个import语句即可 </li>
<li>举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口</li>
<li>如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句</li>
<li>如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的 是哪个类</li>
<li>如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入</li>
<li>import static组合的使用：调用指定类或接口下的静态的属性或方法</li>
</ol>
<h3 id="JDK中主要的包介绍"><a href="#JDK中主要的包介绍" class="headerlink" title="JDK中主要的包介绍"></a>JDK中主要的包介绍</h3><ol>
<li><p>java.lang—-包含一些Java语言的核心类，如String、Math、Integer、 System和 Thread，提供常用功能 </p>
</li>
<li><p>java.net—-包含执行与网络相关的操作的类和接口。 </p>
</li>
<li><p>java.io —-包含能提供多种输入&#x2F;输出功能的类。</p>
</li>
<li><p>java.util—-包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日 期日历相关的函数。</p>
</li>
<li><p>java.text—-包含了一些java格式化相关的类 </p>
</li>
<li><p>java.sql—-包含了java进行JDBC数据库编程的相关类&#x2F;接口 </p>
</li>
<li><p>java.awt—-包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这 些类被用来构建和管理应用程序的图形用户界面(GUI)。 B&#x2F;S C&#x2F;S</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识总结（下）</title>
    <url>/2020/05/06/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>在Java中声明类、变量和方法时，可使用关键字final来修饰,表示“最终的”</p>
<ul>
<li><p>final标记的类不能被继承。提高安全性，提高程序的可读性。</p>
<p>例如：String类、System类、StringBuffer类</p>
</li>
<li><p>final标记的方法不能被子类重写。 </p>
<p>例如：Object类中的getClass()。</p>
</li>
<li><p>final标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋值，然后才能使用。</p>
</li>
<li><p><strong>final修饰的引用数据类型其地址值不能变化，但是其内部属性可以改变。</strong></p>
</li>
</ul>
<h3 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123; <span class="comment">//错误，不能被继承。</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中国古代，什么人不能有后代，就可以被final声明，称为“太监类”</p>
<span id="more"></span>

<h3 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">  	System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123; <span class="comment">// 错误，不能被重写。</span></span><br><span class="line">  	System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="final修饰变量—常量"><a href="#final修饰变量—常量" class="headerlink" title="final修饰变量—常量"></a>final修饰变量—常量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INFO</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>; <span class="comment">//声明常量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//The final field A.INFO cannot be assigned</span></span><br><span class="line">    INFO = <span class="string">&quot;尚硅谷&quot;</span>;<span class="comment">//错误，final修饰的变量不能被改变</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final举例应用"><a href="#final举例应用" class="headerlink" title="final举例应用"></a>final举例应用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">totalNumber</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> ID;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">	  ID = ++totalNumber; <span class="comment">// 可在构造器中给final修饰的“变量”赋值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    System.out.println(t.ID);</span><br><span class="line">    t.ID = <span class="number">1</span>;<span class="comment">//非法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    x = <span class="number">20</span>;<span class="comment">//非法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line">    y = <span class="number">30</span>; <span class="comment">//合法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><blockquote>
<p>当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上 的对象，只有通过new关键字才会产生出对象，这时系统才会分配内存空间给对象， 其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少 对象的情况下，某些特定的数据在内存空间里只有一份，例如所有的中国人都有个 国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中 都单独分配一个用于代表国家名称的变量。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.radius=radius;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.PI*radius*radius;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建两个Circle对象</span></span><br><span class="line">Circle c1=<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2.0</span>); <span class="comment">//c1.radius=2.0</span></span><br><span class="line">Circle c2=<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">3.0</span>); <span class="comment">//c2.radius=3.0</span></span><br></pre></td></tr></table></figure>

<p>上面的Circle类中的变量radius是一个**实例变量(instance variable)**，它属于类的每一个对象，不能被同一个类的不同对象所共享。上例中c1的radius独立于c2的radius，存储在不同的空间。c1中的radius 变化不会影响c2的radius，反之亦然。</p>
<ul>
<li><p>static关键字的使用范围： </p>
<ul>
<li>在Java类中，可用static修饰属性、方法、代码块、内部类</li>
</ul>
</li>
<li><p>被修饰后的成员具备以下特点：</p>
<ul>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>修饰的成员，被所有对象所共享</li>
<li>访问权限允许时，可以不创建对象，直接被类调用</li>
</ul>
</li>
</ul>
<h3 id="静态变量（类变量）"><a href="#静态变量（类变量）" class="headerlink" title="静态变量（类变量）"></a>静态变量（类变量）</h3><p>类属性作为该类各个对象之间共享的变量。在设计类时,分析哪些属性不因对象的不同而改变，将这些属性设置为类属性。相应的方法设置为类方法。</p>
<p>拿上面的煮个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.PI*radius*radius;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建两个Circle对象</span></span><br><span class="line">Circle c1=<span class="keyword">new</span> <span class="title class_">Circle</span>(); <span class="comment">//c1.radius=1.0</span></span><br><span class="line">Circle c2=<span class="keyword">new</span> <span class="title class_">Circle</span>(); <span class="comment">//c2.radius=1.0</span></span><br><span class="line"><span class="comment">//这两个对象是共用这个radius，radius在内存空间中指向的是同一个地址</span></span><br></pre></td></tr></table></figure>

<p>再煮个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    total++;</span><br><span class="line">    id = total;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;<span class="comment">//每次new对象的时候id会自动加1</span></span><br><span class="line">    total++;</span><br><span class="line">    id = total;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">Tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    Tom.id=<span class="number">0</span>;</span><br><span class="line">    total=<span class="number">100</span>; <span class="comment">// 不用创建对象就可以访问静态成员</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    Person.total = <span class="number">100</span>; <span class="comment">// 不用创建对象就可以访问静态成员</span></span><br><span class="line">    <span class="comment">//访问方式：类名.类属性，类名.类方法</span></span><br><span class="line">    System.out.println(Person.total);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    System.out.println(c.total); <span class="comment">//输出101</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="/images/Java基础知识总结（下）/image-20200506143718368.png" alt="image-20200506143718368.png" style="zoom: 70%;" />



<h3 id="静态方法（类方法）"><a href="#静态方法（类方法）" class="headerlink" title="静态方法（类方法）"></a>静态方法（类方法）</h3><p>如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。</p>
<ul>
<li><p>因为不需要实例就可以访问static方法，因此static方法内部不能有this。&#x3D;&#x3D;(也不能有super )&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;static修饰的方法不能被重写&#x3D;&#x3D;</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setTotalPerson</span><span class="params">(<span class="type">int</span> total)</span>&#123;</span><br><span class="line">  	<span class="built_in">this</span>.total=total; <span class="comment">//非法，在static方法中不能有this，也不能有super</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    total++;</span><br><span class="line">    id = total;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	  Person.setTotalPerson(<span class="number">3</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单例-Singleton-设计模式"><a href="#单例-Singleton-设计模式" class="headerlink" title="单例(Singleton)设计模式"></a>单例(Singleton)设计模式</h3><blockquote>
<p>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、 以及解决问题的思考方式。设计模免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。</p>
<p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象， 静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。</p>
</blockquote>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="comment">// 1.私有化构造器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line">  <span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">  <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> single;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p>这种写法暂时还存在线程安全的问题，后面多线程的时候再修复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="comment">// 1.私有化构造器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line">  <span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton single;</span><br><span class="line">  <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="keyword">if</span>(single == <span class="literal">null</span>) &#123;</span><br><span class="line">    	single = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> single;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h4><p>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的 产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>网站的计数器，一般是单例模式实现，否则难以同步</li>
<li>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</li>
<li>项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。</li>
<li>Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li>
</ul>
<h3 id="main方法的理解"><a href="#main方法的理解" class="headerlink" title="main方法的理解"></a>main方法的理解</h3><blockquote>
<p>由于Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是 public，又因为Java虚拟机在执行main()方法时不必创建对象，所以该方法必须 是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令 时传递给所运行的类的参数。</p>
<p>又因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创 建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情 况，我们在之前的例子中多次碰到。</p>
</blockquote>
<h4 id="命令行参数用法举例"><a href="#命令行参数用法举例" class="headerlink" title="命令行参数用法举例"></a>命令行参数用法举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandPara</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;args[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + args[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行程序CommandPara.java</span></span><br><span class="line"><span class="comment">//java CommandPara “Tom&quot; “Jerry&quot; “John&quot;</span></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//args[0] = Tom</span></span><br><span class="line"><span class="comment">//args[1] = Jerry</span></span><br><span class="line"><span class="comment">//args[2] = John</span></span><br></pre></td></tr></table></figure>



<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>对Java类或对象进行初始化</p>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  <span class="comment">//属性......</span></span><br><span class="line">  <span class="comment">//代码块</span></span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//构造器......</span></span><br><span class="line">  <span class="comment">//方法......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li><p>不可以调用非静态的属性和方法。</p>
</li>
<li><p>静态代码块的执行要先于非静态代码块。</p>
</li>
<li><p>静态代码块随着类的加载而加载，并且只执行一次。</p>
</li>
</ol>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> total;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    total = <span class="number">100</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;in static block!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;total = &quot;</span> + Person.total);<span class="comment">//100</span></span><br><span class="line">    System.out.println(<span class="string">&quot;total = &quot;</span> + Person.total);<span class="comment">//100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="非静态代码块"><a href="#非静态代码块" class="headerlink" title="非静态代码块"></a>非静态代码块</h3><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  <span class="comment">//属性.......</span></span><br><span class="line">  <span class="comment">//代码块</span></span><br><span class="line">  &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//构造器.......</span></span><br><span class="line">  <span class="comment">//方法......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li>可以调用静态的代码结构，也可以调用非静态的结构。</li>
<li>每次创建对象的时候都会执行一次，且先于构造器的执行。</li>
</ol>
<h3 id="总结：程序中成员变量赋值的执行顺序"><a href="#总结：程序中成员变量赋值的执行顺序" class="headerlink" title="总结：程序中成员变量赋值的执行顺序"></a>总结：程序中成员变量赋值的执行顺序</h3><pre class="mermaid">graph TB
a(默认初始化) --> b(显示初始化)
a(默认初始化) --> c(代码块)
b --> d(构造器)
c --> d
d --> e(通过 对象.属性 或 对象.方法 给属性赋值)</pre>



<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><blockquote>
<p>当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。</p>
<p>内部类一般用在定义它的类或语句块之内，在外部引用它时必须给出完 整的名称。</p>
</blockquote>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><ul>
<li><p>内部类作为类的成员的角色：</p>
<ul>
<li>和外部类不同，内部类还可以声明为private或protected</li>
<li>可以调用外部类的结构</li>
<li>内部类可以声明为static的，但此时就不能再使用外层类的非static的成员变量</li>
</ul>
</li>
<li><p>内部类作为类的角色：</p>
<ul>
<li>可以在内部定义属性、方法、构造器等结构</li>
<li>可以声明为abstract类 ，因此可以被其它的内部类继承</li>
<li>可以声明为final的</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员内部类中才可声明static成员。</li>
<li>外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式</li>
<li>成员内部类可以直接使用外部类的所有成员，包括私有的数据</li>
<li>当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的</li>
</ol>
<p><strong>举例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">111</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">222</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mb</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">      System.out.println(s); <span class="comment">// 局部变量s</span></span><br><span class="line">      System.out.println(<span class="built_in">this</span>.s); <span class="comment">// 内部类对象的属性s</span></span><br><span class="line">      System.out.println(Outer.<span class="built_in">this</span>.s); <span class="comment">// 外部类对象属性s</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="type">Outer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">    Outer.<span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> a.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    b.mb(<span class="number">333</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 外部类&#123;</span><br><span class="line">  方法()&#123;</span><br><span class="line">    class 局部内部类&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    class 局部内部类&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li>只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类</li>
<li>是它的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类的父类或父接口类型</li>
</ol>
<p>局部内部类的特点</p>
<ul>
<li>内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号，以及数字编号。 </li>
<li>只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类。 </li>
<li>局部内部类可以使用外部类的成员，包括私有的。 </li>
<li>局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内部类和局部变量的声明周期不同所致。 </li>
<li>局部内部类和局部变量地位类似，不能使用public,protected,缺省,private </li>
<li>局部内部类不能使用static修饰，因此也不能包含静态成员</li>
</ul>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。一个匿名内部类一定是在new的后面，用其隐含实现一个接口或 实现一个类。</p>
<p><strong>特点：</strong></p>
<ul>
<li>匿名内部类必须继承父类或实现接口 </li>
<li>匿名内部类只能有一个对象 </li>
<li>匿名内部类对象只能使用多态形式引用</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Outer</span>().callInner(<span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">      <span class="comment">//接口是不能new但此处比较特殊是子类对象实现接口，只不过没有为对象取名</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(“implement <span class="keyword">for</span> fun1<span class="string">&quot;);</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;);// 两步写成一步了</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	public void callInner(A a) &#123;</span></span><br><span class="line"><span class="string">		a.fun1();</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125; </span></span><br></pre></td></tr></table></figure>

<p>思考题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Inner</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    s1.a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">Inner</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    s2.a = <span class="number">20</span>;</span><br><span class="line">    Test.<span class="type">Inner</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>.Inner();</span><br><span class="line">    System.out.println(s3.a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    <span class="type">Inner</span> <span class="variable">r</span> <span class="operator">=</span> t.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    System.out.println(r.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果是两个5</p>
<p>没想到吧，其实仔细看一下也不能理解</p>
<h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><blockquote>
<p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一 般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父 类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p>
</blockquote>
<p>先煮个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;  <span class="comment">//抽象类</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;  <span class="comment">//抽象方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">  	System.out.println(<span class="string">&quot;A类中定义的m2方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;<span class="comment">//抽象方法的具体实现</span></span><br><span class="line">  	System.out.println(<span class="string">&quot;B类中定义的m1方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    a.m1();<span class="comment">//虚拟方法调用</span></span><br><span class="line">    a.m2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类的一些规定"><a href="#抽象类的一些规定" class="headerlink" title="抽象类的一些规定"></a>抽象类的一些规定</h3><ul>
<li>用abstract关键字来修饰一个类，这个类叫做抽象类。</li>
<li>用abstract来修饰一个方法，该方法叫做抽象方法。<ul>
<li>抽象方法：只有方法的声明，没有方法的实现，以分号结束： 比如：public abstract void talk();</li>
</ul>
</li>
<li>含有抽象方法的类必须被声明为抽象类。</li>
<li>抽象类&#x3D;&#x3D;不能被实例化&#x3D;&#x3D;。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写&#x3D;&#x3D;全部&#x3D;&#x3D;的抽象方法，则该类仍为抽象类。</li>
<li>抽象类可以有构造器，但是不能直接用构造器实例化对象，但实例化子类的时候，就会初始化父类，不管父类是不是抽象类都会调用父类的构造方法，初始化一个类，都要先先初始化父类。</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>不能用abstract修饰变量、代码块、构造器；</li>
<li>不能用abstract修饰私有方法、静态方法、final的方法、final的类。</li>
</ol>
<h3 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h3><blockquote>
<p>在航运公司系统中，Vehicle类需要定义两个方法分别计算运 输工具的燃料效率和行驶距离。</p>
<p>问题：卡车(Truck)和驳船(RiverBarge)的燃料效率和行驶距离的计算方法完全不 同。Vehicle类不能提供计算方法，但子类可以。</p>
</blockquote>
<p>具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">()</span>; <span class="comment">//计算燃料效率的抽象方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">()</span>; <span class="comment">//计算行驶距离的抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Truck</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="comment">//写出计算卡车的燃料效率的具体方法 </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="comment">//写出计算卡车行驶距离的具体方法 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RiverBarge</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="comment">//写出计算驳船的燃料效率的具体方法 </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="comment">//写出计算驳船行驶距离的具体方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：抽象类不能实例化 new Vihicle()是非法的!</strong></p>
<h3 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h3><blockquote>
<p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
</blockquote>
<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用， 这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    code();</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;执行时间是：&quot;</span> + (end - start));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubTemplate</span> <span class="keyword">extends</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">      System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方 法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。</li>
<li>另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又 没有is-a的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打 印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都 支持USB连接。</li>
<li>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是&#x2F;要…则 必须能…”的思想。继承是一个”是不是”的关系，而接口实现则是 “能不能” 的关系。</li>
<li>接口的本质是契约，标准，规范，就像我们的法律一样。制定好后大家都 要遵守。</li>
</ol>
<img data-src="/images/Java基础知识总结（下）/image-20200506191958389.png" alt="image-20200506191958389" style="zoom:67%;" />

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runner</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">ID</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h3><ul>
<li><strong>接口中所有成员变量都默认是public static final修饰的</strong></li>
<li><strong>接口中所有抽象方法都是public abstract修饰的</strong></li>
<li>接口中没有构造器</li>
<li>接口可以被多实现</li>
</ul>
<p>上面示例的代码实际上是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runner</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ID</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Runner</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Runner</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 准备工作：弯腰、蹬腿、咬牙、瞪眼</span></span><br><span class="line">    <span class="comment">// 开跑</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 摆动手臂</span></span><br><span class="line">    <span class="comment">// 维持直线方向</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 减速直至停止、喝水。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>一个类可以实现多个接口，接口也可以继承其它接口。</li>
<li>实现接口的类中必须提供接口中所有方法的具体实现，方可实例化。否则，仍为抽象类，不可实例化。</li>
<li>与继承关系类似，接口与实现类之间存在多态性</li>
<li>接口和类是并列关系，或者可以理解为一种特殊的类。从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义(JDK7.0及之前)，而没有变量和方法的实现。</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Runner</span> &#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimmer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Creator</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Creator</span> <span class="keyword">implements</span> <span class="title class_">Runner</span>, Swimmer&#123;<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类必须给出接口以及父接口中所有方法的实现。否则，实现类仍需声明为abstract的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span>&#123;</span><br><span class="line">  String s=“MyInterface”;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">absM1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SubInterface</span> <span class="keyword">extends</span> <span class="title class_">MyInterface</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">absM2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubAdapter</span> <span class="keyword">implements</span> <span class="title class_">SubInterface</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">absM1</span><span class="params">()</span>&#123;System.out.println(“absM1”);&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">absM2</span><span class="params">()</span>&#123;System.out.println(“absM2”);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-8中关于接口的改进"><a href="#Java-8中关于接口的改进" class="headerlink" title="Java 8中关于接口的改进"></a>Java 8中关于接口的改进</h3><p>Java 8中，你可以为接口添加静态方法和默认方法。从技术角度来说，这是完 全合法的，只是它看起来违反了接口作为一个抽象定义的理念。</p>
<h4 id="静态方法："><a href="#静态方法：" class="headerlink" title="静态方法："></a>静态方法：</h4><p>使用 static 关键字修饰。可以通过接口直接调用静态方法，并执行 其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中 找到像Collection&#x2F;Collections或者Path&#x2F;Paths这样成对的接口和类。 </p>
<h4 id="默认方法："><a href="#默认方法：" class="headerlink" title="默认方法："></a>默认方法：</h4><p>默认方法使用 default 关键字修饰。可以通过实现类对象来调用。 我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。 比如：java 8 API中对Collection、List、Comparator等接口提供了丰富的默认 方法。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AA</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;<span class="comment">//默认方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span> String <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;上海&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;<span class="comment">//静态方法</span></span><br><span class="line">    System.out.println(“hello lambda!<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><p>若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同参数的方法（不管此方法是否是默认方法），在实现类同时实现了这两个接口时，会出现：接口冲突。</p>
</li>
<li><p>若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，则不会出现冲突问题。因为此时遵守：类优先原则。接口中具有相同名称和参数的默认方法会被忽略。</p>
</li>
</ul>
<p>煮个有趣的栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Filial</span> &#123;<span class="comment">// 孝顺的</span></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">help</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;老妈，我来救你了&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Spoony</span> &#123;<span class="comment">// 痴情的</span></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">help</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;媳妇，别怕，我来了&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">implements</span> <span class="title class_">Filial</span>, Spoony &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">help</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我该怎么办呢？&quot;</span>);</span><br><span class="line">    Filial.<span class="built_in">super</span>.help();</span><br><span class="line">    Spoony.<span class="built_in">super</span>.help();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Network</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealServer</span> <span class="keyword">implements</span> <span class="title class_">Network</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;真实服务器上网浏览信息&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyServer</span> <span class="keyword">implements</span> <span class="title class_">Network</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Network network;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ProxyServer</span><span class="params">(Network network)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.network = network;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;检查网络连接等操作&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span> &#123;</span><br><span class="line">    check();</span><br><span class="line">    network.browse();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Network</span> <span class="variable">net</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyServer</span>(<span class="keyword">new</span> <span class="title class_">RealServer</span>());</span><br><span class="line">    net.browse();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>安全代理：屏蔽对真实角色的直接访问。</li>
<li>远程代理：通过代理类处理远程方法调用（RMI）</li>
<li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象 比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有 100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理 模式，当需要查看图片时，用proxy来进行大图片的打开。</li>
</ol>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>静态代理（静态定义代理类）</li>
<li>动态代理（动态生成代理类）</li>
</ul>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>略……..</p>
<h3 id="接口和抽象类之间的对比"><a href="#接口和抽象类之间的对比" class="headerlink" title="接口和抽象类之间的对比"></a>接口和抽象类之间的对比</h3><table>
<thead>
<tr>
<th align="left">区别点</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td align="left">定义</td>
<td>包含抽象方法的类</td>
<td>主要是抽象方法和全局常量的集合</td>
</tr>
<tr>
<td align="left">组成</td>
<td>构造器、抽象方法、普通方法、常量、变量</td>
<td>常量、抽象方法、（jdk8.0之后：默认方法、静态方法）</td>
</tr>
<tr>
<td align="left">使用</td>
<td>子类继承抽象类（extends）</td>
<td>子类实现接口（implements）</td>
</tr>
<tr>
<td align="left">关系</td>
<td>抽象类可以实现多个接口</td>
<td>接口不能继承抽象类，但接口可以继承接口</td>
</tr>
<tr>
<td align="left">局限</td>
<td>只能单继承</td>
<td>可以多实现</td>
</tr>
<tr>
<td align="left">实际</td>
<td>作为一个模板</td>
<td>作为一种标准或是表示一种能力</td>
</tr>
<tr>
<td align="left">常见设计模式</td>
<td>模板方法</td>
<td>工厂设计模式、代理模式</td>
</tr>
</tbody></table>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><blockquote>
<p>在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美， 在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避 免的，比如：客户输入数据的格式，读取文件是否存在，网络是否始终保持 通畅等等。</p>
</blockquote>
<p>Java程序在执行过程中所发生的异常事件可分为两大类：</p>
<ul>
<li>Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError。一般不会编写针对性的代码进行处理。</li>
<li>Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使 用针对性的代码进行处理。例如：<ul>
<li>空指针异常</li>
<li>读取的文件不存在</li>
<li>网络连接中断</li>
<li>数据角标越界</li>
</ul>
</li>
</ul>
<p>对于这些错误，一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法是由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理。</p>
<p>捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生。比如：除数为0，数组下标越界等。</p>
<p>这里又可以将异常分为两类：分别是<strong>编译时异常</strong>和<strong>运行时异常</strong>。</p>
<img data-src="/images/Java基础知识总结（下）/image-20200512121258745.png" alt="image-20200512121258745" style="zoom: 80%;" />

<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。</p>
<p>对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。</p>
<h3 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h3><p>是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。</p>
<p>对于这类异常，如果程序不处理，可能会带来意想不到的结果。</p>
<h3 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h3><h4 id="java-lang-RuntimeException"><a href="#java-lang-RuntimeException" class="headerlink" title="java.lang.RuntimeException"></a>java.lang.RuntimeException</h4><ol>
<li><p>ClassCastException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    Order order;</span><br><span class="line">    order = (Order) obj;</span><br><span class="line">    System.out.println(order);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>ArrayIndexOutOfBoundsException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexOutExp</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String friends[] = &#123; <span class="string">&quot;lisa&quot;</span>, <span class="string">&quot;bily&quot;</span>, <span class="string">&quot;kessy&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      System.out.println(friends[i]); <span class="comment">// friends[4]?</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;/nthis is the end&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>NullPointerException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NullRef</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">NullRef</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullRef</span>();</span><br><span class="line">    t = <span class="literal">null</span>;</span><br><span class="line">    System.out.println(t.i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>ArithmeticException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DivideZero</span> &#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    DivideZero c=<span class="keyword">new</span> <span class="title class_">DivideZero</span>();</span><br><span class="line">    y=<span class="number">3</span>/c.x;</span><br><span class="line">    System.out.println(<span class="string">&quot;program ends ok!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>NumberFormatException</p>
</li>
<li><p>InputMismatchException</p>
</li>
<li><p>……</p>
</li>
</ol>
<h4 id="java-io-IOExeption"><a href="#java-io-IOExeption" class="headerlink" title="java.io.IOExeption"></a>java.io.IOExeption</h4><ol>
<li>FileNotFoundException</li>
<li>EOFException</li>
</ol>
<h4 id="java-lang-ClassNotFoundException"><a href="#java-lang-ClassNotFoundException" class="headerlink" title="java.lang.ClassNotFoundException"></a>java.lang.ClassNotFoundException</h4><h4 id="java-lang-InterruptedException"><a href="#java-lang-InterruptedException" class="headerlink" title="java.lang.InterruptedException"></a>java.lang.InterruptedException</h4><h4 id="java-io-FileNotFoundException"><a href="#java-io-FileNotFoundException" class="headerlink" title="java.io.FileNotFoundException"></a>java.io.FileNotFoundException</h4><h4 id="java-sql-SQLException"><a href="#java-sql-SQLException" class="headerlink" title="java.sql.SQLException"></a>java.sql.SQLException</h4><h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><blockquote>
<p>在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x&#x2F;y运算时，要检测分母为0，数据为空，输入的不是数据而是字符等。过多的if-else分支会导致程序的代码加长、臃肿，可读性差。因此采用异常处理机制。</p>
</blockquote>
<h4 id="机制一：try-catch-finally"><a href="#机制一：try-catch-finally" class="headerlink" title="机制一：try-catch-finally"></a>机制一：try-catch-finally</h4><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  ...... <span class="comment">//可能产生异常的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName1 e )&#123;</span><br><span class="line">  ...... <span class="comment">//当产生ExceptionName1型异常时的处置措施</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName2 e )&#123;</span><br><span class="line">  ...... <span class="comment">//当产生ExceptionName2型异常时的处置措施</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">  ...... <span class="comment">//无论是否发生异常，都无条件执行的语句</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li><p>try </p>
<p>捕获异常的第一步是用try{…}语句块选定捕获异常的范围，将可能出现异常的代码放在try语句块中。</p>
</li>
<li><p>catch (Exceptiontype e)</p>
<p>在catch语句块中是对异常对象进行处理的代码。每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。</p>
</li>
<li><p>finally</p>
<p>捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，finally块中的语句都会被执行。</p>
</li>
</ul>
<p>如果明确知道产生的是何种异常，可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。 </p>
<p>比 如 ： 可以用ArithmeticException 类作为参数的地方，就可以用RuntimeException类作为参数，或者用所有异常的父类Exception类作为参数。但不能是与ArithmeticException类无关的异常，比如：NullPointerException（catch 中的语句将不会执行）。</p>
<p>捕获异常的有关信息：与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法。</p>
<ul>
<li><p>getMessage() 获取异常信息，返回字符串 </p>
</li>
<li><p>printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。</p>
</li>
</ul>
<img data-src="/images/Java基础知识总结（下）/image-20200512201503354.png" alt="image-20200512201503354" style="zoom:80%;" />

<h4 id="常见异常捕获的举例"><a href="#常见异常捕获的举例" class="headerlink" title="常见异常捕获的举例"></a>常见异常捕获的举例</h4><h5 id="数据角标越界"><a href="#数据角标越界" class="headerlink" title="数据角标越界"></a>数据角标越界</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexOutExp</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String friends[] = &#123; <span class="string">&quot;lisa&quot;</span>, <span class="string">&quot;bily&quot;</span>, <span class="string">&quot;kessy&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        System.out.println(friends[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;index err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;/nthis is the end&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//lisa</span></span><br><span class="line"><span class="comment">//bily</span></span><br><span class="line"><span class="comment">//kessy</span></span><br><span class="line"><span class="comment">//index err</span></span><br><span class="line"><span class="comment">//this is the end</span></span><br></pre></td></tr></table></figure>

<h5 id="除零异常"><a href="#除零异常" class="headerlink" title="除零异常"></a>除零异常</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DivideZero1</span> &#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">DivideZero1</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DivideZero1</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      y = <span class="number">3</span> / c.x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;divide by zero error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;program ends ok!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//divide by zero error!</span></span><br><span class="line"><span class="comment">//program ends ok!</span></span><br></pre></td></tr></table></figure>

<h4 id="不捕获异常时的情况"><a href="#不捕获异常时的情况" class="headerlink" title="不捕获异常时的情况"></a>不捕获异常时的情况</h4><p>前面使用的异常都是RuntimeException类或是它的子类，这些类的异常的特点是：即使没有使用try和catch捕获，Java自己也能捕获，并且编译通过( <strong>但运行时会发生异常使得程序运行终止</strong> )。</p>
<p>如果抛出的异常是IOException等类型的非运行时异常，则必须捕获，否则编译错误。也就是说，我们必须处理编译时异常，将异常进行捕捉，转化为运行时异常。</p>
<h4 id="机制二：throws"><a href="#机制二：throws" class="headerlink" title="机制二：throws"></a>机制二：throws</h4><p>如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这 种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理， 而由该方法的<strong>调用者</strong>负责处理。</p>
<p>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p>
<h5 id="声明抛出异常举例："><a href="#声明抛出异常举例：" class="headerlink" title="声明抛出异常举例："></a>声明抛出异常举例：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String file)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">  ……</span><br><span class="line">    <span class="comment">// 读文件的操作可能产生FileNotFoundException类型的异常</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">  ..……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowsTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ThrowsTest</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThrowsTest</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      t.readFile();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;atguigushk.txt&quot;</span>);</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    b = in.read();</span><br><span class="line">    <span class="keyword">while</span> (b != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.print((<span class="type">char</span>) b);</span><br><span class="line">      b = in.read();</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="/images/Java基础知识总结（下）/image-20200512203407744.png" alt="image-20200512203407744" style="zoom:80%;" />

<h5 id="重写方法声明抛出异常的原则"><a href="#重写方法声明抛出异常的原则" class="headerlink" title="重写方法声明抛出异常的原则"></a>重写方法声明抛出异常的原则</h5><p><strong>重写方法不能抛出比被重写方法范围更大的异常类型</strong>。在多态的情况下，对methodA()方法的调用-异常的捕获按父类声明的异常处理。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B1</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B2</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">//报错</span></span><br><span class="line">    ……</span><br><span class="line">  &#125; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="手动抛出异常"><a href="#手动抛出异常" class="headerlink" title="手动抛出异常"></a>手动抛出异常</h3><p>Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要使用人工创建并抛出。</p>
<p>首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运行环境)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IOException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line"><span class="keyword">throw</span> e;</span><br></pre></td></tr></table></figure>

<p>可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将 会产生语法错误：</p>
<p>&#x3D;&#x3D;throw new String(“want to throw”);&#x3D;&#x3D;</p>
<h3 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h3><ul>
<li><p>一般地，用户自定义异常类都是RuntimeException的子类。 </p>
</li>
<li><p>自定义异常类通常需要编写几个重载的构造器。 </p>
</li>
<li><p>自定义异常需要提供serialVersionUID </p>
</li>
<li><p>自定义的异常通过throw抛出。 </p>
</li>
<li><p>自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。</p>
</li>
</ul>
<p>用户自定义异常类MyException，用于描述数据取值范围错误信息。用户自己的异常类必须继承现有的异常类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">13465653435L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> idnumber;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(message);</span><br><span class="line">    <span class="built_in">this</span>.idnumber = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> idnumber;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExpTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regist</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;人数为负值，不合理&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      System.out.println(<span class="string">&quot;登记人数&quot;</span> + num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">manager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      regist(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">      System.out.print(<span class="string">&quot;登记失败，出错种类&quot;</span> + e.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(<span class="string">&quot;本次登记操作结束&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="type">MyExpTest</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyExpTest</span>();</span><br><span class="line">    t.manager();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="/images/Java基础知识总结（下）/image-20200512204401486.png" alt="image-20200512204401486" style="zoom: 67%;" />]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java枚举类</title>
    <url>/2020/06/16/Java%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><p>在JDK5.0之前需要自定义枚举类，JDK5.0中新增了enum关键字，用来定义枚举类</p>
<h2 id="枚举类的特点"><a href="#枚举类的特点" class="headerlink" title="枚举类的特点"></a>枚举类的特点</h2><ul>
<li>枚举类对象的属性不允许被改动，所以应该使用private final修饰</li>
<li>枚举类的被private final修饰的属性要在构造器中为期赋值</li>
<li>若枚举类显式的定义了带参数的构造器，则在列出枚举值时也必须传入对应参数</li>
</ul>
<h1 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h1><ol>
<li>私有化类的构造器，保证不能再类的外部创建其对象</li>
<li>在类的内部穿件枚举类的实例，并用public static final修饰</li>
<li>对象如果有实例变量，应该声明为private final，并在构造器中初始化</li>
</ol>
<span id="more"></span>

<p>用季节来举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String NAME;<span class="comment">//季节的名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String DESC;<span class="comment">//季节的描述</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.NAME = seasonName;</span><br><span class="line">    <span class="built_in">this</span>.DESC = seasonDesc;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;白雪皑皑&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="enum关键字定义枚举类"><a href="#enum关键字定义枚举类" class="headerlink" title="enum关键字定义枚举类"></a>enum关键字定义枚举类</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>用enum定义的枚举类默认继承了java.lang.Enum类，因此不能再继承其他类</li>
<li>枚举类的构造器只能用private修饰</li>
<li>枚举类的所有实例必须在枚举类中显式列出（用“,”分隔，“;”）结尾，列出的实例会自动添加public static final修饰</li>
<li>必须要在枚举类的第一行声明枚举类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">  SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春风又绿江南岸&quot;</span>),</span><br><span class="line">  SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;映日荷花别样红&quot;</span>),</span><br><span class="line">  AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋水共长天一色&quot;</span>),</span><br><span class="line">  WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;窗含西岭千秋雪&quot;</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">    <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> seasonName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> seasonDesc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Enum类的主要方法"><a href="#Enum类的主要方法" class="headerlink" title="Enum类的主要方法"></a>Enum类的主要方法</h1><ul>
<li>values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 </li>
<li>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常： IllegalArgumentException。 </li>
<li>toString()：返回当前枚举类对象常量的名称</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用类</title>
    <url>/2020/06/06/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="字符串相关的类"><a href="#字符串相关的类" class="headerlink" title="字符串相关的类"></a>字符串相关的类</h1><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="String类的特性"><a href="#String类的特性" class="headerlink" title="String类的特性"></a>String类的特性</h3><ul>
<li>String类是字符串类，java中所有的字符串字面值，都作为此类的示例实现。</li>
<li>String类是一个final类，不可用继承，定义的变量是常量，定义之后也不能改变。</li>
<li>String对象的字符内容是存储在一个字符数组value[]中的。</li>
</ul>
<img data-src="../images/Java常用类/image-20200606144906113.png" alt="image-20200606144906113" style="zoom:80%;" />

<p>String str1 &#x3D; “abc”;与String str2 &#x3D; new String(“abc”);的区别？</p>
<ul>
<li>前者是一个字符串常量，存储在字符串常量池中，目的是共享。</li>
<li>后者是字符串非常量对象，存储在堆中。</li>
</ul>
<span id="more"></span>

<img data-src="../images/Java常用类/image-20200606145317796.png" alt="image-20200606145317796" style="zoom:80%;" />

<p>字符串对象的存储：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<img data-src="../images/Java常用类/image-20200606145604487.png" alt="image-20200606145604487" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line">System.out.println(p1.name == p2.name);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<img data-src="../images/Java常用类/image-20200606145948843.png" alt="image-20200606145948843" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> (s1 + s2).intern();</span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s4 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<img data-src="../images/Java常用类/image-20200606150430936.png" alt="image-20200606150430936" style="zoom:80%;" />

<p>通过上面这些例子，可以总结出来：</p>
<ol>
<li>常量和常量的拼接结果任然在常量池，并且常量池中不会有相同内容的常量。</li>
<li>只要两个拼接的字符串有一个是变量，拼接的结果就在堆中。</li>
<li>如果拼接的结果调用intern()方法，返回值就在常量池中。</li>
</ol>
<h3 id="String的使用陷阱"><a href="#String的使用陷阱" class="headerlink" title="String的使用陷阱"></a>String的使用陷阱</h3><ul>
<li><p>String s1 &#x3D; “a”; 说明：在字符串常量池中创建了一个字面量为”a”的字符串。 </p>
</li>
<li><p>s1 &#x3D; s1 + “b”; 说明：实际上原来的“a”字符串对象<strong>已经丢弃了</strong>，现在在堆空间中产生了一个字符串s1+”b”（也就是”ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，<strong>会极大影响程序的性能</strong>。 </p>
</li>
<li><p>String s2 &#x3D; “ab”; </p>
<p>说明：直接在字符串常量池中创建一个字面量为”ab”的字符串。 </p>
</li>
<li><p>String s3 &#x3D; “a” + “b”; </p>
<p>说明：s3指向字符串常量池中已经创建的”ab”的字符串。</p>
</li>
<li><p>String s4 &#x3D; s1.intern();</p>
<p>说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的”ab”字符串赋值给s4。</p>
</li>
</ul>
<h3 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h3><ul>
<li><p>int length();  返回字符串的长度</p>
</li>
<li><p>char charAt(int index);  返回索引出的字符串</p>
</li>
<li><p>boolean isEmpty();  判断字符串是否为空</p>
</li>
<li><p>String toLowCase();  将字符串全部转换为小写</p>
</li>
<li><p>String toUpperCase();  将字符串全部转换为大写</p>
</li>
<li><p>String trim();  将字符串首位的空格去掉，返回字符串的副本</p>
</li>
<li><p>boolean equals(String str);  比较两个字符串内容是否相同</p>
</li>
<li><p>boolean equalsIgnoreCase(String str);  比较两个字符串内容是否相同，忽略大小写</p>
</li>
<li><p>String concat(String str);  将指定字符串拼接到该字符串的结尾</p>
</li>
<li><p>int conpareTo(String str);比较两个字符串的大小</p>
</li>
<li><p>String substring(int beginIndex);   返回一个从beginIndex开始到最后的一个字符的新字符串</p>
</li>
<li><p>String substring(int beginIndex, int endIndex);  返回一个从beginIndex开始到endIndex（不包含）结束的新字符串</p>
</li>
<li><p>boolean endsWith(String suffix);  判断此字符串是否以指定的后缀结束 </p>
</li>
<li><p>boolean startsWith(String prefix);  判断此字符串是否以指定的前缀开始 </p>
</li>
<li><p>boolean startsWith(String prefix, int toffset); 判断此字符串从指定索引开始的子字符串是否以指定前缀开始</p>
</li>
<li><p>boolean contains(CharSequence s);  判断当前字符串是否包含指定的 char 值序列</p>
</li>
<li><p>int indexOf(String str);  返回指定子字符串在此字符串中第一次出现处的索引 </p>
</li>
<li><p>int indexOf(String str, int fromIndex);  从指定的索引开始，获取指定子字符串在此字符串中第一次出现处的索引值</p>
</li>
<li><p>int lastIndexOf(String str);  返回指定子字符串在此字符串中最右边出现处的索引值</p>
</li>
<li><p>int lastIndexOf(String str, int fromIndex);  返回指定子字符串在此字符串中最后 一次出现处的索引值，从指定的索引开始反向搜索 <strong>注：indexOf()和lastIndexOf()方法如果未找到都是返回-1</strong></p>
</li>
<li><p>String replace(char oldChar, char newChar);  返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 </p>
</li>
<li><p>String replace(CharSequence target, CharSequence replacement);  使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</p>
</li>
<li><p>String replaceAll(String regex, String replacement) ;  使用给定的replacement替换此字符串所有匹配给定的正则表达式的子字符串。</p>
</li>
<li><p>String replaceFirst(String regex, String replacement) ; 使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串。</p>
</li>
<li><p>boolean matches(String regex); 判断此字符串是否匹配给定的正则表达式。</p>
</li>
<li><p>String[] split(String regex);  根据给定正则表达式的匹配拆分此字符串。</p>
</li>
<li><p>String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</p>
</li>
</ul>
<h3 id="String与字符数组的转换"><a href="#String与字符数组的转换" class="headerlink" title="String与字符数组的转换"></a>String与字符数组的转换</h3><ul>
<li><p>字符数组   —&gt;  字符串</p>
<p>String 类的构造器：String(char[]) 和 String(char[]，int offset，int length) 分别用字符数组中的全部字符和部分字符创建字符串对象。</p>
</li>
<li><p>字符串  —&gt;  字符数组</p>
<p>char[] toCharArray()：将字符串中的全部字符存放在一个字符数组中的方法。</p>
<p>void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)：提供了将指定索引范围内的字符串存放到数组中的方法。</p>
</li>
</ul>
<h3 id="String与字节数组转换"><a href="#String与字节数组转换" class="headerlink" title="String与字节数组转换"></a>String与字节数组转换</h3><ul>
<li><p>字节数组  —&gt;  字符串</p>
<p>String(byte[])：通过使用平台的默认字符集解码指定的 byte 数组，构 造一个新的String。</p>
<p>String(byte[]，int offset，int length) ：用指定的字节数组的一部分，即从数组起始位置offset开始取length个字节构造一个字符串对象。</p>
</li>
<li><p>字符串  —&gt;  字节数组</p>
<p>public byte[] getBytes() ：使用平台的默认字符集将此 String 编码为byte 序列，并将结果存储到一个新的 byte 数组中。</p>
<p>public byte[] getBytes(String charsetName) ：使用指定的字符集将此String 编码到 byte 序列，并将结果存储到新的 byte 数组。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;中&quot;</span>;</span><br><span class="line">System.out.println(str.getBytes(<span class="string">&quot;ISO8859-1&quot;</span>).length);<span class="comment">// -128~127</span></span><br><span class="line">System.out.println(str.getBytes(<span class="string">&quot;GBK&quot;</span>).length);</span><br><span class="line">System.out.println(str.getBytes(<span class="string">&quot;UTF-8&quot;</span>).length);</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(str.getBytes(<span class="string">&quot;ISO8859-1&quot;</span>),</span><br><span class="line">                              <span class="string">&quot;ISO8859-1&quot;</span>));<span class="comment">// 乱码，表示不了中文</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(str.getBytes(<span class="string">&quot;GBK&quot;</span>), <span class="string">&quot;GBK&quot;</span>));</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(str.getBytes(<span class="string">&quot;UTF-8&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><h3 id="StringBuffer类的特性"><a href="#StringBuffer类的特性" class="headerlink" title="StringBuffer类的特性"></a>StringBuffer类的特性</h3><ul>
<li>java.lang.StringBuffer代表可变的字符序列，JDK1.0中声明，可以对字符串进行修改，并不会产生新的对象</li>
<li>StringBuffer类使用必须构造器生成对象，有三个构造器：<ul>
<li>StringBuffer()  初始容量为16的字符串缓冲区</li>
<li>StringBuffer(int size)  自定容量的字符串缓冲区</li>
<li>StringBuffer(String str)   将内容初始化为指定字符串内容</li>
</ul>
</li>
<li>很多方法与String相同</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我喜欢学习&quot;</span>);</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;我喜欢学习&quot;</span>);</span><br><span class="line">buffer.append(<span class="string">&quot;数学&quot;</span>); </span><br></pre></td></tr></table></figure>

<img data-src="../images/Java常用类/image-20200606180019262.png" alt="image-20200606180019262" style="zoom:80%;" />

<h3 id="StringBuffer类的常用方法"><a href="#StringBuffer类的常用方法" class="headerlink" title="StringBuffer类的常用方法"></a>StringBuffer类的常用方法</h3><ul>
<li><p>StringBuffer append(XXX)  提供了很多重载的append()方法,用于进行字符串拼接</p>
</li>
<li><p>StringBuffer delete(int start,int end)    删除指定位置的内容</p>
</li>
<li><p>StringBuffer replace(int start,int end,String str)   把[start,end)位置替换为str</p>
</li>
<li><p>StringBuffer insert(int offset, XXX) 在指定位置插入XXX</p>
</li>
<li><p>StringBuffer reverse()    把当前字符序列逆转</p>
<p>注意：在使用append()和insert()时，如果原来数组的长度不够，可以自动扩容</p>
</li>
</ul>
<h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><p>StringBuilder类和StringBuffer类非常相似，类中提供的方法也差不多，这里不再赘述。</p>
<h2 id="String、StringBuffer和Stringbuilder三者的对比："><a href="#String、StringBuffer和Stringbuilder三者的对比：" class="headerlink" title="String、StringBuffer和Stringbuilder三者的对比："></a>String、StringBuffer和Stringbuilder三者的对比：</h2><p>String（JDK1.0）：不可变字符序列</p>
<p>StringBuffer（JDK1.0）：可变字符序列、线程安全、效率低</p>
<p>StringBuilder（JDK5.0）：可变字符序列、线程不安全、效率高</p>
<h1 id="时间日期相关的API"><a href="#时间日期相关的API" class="headerlink" title="时间日期相关的API"></a>时间日期相关的API</h1><h2 id="JDK8之前的"><a href="#JDK8之前的" class="headerlink" title="JDK8之前的"></a>JDK8之前的</h2><h3 id="java-lang-System类"><a href="#java-lang-System类" class="headerlink" title="java.lang.System类"></a>java.lang.System类</h3><p>System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。此方法可以用于计算时间差。</p>
<h3 id="java-util-Date类"><a href="#java-util-Date类" class="headerlink" title="java.util.Date类"></a>java.util.Date类</h3><p>表示特定的瞬间，精确到毫秒</p>
<ul>
<li><p>构造器</p>
<p>Date()   获取本地当前时间</p>
<p>Date(long date)   传入一个毫秒数，将其转换为对应的时间</p>
</li>
<li><p>常用方法</p>
<ul>
<li><p>getTime()  返回自1970 年1月1日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</p>
</li>
<li><p>toString()  把此 Date 对象转换为以下形式的 String：dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon,Tue, Wed, Thu, Fri, Sat)，zzz是时间标准。</p>
</li>
<li><p>其他很多方法都过时了</p>
</li>
</ul>
</li>
</ul>
<h3 id="java-text-SimpleDateFormate类"><a href="#java-text-SimpleDateFormate类" class="headerlink" title="java.text.SimpleDateFormate类"></a>java.text.SimpleDateFormate类</h3><ul>
<li><p>Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat 类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</p>
</li>
<li><p>SimpleDateFormate类可以对时间日期进行格式化：日期  –&gt;  文本、解析：文本  –&gt;  日期</p>
<ul>
<li><p>格式化：</p>
<p>SimpleDateFormat()   默认的格式和语言环境创建对象</p>
<p>SimpleDateFormat(String pattern)  该构造方法可以用参数pattern指定的格式创建一个对象，该对象调用String format(Date date) 方法格式化时间对象date</p>
</li>
<li><p>解析：</p>
<p>Date parse(String source)   将给定的字符串解析为一个日期</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// 产生一个Date实例</span></span><br><span class="line"><span class="comment">// 产生一个formater格式化的实例</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">formater</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>();</span><br><span class="line">System.out.println(formater.format(date));<span class="comment">// 打印输出默认的格式</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">formater2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 EEE HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(formater2.format(date));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 实例化一个指定的格式对象</span></span><br><span class="line">  <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> formater2.parse(<span class="string">&quot;2008年08月08日 星期一 08:08:08&quot;</span>);</span><br><span class="line">  <span class="comment">// 将指定的日期解析后格式化按指定的格式输出</span></span><br><span class="line">  System.out.println(date2.toString());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java-util-Calendar类"><a href="#java-util-Calendar类" class="headerlink" title="java.util.Calendar类"></a>java.util.Calendar类</h3><h4 id="Calender描述"><a href="#Calender描述" class="headerlink" title="Calender描述"></a>Calender描述</h4><p>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能</p>
<h4 id="获取Calender实例的方法"><a href="#获取Calender实例的方法" class="headerlink" title="获取Calender实例的方法"></a>获取Calender实例的方法</h4><p>1.使用Calender.getInstance()方法</p>
<p>2.调用他的子类GregorianCalender的构造器</p>
<p>一个Calendar的实例是系统时间的抽象表示，通过get(int field)方法来取得想要的时间信息。比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND。</p>
<ul>
<li>public void set(int field,int value)</li>
<li>public void add(int field,int amount)</li>
<li>public final Date getTIme()</li>
<li>public final void setTime(Date date)</li>
</ul>
<p>注意：</p>
<ol>
<li>获取月份时：一月是0二月是1，以此类推，十二月是11</li>
<li>获取星期时：周日是1，周二是2……周六是7</li>
</ol>
<h2 id="JDK8中新的"><a href="#JDK8中新的" class="headerlink" title="JDK8中新的"></a>JDK8中新的</h2><blockquote>
<p>如果我们可以跟别人说：“我们在1502643933071见面，别晚了！”那么就再简单不过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是： </p>
<p>可变性：像日期和时间这样的类应该是不可变的。 </p>
<p>偏移性：Date中的年份是从1900开始的，而月份都从0开始。 </p>
<p>格式化：格式化只对Date有用，Calendar则不行。 </p>
<p>此外，它们也不是线程安全的；不能处理闰秒等。</p>
</blockquote>
<h3 id="LocalDate、LocalTime、LocalDateTime"><a href="#LocalDate、LocalTime、LocalDateTime" class="headerlink" title="LocalDate、LocalTime、LocalDateTime"></a>LocalDate、LocalTime、LocalDateTime</h3><p>Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的API。新的 java.time 中包含了所有关于本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime） 和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简 化了日期时间和本地化的管理。</p>
<ul>
<li>LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储生日、纪念日等日期。</li>
<li>LocalTime表示一个时间，不是日期。</li>
<li>LocalDateTime是用来表示日期和时间的，是最常用的类之一。</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>now()&#x2F; now(ZoneId zone)</td>
<td>静态方法，根据当前时间创建对象&#x2F;指定时区的对象</td>
</tr>
<tr>
<td>of()</td>
<td>静态方法，根据指定的日期&#x2F;时间创建对象</td>
</tr>
<tr>
<td>getDayOfMonth&#x2F;getDayOfYear()</td>
<td>获得月份天数(1-31)&#x2F;获得年份天数(1-366)</td>
</tr>
<tr>
<td>getDayOfWeek()</td>
<td>获得星期(返回一个DayOfWeek枚举值)</td>
</tr>
<tr>
<td>getMonth()</td>
<td>获得月份，返回一个Month枚举值</td>
</tr>
<tr>
<td>getMonthValue()&#x2F;getYear()</td>
<td>获得月份(1-12)&#x2F;获得年份</td>
</tr>
<tr>
<td>getHour()&#x2F;getMinute()&#x2F;getSecond()</td>
<td>获得当前对象对应的小时、分钟、秒</td>
</tr>
<tr>
<td>withDayOfMonth()&#x2F;withDayOfYear()&#x2F;withMonth()&#x2F;withYear()</td>
<td>将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Duration:用于计算两个“时间”间隔，以秒和纳秒为基准</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime1</span> <span class="operator">=</span> LocalTime.of(<span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"><span class="comment">//between():静态方法，返回Duration对象，表示两个时间的间隔</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(localTime1, localTime);</span><br><span class="line">System.out.println(duration);</span><br><span class="line">System.out.println(duration.getSeconds());</span><br><span class="line">System.out.println(duration.getNano());</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2016</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2017</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration1</span> <span class="operator">=</span> Duration.between(localDateTime1, localDateTime);</span><br><span class="line">System.out.println(duration1.toDays());</span><br></pre></td></tr></table></figure>

<h3 id="Instant（瞬时）"><a href="#Instant（瞬时）" class="headerlink" title="Instant（瞬时）"></a>Instant（瞬时）</h3><p>instant：时间线上的一个瞬时点。这可能被用来记录应用程序中的事件时间戳。</p>
<p>在处理时间和日期的时候，我们通常会想到年，月，日，时，分，秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位。</p>
<p> java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。</p>
<h3 id="格式化与解析日期或时间"><a href="#格式化与解析日期或时间" class="headerlink" title="格式化与解析日期或时间"></a>格式化与解析日期或时间</h3><p>java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：</p>
<p>预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</p>
<p>本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)</p>
<p>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ofPattern(String pattern)</td>
<td>静态方法 ， 返回一个指定字符串格式的DateTimeFormatter</td>
</tr>
<tr>
<td>format(TemporalAccessor t)</td>
<td>格式化一个日期、时间，返回字符串。</td>
</tr>
<tr>
<td>parse(CharSequence text)</td>
<td>将制定的字符串序列解析为一个日期、时间</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="其他相关API"><a href="#其他相关API" class="headerlink" title="其他相关API"></a>其他相关API</h2><ul>
<li>ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe&#x2F;Paris </li>
<li>ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12- 03T10:15:30+01:00 Europe&#x2F;Paris。 </li>
<li>其中每个时区都对应着ID，地区ID都为“{区域}&#x2F;{城市}”的格式，例如： Asia&#x2F;Shanghai等 </li>
<li>Clock：使用时区提供对当前即时、日期和时间的访问的时钟。 </li>
<li>持续时间：Duration，用于计算两个“时间”间隔 </li>
<li>日期间隔：Period，用于计算两个“日期”间隔 </li>
<li>TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整 到“下一个工作日”等操作。       </li>
<li>TemporalAdjusters : 该类通过静态方法 (firstDayOfXxx()&#x2F;lastDayOfXxx()&#x2F;nextXxx())提供了大量的常用 TemporalAdjuster 的实现。</li>
</ul>
<h1 id="Java比较器"><a href="#Java比较器" class="headerlink" title="Java比较器"></a>Java比较器</h1><blockquote>
<p>在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间 的比较问题。 </p>
<p>Java实现对象排序的方式有两种： </p>
<ul>
<li><p>自然排序：java.lang.Comparable </p>
</li>
<li><p>定制排序：java.util.Comparator</p>
</li>
</ul>
</blockquote>
<h2 id="自然排序：java-lang-Comparable"><a href="#自然排序：java-lang-Comparable" class="headerlink" title="自然排序：java.lang.Comparable"></a>自然排序：java.lang.Comparable</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。</p>
<p>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。如果当前对象this大于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零。</p>
<p>实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或 Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有 序集合中的元素，无需指定比较器。</p>
<p>各个数据类型的比较方式：</p>
<ul>
<li>String：按照字符串中字符的Unicode值进行比较</li>
<li>Character：按照字符的中字符的Unicode值进行比较</li>
<li>数值类型对应的包装类以及BigInteger、BigDecimal：按照它们对应的数值大小进行比较</li>
<li>Boolean：true 对应的包装类实例大于 false 对应的包装类实例</li>
<li>Date、Time等：后面的日期时间比前面的日期时间大</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">  <span class="comment">//按照价格，比较商品的大小</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">      <span class="type">Goods</span> <span class="variable">other</span> <span class="operator">=</span> (Goods) o;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.price &gt; other.price) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.price &lt; other.price) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//构造器、getter、setter、toString()方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定制排序：java-util-Comparator"><a href="#定制排序：java-util-Comparator" class="headerlink" title="定制排序：java.util.Comparator"></a>定制排序：java.util.Comparator</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码， 或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用Comparator 的对象来排序，强行对多个对象进行整体排序的比较。</p>
<p>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返 回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示 o1小于o2。</p>
<p>可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort）， 从而允许在排序顺序上实现精确控制。</p>
<p>还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的 顺序，或者为那些没有自然顺序的对象 collection 提供排序。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Goods[] all = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">4</span>];</span><br><span class="line">all[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;War and Peace&quot;</span>, <span class="number">100</span>);</span><br><span class="line">all[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Childhood&quot;</span>, <span class="number">80</span>);</span><br><span class="line">all[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Scarlet and Black&quot;</span>, <span class="number">140</span>);</span><br><span class="line">all[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Notre Dame de Paris&quot;</span>, <span class="number">120</span>);</span><br><span class="line">Arrays.sort(all, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">    <span class="type">Goods</span> <span class="variable">g1</span> <span class="operator">=</span> (Goods) o1;</span><br><span class="line">    <span class="type">Goods</span> <span class="variable">g2</span> <span class="operator">=</span> (Goods) o2;</span><br><span class="line">    <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(all));</span><br></pre></td></tr></table></figure>



<h1 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h1><h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。</p>
<p>由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便 的进行调用。</p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>System类内部包含in、out和err三个成员变量，分表代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</p>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><p>native long currentTimeMillis()</p>
<p>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。 </p>
</li>
<li><p>void exit(int status)</p>
<p>该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p>
</li>
<li><p>void gc()</p>
<p>该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p>
</li>
<li><p>String getProperty(String key)</p>
<p>该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>java.version</td>
<td>java运行时环境（JRE）版本</td>
</tr>
<tr>
<td>java.home</td>
<td>java安装目录</td>
</tr>
<tr>
<td>os.name</td>
<td>操作系统名称</td>
</tr>
<tr>
<td>os.version</td>
<td>操作系统版本</td>
</tr>
<tr>
<td>user.name</td>
<td>用户的账户名</td>
</tr>
<tr>
<td>user.home</td>
<td>用户的主目录</td>
</tr>
<tr>
<td>user.dir</td>
<td>用户的当前的工作目录</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h1><p>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回 值类型一般为double型。 </p>
<p>abs 绝对值 </p>
<p>acos,asin,atan,cos,sin,tan 三角函数 </p>
<p>sqrt 平方根 </p>
<p>pow(double a,doble b) a的b次幂 </p>
<p>log 自然对数 exp e为底指数 </p>
<p>max(double a,double b)   取两者大的一个</p>
<p>min(double a,double b)    取两者小的一个</p>
<p>random() 返回0.0到1.0的随机数 </p>
<p>long round(double a)   double型数据a转换为long型（四舍五入） </p>
<p>toDegrees(double angrad) 弧度—&gt;角度 </p>
<p>toRadians(double angdeg) 角度—&gt;弧度</p>
<h1 id="BigInteger和BigDecimal"><a href="#BigInteger和BigDecimal" class="headerlink" title="BigInteger和BigDecimal"></a>BigInteger和BigDecimal</h1><h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><p>Integer类作为int的包装类，能存储的最大整型值为2 31-1，Long类也是有限的，最大为2 63-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类 都无能为力，更不用说进行运算了。</p>
<p>java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、 位操作以及一些其他操作。</p>
<p>常用方法：</p>
<ul>
<li><p>public BigInteger abs()：返回此 BigInteger 的绝对值的 BigInteger。 </p>
</li>
<li><p>BigInteger add(BigInteger val) ：返回其值为 (this + val) 的BigInteger </p>
</li>
<li><p>BigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigInteger </p>
</li>
<li><p>BigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigInteger</p>
</li>
<li><p>BigInteger divide(BigInteger val) ：返回其值为 (this &#x2F; val) 的 BigInteger。整数 相除只保留整数部分。</p>
</li>
<li><p>BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。 </p>
</li>
<li><p>BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (this &#x2F; val) 后跟(this % val) 的两个 BigInteger 的数组。 </p>
</li>
<li><p>BigInteger pow(int exponent) ：返回其值为 (thisexponent) 的 BigInteger。</p>
</li>
</ul>
<h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。</p>
<p>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p>
<p>常用方法：</p>
<ul>
<li>public BigDecimal add(BigDecimal augend) </li>
<li>public BigDecimal subtract(BigDecimal subtrahend) </li>
<li>public BigDecimal multiply(BigDecimal multiplicand) </li>
<li>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java标识符命名规范</title>
    <url>/2020/03/28/Java%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<ol>
<li>包名：多单词组合时多有字母都小写，例如：helloworld</li>
<li>类名和接口名：多单词组合所有单词第一个字母大写，例如：HelloWorld</li>
<li>变量名和方法名：多单词组合时，除了第一个单词其他单词的第一个字母大写，例如：helloWorld</li>
<li>常量名：所有字母都大写，多单词组合时下划线连接，例如：HELLO_WORLD</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode第一天</title>
    <url>/2020/08/21/LeetCode%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode第350题</p>
<p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p>示例 1：</p>
<p>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]<br>输出：[2,2]<br>示例 2:</p>
<p>输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]<br>输出：[4,9]</p>
<p>说明：</p>
<p>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。<br>我们可以不考虑输出结果的顺序。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii</a></p>
</blockquote>
<p>方法一：</p>
<p>用哈希表映射，先把较短的那个数组遍历，存入哈希表中，键是数组中元素的值，值是数组中元素出现的次数<br>再遍历另外一个数组，从哈希表中找这个数组中的值，看是否存在，存在就将其存入新造的数组中，再将哈希表中该键对应的值减一，如果值减到了0，就将这个键移除去，否则将这个键对应的值减一，在存入哈希表中。</p>
<span id="more"></span>

<p>这个方法LeetCode上的一张图看的明明白白：</p>
<p><img data-src="/images/LeetCode%E7%AC%AC%E4%B8%80%E5%A4%A9/350_fig1.gif" alt="fig1"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] intersect1(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> intersect1(nums2, nums1);</span><br><span class="line">  &#125;</span><br><span class="line">  Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> num : nums1) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    map.put(num, count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[nums2.length];</span><br><span class="line">  <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(num, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      arr[index++] = num;</span><br><span class="line">      <span class="keyword">if</span> (count != <span class="number">1</span>) &#123;</span><br><span class="line">        map.put(num, --count);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        map.remove(num);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Arrays.copyOfRange(arr, <span class="number">0</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<p>先对两个数组进行排序，然后设置两个指针来遍历这两个数组。将比较结果较小的那个数组的指针后移，如果两数相等，则将两个数组的指针都向后移，并将这个数存入新造好的数组。遍历直到有一个指针到了数组的结尾，结束遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] intersect2(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">  Arrays.sort(nums1);</span><br><span class="line">  Arrays.sort(nums2);</span><br><span class="line">  <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> nums1.length, len2 = nums2.length;</span><br><span class="line">  <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> <span class="number">0</span>, index2 = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[Math.min(len1, len2)];</span><br><span class="line">  <span class="keyword">while</span> (index1 &lt; len1 &amp;&amp; index2 &lt; len2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1[index1] &lt; nums2[index2]) &#123;</span><br><span class="line">      index1++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;</span><br><span class="line">      index2++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr[index++] = nums1[index1];</span><br><span class="line">      index1++;</span><br><span class="line">      index2++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Arrays.copyOfRange(arr, <span class="number">0</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结语</p>
<p>如果 nums2的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中。那么就无法高效地对 nums2进行排序，因此推荐使用方法一而不是方法二。在方法一中，nums2 只关系到查询操作，因此每次读取nums2中的一部分数据，并进行处理即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>linux中的权限管理</title>
    <url>/2020/05/15/Linux%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="文件基本权限"><a href="#文件基本权限" class="headerlink" title="文件基本权限"></a>文件基本权限</h1><p>首先看一下Linux中的文件权限，可以用ll命令或者带-l的ls命令查看</p>
<img data-src="/images/Linux中的权限管理/image-20200515135526284.png" alt="image-20200515135526284" style="zoom:80%;" />

<p>第一个字符代表文件的类型，然后是权限、链接数、所属用户、所属用户组、文件大小、最后修改时间、文件名</p>
<p>Linux中的文件权限一共有7种：</p>
<span id="more"></span>

<p>前面三种为常见的文件类型，后面四种是特殊文件类型</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>文件类型</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>普通文件（如上图第三列）</td>
</tr>
<tr>
<td>d</td>
<td>文件目录（也就是文件夹）</td>
</tr>
<tr>
<td>l</td>
<td>软连接（和Windows中的快捷方式相似）</td>
</tr>
<tr>
<td>b</td>
<td>设备块文件（例如硬盘和光驱）</td>
</tr>
<tr>
<td>p</td>
<td>管道文件</td>
</tr>
<tr>
<td>c</td>
<td>字符设备文件</td>
</tr>
<tr>
<td>s</td>
<td>套接口文件&#x2F;数据接口文件</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>权限</th>
<th>对应数字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>4</td>
<td>可读</td>
</tr>
<tr>
<td>w</td>
<td>2</td>
<td>可写</td>
</tr>
<tr>
<td>x</td>
<td>1</td>
<td>可执行</td>
</tr>
</tbody></table>
<p>在看上面图中的第一个文件权限</p>
<p><strong>rwx——</strong></p>
<p>每三个字符为一组，-代表没有相关的权限</p>
<p>第一组是表示文件所有者（u表示）的权限，这里是root，root对该文件拥有所有的权限</p>
<p>第二组是表示所属组（g表示）的权限，这里也是root，这里所属组对该文件没有任何权限</p>
<p>第三组是表示其他人（o表示）的权限，这里也是没有任何权限的</p>
<p>新创建的文件默认权限：</p>
<img data-src="/images/Linux中的权限管理/image-20200515141738439.png" alt="image-20200515141738439" style="zoom:80%;" />

<h1 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h1><p>Linux中修改权限用的是chmod命令</p>
<p>具体用法见下图：</p>
<h2 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h2><p>给所属组加上写的权限</p>
<img data-src="/images/Linux中的权限管理/image-20200515141537125.png" alt="image-20200515141537125" style="zoom:80%;" />

<p>也可以同时给所属用户和用户组还有其他用户加权限</p>
<img data-src="/images/Linux中的权限管理/image-20200515142243765.png" alt="image-20200515142243765" style="zoom:80%;" />

<p>如果是要给全部的三个组同时加权限可以直接用a代表ugo，是就是all</p>
<p><img data-src="/images/Linux%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20200515142524794.png" alt="image-20200515142524794"></p>
<p>减权限，这里同理也可以用a代替ugo</p>
<img data-src="/images/Linux中的权限管理/image-20200515142333848.png" alt="image-20200515142333848" style="zoom:80%;" />

<h2 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h2><p>直接用代号赋予相应的权限，当要更改多个组的权限时，中间用逗号隔开</p>
<img data-src="/images/Linux中的权限管理/image-20200515142801089.png" alt="image-20200515142801089" style="zoom:80%;" />

<p><img data-src="/images/Linux%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20200515143020204.png" alt="image-20200515143020204"></p>
<p><img data-src="/images/Linux%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20200515143020204.png" alt="image-20200515143020204"></p>
<h2 id="方式三："><a href="#方式三：" class="headerlink" title="方式三："></a>方式三：</h2><p>用的比较多的其实是这一种</p>
<img data-src="/images/Linux中的权限管理/image-20200515143154536.png" alt="image-20200515143154536" style="zoom:80%;" />

<p>这里的每个数字就是刚刚对应权限代表的二进制转换过来的，这里544转换为方式二就是：u&#x3D;rx,g&#x3D;r,o&#x3D;r，x的权重为1，w的权重为2，r的权重为4，把每个组的所有权限的权重加起来就是方式三的数字了。</p>
<p>这里再顺便介绍一个和权限相关的命令：</p>
<p>chown: 用来改变文件或目录的所有者</p>
<p>格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> user:user fileName</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的进程管理</title>
    <url>/2020/05/22/Linux%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><p>pa a    显示终端机下所有进程</p>
<p>ps -A   查看所有进程（ps -e和-A是一样的效果，-e更常用一点）（这两个看到的比上面那个多些）</p>
<p>ps u 以用户为主的格式来显示程序状况</p>
<p>ps x 显示所有程序，不以终端机来区分</p>
<p>lsof -i:端口号   根据指定的端口查询进程</p>
<p>常用的组合命令：</p>
<p>ps aux,然后再通过管道使用grep命令过滤查找特定的进程,然后再对特定的进程进行操作。</p>
<p><strong>ps -ef|grep java|grep -v grep</strong> 显示出所有的java进程，去处掉当前的grep进程。</p>
<h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><p>kill -9 进程PID  	根据进程号结束进程</p>
<p>killall -9 进程名 	根据进程名结束进程</p>
<blockquote>
<p>参考资料：<a href="https://blog.csdn.net/wojiaopanpan/article/details/7286430">https://blog.csdn.net/wojiaopanpan/article/details/7286430</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown基本语法</title>
    <url>/2020/02/27/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一级标题</span></span><br><span class="line"><span class="comment">## 二级标题</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="comment">###### 六级标题</span></span><br></pre></td></tr></table></figure>



<p><strong>注意#和标题之间要有空格才会有效果</strong>   这简直是初学者的一大坑  </p>
<span id="more"></span>

<h4 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*斜体1*	 _斜体2_</span><br><span class="line">**加粗1**  __加粗2__</span><br><span class="line">~~删除线~~</span><br><span class="line">H~2~O	（hexo要用&lt;sub&gt;&lt;/sub&gt;标签，如H&lt;sub&gt;2&lt;/sub&gt;O）</span><br><span class="line">2^10^   （hexo要用&lt;sup&gt;&lt;/sup&gt;标签，如2&lt;sup&gt;10&lt;/sup&gt;）</span><br><span class="line">&gt; 引用</span><br></pre></td></tr></table></figure>

<p><strong>效果显示</strong></p>
<p><em>斜体1</em>	 <em>斜体2</em><br><strong>加粗1</strong>     <strong>加粗2</strong><br><del>删除线</del></p>
<p>H<sub>2</sub>O<br>2<sup>10</sup></p>
<blockquote>
<p>引用</p>
</blockquote>
<p><strong>后面两个要在偏好里面设置，Markdown扩展语法那几个选项打上勾</strong></p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- 项目1</span><br><span class="line">  </span><br><span class="line">  - 项目2</span><br><span class="line">  </span><br><span class="line">    - 项目3</span><br></pre></td></tr></table></figure>

<ul>
<li><p>项目1</p>
<ul>
<li><p>项目2</p>
<ul>
<li>项目3</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 项目</span><br><span class="line">2. 项目</span><br><span class="line">3. 项目</span><br></pre></td></tr></table></figure>

<ol>
<li>项目</li>
<li>项目</li>
<li>项目</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [ ] 计划任务</span><br><span class="line">- [x] 完成任务 </span><br></pre></td></tr></table></figure>

<ul>
<li><input disabled="" type="checkbox"> 计划任务</li>
<li><input checked="" disabled="" type="checkbox"> 完成任务</li>
</ul>
<h4 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```c</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">![](图片链接)</span><br></pre></td></tr></table></figure>

<p>今天先写到这，睡觉去了🌛 🌜</p>
<hr>
<h4 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[文字描述](链接)</span><br></pre></td></tr></table></figure>

<p><a href="https://www.baidu.com/">百度</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL8安装与配置</title>
    <url>/2020/11/23/MySQL8%E5%85%81%E8%AE%B8%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h2 id="Ubuntu安装MySQL8"><a href="#Ubuntu安装MySQL8" class="headerlink" title="Ubuntu安装MySQL8"></a>Ubuntu安装MySQL8</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install mysql-server</span><br></pre></td></tr></table></figure>

<h2 id="Debian-安装MySQL8"><a href="#Debian-安装MySQL8" class="headerlink" title="Debian 安装MySQL8"></a>Debian 安装MySQL8</h2><p>因为Debian的源中没有MySQL，所以我们需要手动添加</p>
<ol>
<li><p>先去MySQL<a href="https://dev.mysql.com/downloads/mysql/">官网</a></p>
<p>选择版本和系统之后，会出来下面这张图片，点击这张图片，进入到第二步</p>
<p><img data-src="/../images/MySQL8%E5%85%81%E8%AE%B8%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/image-20230826144155692.png" alt="image-20230826144155692"></p>
</li>
<li><p>下载DEB package</p>
<p>进入第二个页面后，点击下载按钮，之后会跳转到另外一个页面</p>
<p><img data-src="/../images/MySQL8%E5%85%81%E8%AE%B8%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/image-20230826144328978.png" alt="image-20230826144328978"></p>
<p>不需要登录，右键点击最下面的直接下载的链接，复制链接</p>
<p><img data-src="/../images/MySQL8%E5%85%81%E8%AE%B8%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/image-20230826144446024.png" alt="image-20230826144446024"></p>
<p>然后到Debian中用wget下载：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql-apt-config_0.8.26-1_all.deb</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg --install mysql-apt-xxx.deb</span><br></pre></td></tr></table></figure>

<p>然后<code>apt update</code>一下，<code>apt install mysql-server</code>就可以找到MySQL的包了。</p>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>登录MySQL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mysql</span><br></pre></td></tr></table></figure>

<p>可以直接登录，只要输入账户密码，登录之后再改密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">use mysql;</span><br><span class="line"></span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;你的新密码&#x27;;</span><br></pre></td></tr></table></figure>

<p>更新域属性，’%’表示任何方式访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update user set host=&#x27;%&#x27; where user =&#x27;root&#x27;;</span><br></pre></td></tr></table></figure>

<p>执行以上语句之后再执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>再执行授权语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27;WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>

<p>Debian系统到这里一般就可以远程连接了，Ubuntu可能还需要修改配置文件，注释掉绑定地址。</p>
<p><strong>!!! 若还是有问题，则将<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>文件中的<code>bind-address</code>注释掉。</strong></p>
]]></content>
      <categories>
        <category>软件</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置反向代理</title>
    <url>/2021/09/19/Nginx%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="前后端分离项目的部署配置"><a href="#前后端分离项目的部署配置" class="headerlink" title="前后端分离项目的部署配置"></a>前后端分离项目的部署配置</h1><p>Nginx就非常离谱，也不知道为什么，前端静态资源也需要单独配置，而且这配置方式还非常的离谱，贴一下配置文件</p>
<p>配置文件路径<code>/etc/nginx/sites-enabled</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">server <span class="punctuation">&#123;</span></span><br><span class="line">    listen      <span class="number">80</span>;   			#监听<span class="number">80</span>端口</span><br><span class="line">    server_name	<span class="number">10.100</span><span class="number">.128</span><span class="number">.8</span>;   #监听访问的host</span><br><span class="line"></span><br><span class="line">    location /EleLabSys/ <span class="punctuation">&#123;</span></span><br><span class="line">		root   /var/www/html/;</span><br><span class="line">		try_files $uri $uri/ EleLabSys/;	#此处非常离谱，是经过不断尝试出来的，子文件夹必须要写在这个地方才行</span><br><span class="line">		index  index.html index.htm;</span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line">	# 后端api代理还比较正常</span><br><span class="line">	location /prod-api/ <span class="punctuation">&#123;</span></span><br><span class="line">		proxy_set_header Host $http_host;</span><br><span class="line">		proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">		proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">		proxy_pass http<span class="punctuation">:</span><span class="comment">//localhost:8080/;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>具体是什么原因导致的暂且不深究。。。</p>
<p>等有空再研究</p>
<hr>
<p>更新来了。。。</p>
<p>经过再次的尝试，发现是需要把根路径放到最后面，这样才能正常地访问静态资源，不需要手动配置，并且代理也有效果</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      80;   <span class="comment">#监听80端口</span></span><br><span class="line">    server_name	10.100.128.8;   <span class="comment">#监听访问的host</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实验室系统后端</span></span><br><span class="line">	location /prod-api/ &#123;</span><br><span class="line">		proxy_set_header Host <span class="variable">$http_host</span>;</span><br><span class="line">		proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">		proxy_set_header REMOTE-HOST <span class="variable">$remote_addr</span>;</span><br><span class="line">		proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">		proxy_pass http://localhost:8080/;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment"># 实验室代码仓库</span></span><br><span class="line">    location /gitea/ &#123;</span><br><span class="line">		proxy_set_header Host <span class="variable">$http_host</span>;</span><br><span class="line">		proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">		proxy_set_header REMOTE-HOST <span class="variable">$remote_addr</span>;</span><br><span class="line">		proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">		proxy_pass http://localhost:3000/;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment"># 实验室系统云盘</span></span><br><span class="line">	location /cloudDisk/ &#123;</span><br><span class="line">		<span class="comment"># proxy_set_header Host $http_host;</span></span><br><span class="line">		<span class="comment"># proxy_set_header X-Real-IP $remote_addr;</span></span><br><span class="line">		<span class="comment"># proxy_set_header REMOTE-HOST $remote_addr;</span></span><br><span class="line">		proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">		proxy_pass http://localhost:9999/;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 需要放到最后面，匹配优先级最低</span></span><br><span class="line">	location / &#123;</span><br><span class="line">		root   /var/www/html/;</span><br><span class="line">		try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /;</span><br><span class="line">		index  index.html index.htm;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中常用的函数</title>
    <url>/2020/04/26/MySQL%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><ol>
<li><p>合并字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">concat();</span><br><span class="line">concat(&quot;Hello&quot;,&quot; World&quot;);#Hello world，当传入的参数又一个为null时结果为null</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取字符串的长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">length(str);#空格也算一个字符，计算的是字节的长度，一个汉字占两个字节</span><br></pre></td></tr></table></figure>

<span id="more"></span>
</li>
<li><p>字母大小写转换函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upper();#将传入的字符全部转换为大写</span><br><span class="line">lower();#将传入的字符全部转换为小写</span><br></pre></td></tr></table></figure>
</li>
<li><p>在字符串中查找字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locate(str1,str);# 返回str中字符串str1的开始位置</span><br><span class="line">position(str1 IN str);# 返回str中字符串str1的开始位置</span><br><span class="line">instr(str,str1); # 返回str中字符串str1的开始位置</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>截取字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">left(str,num);# 从左边截取,字符串是str,长度是num</span><br><span class="line">right(str,num);# 从右边截取,字符串是str,长度是num</span><br><span class="line">substring(str,num,len);# 字符串是str,从num位置开始,长度是len,包含num位置</span><br><span class="line">mid(str,num,len);# 字符串是str,从num位置开始,长度是len,包含num位置</span><br></pre></td></tr></table></figure>
</li>
<li><p>去掉字符串首位空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ltrim(str);# 去除字符串开始的空格</span><br><span class="line">rtrim(str);# 去除字符串后面的空格</span><br><span class="line">trim(str);# 去除字符串首位的空格</span><br></pre></td></tr></table></figure>
</li>
<li><p>替换字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">replace(str1,str2,str3);# str1是原字符串，str2是需要替换的字符串，str3是替换str2的字符串</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><ol>
<li><p>获取随机数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RAND();# 返回的数完全随机</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取整数的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CEIL(num);# 上取整</span><br><span class="line"></span><br><span class="line">FLOOR(num);# 下取整</span><br></pre></td></tr></table></figure>
</li>
<li><p>截取数值函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TRUNCATE(x,y);#x表示要截取的数值,y表示小数点后几位,也就是保留几位小数,是直接舍去,而不是四舍五入.</span><br></pre></td></tr></table></figure>
</li>
<li><p>四舍五入函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROUND(x);</span><br><span class="line">ROUND(x,y);# 返回数值x保留到小数点后y位</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数:"></a>日期函数:</h2><ol>
<li><p>获取当前日期和时间函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">now();# 当前日期和时间</span><br><span class="line">locatime();# 当前日期和时间</span><br><span class="line">current_timestamp();# 当前日期和时间</span><br><span class="line">SYSDTAE();# 当前日期和时间</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前日期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curdate();# 当前日期</span><br><span class="line">current_date();# 当前日期</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curtime();</span><br><span class="line">current_time();</span><br></pre></td></tr></table></figure>
</li>
<li><p>各种方式显示日期和时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unix_timestamp(日期类型的字符串);# 将日期类型的字符串转化为整形(秒数),UNIX格式</span><br><span class="line">from_unixtime(&quot;整形&quot;);# 将整形字符串转化为日期,普通格式</span><br><span class="line">UTC_DATE();# utc日期,只有日期</span><br><span class="line">UTC_TIME();# utc时间 ,只有时间</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取日期和时间各部分值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT NOW() 当前日期和时间,</span><br><span class="line">YEAR(NOW()) 年,</span><br><span class="line">QUARTER(NOW()) 季度,</span><br><span class="line">MONTH(NOW()) 月,</span><br><span class="line">WEEK(NOW())星期,</span><br><span class="line">DAYOFMONTH(NOW()) 天,</span><br><span class="line">HOUR(NOW()) 小时,</span><br><span class="line">MINUTE(NOW()) 分,</span><br><span class="line">SECOND(NOW()) 秒;</span><br></pre></td></tr></table></figure>
</li>
<li><p>月(参数都是日期类型的字符串)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MONTH(date);</span><br><span class="line">MONTHNAME(date);</span><br></pre></td></tr></table></figure>
</li>
<li><p>星期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">week(date);# 年中第几个星期</span><br><span class="line">weekofyear(date);# 年中第几个星期</span><br><span class="line">dayname(date);# 星期,英文显示</span><br><span class="line">dayofweek(date);# 星期(不理解,用下面的)</span><br><span class="line">weekday(date);# 星期,数字表示</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>天</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dayofyear(date);# 年中的第几天</span><br><span class="line">dayofmonth(date);# 月中的第几天</span><br></pre></td></tr></table></figure>
</li>
<li><p>EXTRACT函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTRACT(YEAR from NOW()); # 年</span><br><span class="line">EXTRACT(month from NOW()); # 月</span><br><span class="line">EXTRACT(day from NOW()); # 日</span><br><span class="line">EXTRACT(hour from NOW()); # 时</span><br><span class="line">EXTRACT(minutefrom NOW()); # 分</span><br><span class="line">EXTRACT(second from NOW()); # 秒</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算日期和时间的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT NOW() 当前日期和时间,</span><br><span class="line">TO_DAYS(NOW()) 相隔天数, # 距离0000年1月1日</span><br><span class="line">FROM_DAYS(TO_DAYS(NOW())) 一段时间后日期和时间,</span><br><span class="line">DATEDIFF(NOW(),&#x27;2000-12-01&#x27;) 相隔天数;</span><br><span class="line">TIMEDIFF(&#x27;2021-12-15 09:36:46&#x27;,&#x27;2021-12-15 09:38:25&#x27;) 相隔时间;</span><br></pre></td></tr></table></figure>
</li>
<li><p>与指定日期和时间操作:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADDDATE(date,n); # 计算date加上n天后的日期</span><br><span class="line">SUBDATE(date,n); # 计算date减去n天后的日期</span><br><span class="line">ADDDATE(d,INTERVAL expr type);# type的类型查看#http://www.w3school.com.cn/sql/func_date_add.asp</span><br><span class="line">SUBDATE(d,INTERVAL expr type);</span><br><span class="line"># 例子</span><br><span class="line">select adddate(now(),interval &#x27;2,3&#x27; year_month ) &#x27;2年3个月后的日期&#x27;;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PVE直通硬盘到TrueNAS</title>
    <url>/2022/07/16/PVE%20%E7%9B%B4%E9%80%9A%E7%A1%AC%E7%9B%98%E5%88%B0TrueNAS/</url>
    <content><![CDATA[<h1 id="1-查询所有的硬盘识别码"><a href="#1-查询所有的硬盘识别码" class="headerlink" title="1.查询所有的硬盘识别码"></a>1.查询所有的硬盘识别码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -la /dev/disk/by-id/|grep -v dm|grep -v lvm|grep -v part</span><br></pre></td></tr></table></figure>

<h1 id="2-将硬盘直通到TrueNAS"><a href="#2-将硬盘直通到TrueNAS" class="headerlink" title="2.将硬盘直通到TrueNAS"></a>2.将硬盘直通到TrueNAS</h1><p>vmid是TrueNAS虚拟机的编号，x是编号，若此虚拟机没有sata设备，则从从0开始，xxxx为硬盘识别码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qm set &lt;vmid&gt; --sata[x] /dev/disk/by-id/[xxxxxxx]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PVE</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>PVE</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis中的穿透、雪崩、击穿问题</title>
    <url>/2024/02/18/Redis%E4%B8%AD%E7%9A%84%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>Redis中热点数据失效的瞬间，所有的请求都打到MySQL数据库上面，击穿了Redis的缓存，导致性能下降</p>
<p><img data-src="/../images/Redis%E4%B8%AD%E7%9A%84%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/image-20240218210704848.png" alt="image-20240218210704848"></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>设置热点数据永不过期</li>
<li>设置加锁队列（线程锁或分布式锁），先让一个线程去数据库查到数据，缓存到Redis中，然后其他线程再来Redis中取数据</li>
</ol>
<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><h2 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h2><p>Redis中缓存的很多数据，在同一时刻失效，或Redis缓存服务器宕机，而导致请求全部打到MySQL上面，给MySQL造成巨大压力</p>
<p><img data-src="/../images/Redis%E4%B8%AD%E7%9A%84%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/image-20240218204959843.png" alt="image-20240218204959843"></p>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>将缓存数据的过期时间设为随机，避免其都在同一时刻失效</li>
<li>Redis的高可用，集群+哨兵</li>
</ol>
<span id="more"></span>

<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><h2 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h2><p>查询的数据在数据库和缓存中都不存在，恶意请求数据，导致每次请求都要去查询数据，导致数据库压力过大或宕机</p>
<p><img data-src="/../images/Redis%E4%B8%AD%E7%9A%84%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/image-20240218211757292.png" alt="image-20240218211757292"></p>
<h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>对请求参数进行校验（无法完全避免）</li>
<li>将数据库中不存在的数据也缓存到Redis中，避免每次收到数据库中进行查询</li>
<li>布隆过滤器</li>
</ol>
<p>参考：</p>
<p><a href="https://www.bilibili.com/video/BV1Fd4y1T7pD/?share_source=copy_web&vd_source=7db57f5c954df7540610cd1c0fda8f20">1.【趣话Redis第一弹】我是Redis，MySQL大哥被我坑惨了！</a></p>
<p><a href="https://www.bilibili.com/video/BV1Qs4y1K7mY/?share_source=copy_web&vd_source=7db57f5c954df7540610cd1c0fda8f20">2.【阿里二面：说说你在项目中是怎么解决redis穿透、雪崩、击穿问题的？一口气说了17分钟。。】 </a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis底层数据结构学习</title>
    <url>/2024/07/16/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h1><p>Redis是一种键值对形式的NoSQL数据库，它使用<strong>哈希表</strong>来保存所有的键值，哈希表可以快速的以<code>O(1)</code>的时间复杂度帮我们找到我们需要的键值对。<br>在Redis中，键是<code>String</code>类型的，而对应的值则可以是任何的Redis中的数据类型，比如<code>String</code>、<code>list</code>、<code>set</code>、<code>zset</code>、<code>hash</code>等。哈希表中并不是直接存放值本身，而是通过<code>void * key</code>和<code>void * value</code>指针，分别指向实际的键对象和值对象，所以无论值是什么类型的，都可以通过指针来找到。<br>下面是一张Redis保存键值所涉及的数据结构：</p>
<p><img data-src="/../images/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/IMG-20240717085942125.png"></p>
<ul>
<li>redisDb 结构，表示 Redis 数据库的结构，结构体⾥存放了指向了 dict 结构的指针； </li>
<li>dict 结构，结构体⾥存放了 2 个哈希表，正常情况下都是⽤哈希表1，哈希表2只有在 rehash 的时候才⽤； </li>
<li>ditctht 结构，表示哈希表的结构，结构⾥存放了哈希表数组，数组中的每个元素都是指向⼀个哈希表 节点结构（dictEntry）的指针； </li>
<li>dictEntry 结构，表示哈希表节点的结构，结构⾥存放了 <code>void * key</code> 和 <code>void * value</code> 指针， <code>* key</code> 指向 的是 String 对象，⽽ <code>* value</code> 则可以指向 String 对象，也可以指向集合类型的对象，⽐如 List 对 象、Hash 对象、Set 对象和 Zset 对象。<br><code>void * key</code>和<code>void * value</code>指针指向的是<strong>Redis对象</strong>，Redis中的每个对象都是由redisObject结构来表示的，具体结构如下图：<br><img data-src="/../images/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/IMG-20240717091256506.png"></li>
</ul>
<p>对象结构⾥包含的成员变量包括： </p>
<ul>
<li>type，标识该对象是什么类型的对象（String 对象、 List 对象、Hash 对象、Set 对象和 Zset 对 象）； </li>
<li>encoding，标识该对象使⽤了哪种底层的数据结构； </li>
<li>ptr，指向底层数据结构的指针。</li>
</ul>
<h1 id="数据结构实现"><a href="#数据结构实现" class="headerlink" title="数据结构实现"></a>数据结构实现</h1><h2 id="SDS-Simple-Dynamic-String"><a href="#SDS-Simple-Dynamic-String" class="headerlink" title="SDS(Simple Dynamic String)"></a>SDS(Simple Dynamic String)</h2><p><img data-src="/../images/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/IMG-20240717091159316.png"></p>
<p>结构中的每个成员变量分别介绍下： </p>
<ul>
<li>len，记录了字符串⻓度。这样获取字符串⻓度的时候，只需要返回这个成员变量值就⾏，时间复杂度 只需要 <code>O(1)</code>。 </li>
<li>alloc，分配给字符数组的空间⻓度。这样在修改字符串的时候，可以通过 &#x3D;&#x3D;<code>alloc - len</code>&#x3D;&#x3D; 计算出剩余的 空间⼤⼩，可以⽤来判断空间是否满⾜修改需求，如果不满⾜的话，就会⾃动将 SDS 的空间扩展⾄ 执⾏修改所需的⼤⼩，然后才执⾏实际的修改操作，所以使⽤ SDS 既不需要⼿动修改 SDS 的空间⼤ ⼩，也不会出现前⾯所说的缓冲区溢出的问题。 </li>
<li>flags，⽤来表示不同类型的 SDS。⼀共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、 sdshdr32 和 sdshdr64，分别支持不同长度的变量位数。 </li>
<li>buf[]，字符数组，⽤来保存实际数据。不仅可以保存字符串，也可以保存⼆进制数据。</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot AOP</title>
    <url>/2024/02/08/SpringBoot%20AOP/</url>
    <content><![CDATA[<h1 id="AOP是什么"><a href="#AOP是什么" class="headerlink" title="AOP是什么"></a>AOP是什么</h1><p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。</p>
<p>利用AOP可对业务逻辑进行增强，在不改变原有逻辑的基础上，在其前后进行处理。降低了耦合性，减少了大量冗余的操作。特别适合用于大量方法都需要进行相同处理的操作。</p>
<h1 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h1><p><img data-src="/../images/SpringBoot-AOP/32938e240b174d589359defc6a4828cf.png" alt="AOP"></p>
<span id="more"></span>

<ul>
<li>切入点（Pointcut）：被增强的方法。</li>
<li>通知、增强方法（Advice）：对目标方法的增强，有五种增强类型。<ul>
<li>环绕通知（@Around）：内部执行方法，在方法执行的前后操作。</li>
<li>前置通知（@Before）：再发执行前执行。</li>
<li>后置通知（@After）：方法执行后执行。</li>
<li>返回通知（@AfterReturning）：方法返回之后执行。</li>
<li>异常通知（@AfterThrowing）：方法抛出异常后执行。</li>
</ul>
</li>
<li>切面（Aspect）：切入点+通知（增强方法），一般是指被<code>@Aspect</code>修饰的类，代表着某一具体功能的<code>AOP</code>逻辑。</li>
</ul>
<p>切入点的匹配方法：</p>
<table>
<thead>
<tr>
<th>表达式类型</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>execution()</td>
<td>匹配方法，最全的一个</td>
</tr>
<tr>
<td>args()</td>
<td>匹配入参类型</td>
</tr>
<tr>
<td>@args()</td>
<td>匹配入参类型上的注解</td>
</tr>
<tr>
<td>@annotation()</td>
<td>匹配方法上的注解</td>
</tr>
<tr>
<td>within()</td>
<td>匹配类路径</td>
</tr>
<tr>
<td>@within()</td>
<td>匹配类上的注解</td>
</tr>
<tr>
<td>this()</td>
<td>匹配类路径，实际上AOP代理的类</td>
</tr>
<tr>
<td>target()</td>
<td>匹配类路径，目标类</td>
</tr>
<tr>
<td>@target()</td>
<td>匹配类上的注解</td>
</tr>
</tbody></table>
<h1 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h1><p>AOP的代理使用JDK动态代理和CGLIB代理来实现，默认如果目标对象是接口则使用JDK动态代理，否则使用CGLIB来生成动态代理类。</p>
<p>动态代理：程序在执行过程中使用JDK的反射机制，创建代理对象，并动态的指定要代理目标类。动态代理涉及的三个类：</p>
<ul>
<li><p>InvocationHandler接口：处理器，负责调用目标方法（被代理类中的方法），并事项增强功能；通过代理类对象执行目标接口中的方法，会把方法的调用分配给调用处理器的事项类，执行实现类中的invoke()方法，我们需要把在该invoke()方法中实现调用目标类的目标方法；</p>
</li>
<li><p>Proxy 类：通过 JDK 的 java.lang.reflect.Proxy 类实现动态代理 ，使用其静态方法 newProxyInstance()，依据目标对象（被代理类的对象）、业务接口及调用处理器三者，自动生成一个动态代理对象。</p>
</li>
<li><p>Method 类：Method 是实例化的对象，有一个方法叫 invoke()，该方法在反射中就是用来执行反射对象的方法的。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP三次握手与四次挥手</title>
    <url>/2022/08/11/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h1 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h1><h2 id="TCP头格式"><a href="#TCP头格式" class="headerlink" title="TCP头格式"></a>TCP头格式</h2><img data-src="/images/TCP三次握手与四次挥手/tcp-head.png" alt="TCP 头格式"  />

<p><strong>序列号</strong>：在建立连接时，由计算机生成的随机数作为初始值，通过SYN包传给接收端主机，每发送一次数据，就累加一次该「数据字节数」的大小，<strong>来解决网络包乱序的问题</strong>。</p>
<p><strong>确认应答号</strong>：指下次期望收到的数据序列号，发送端收到这个确认应答后可以认为在这个序号之前的数据都已经被正常接收，<strong>用来解决丢包问题</strong>。</p>
<p><strong>控制位</strong>：</p>
<ul>
<li><code>ACK</code>：为1时，「确认应答」的字段变为有效，TCP规定除了最初建立连接时的<code>SYN </code>包之外该位必须为1。</li>
<li><code>RST</code>：为1时，表示TCP连接中出现异常，必须强制断开连接。</li>
<li><code>SYN</code>：为1时，表示希望建立连接，并在其「序列号」的字段就行序列号初始值的设定。</li>
<li><code>FIN </code>：为1时，表示之后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间相互交换<code>FIN</code>位位1的TCP段。</li>
</ul>
<span id="more"></span>

<p>TCP层的存在，是因为IP层是「不可靠」的，他不能保证网络包的交付，网络包的交付，也不能保证网络包中数据的完整性性。</p>
<img data-src="/images/TCP三次握手与四次挥手/tcp-ip model.png" alt="OSI 参考模型与 TCP/IP 的关系"  />

<p>为了保证网络数据包的可靠性，上层就需要<code>TCP</code>协议。</p>
<h2 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h2><p>TCP是面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<ul>
<li>面向连接：一定是「一对一」才能连接，不像UDP协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的。</li>
<li>可靠的：无论网络链路中出现了怎样的变化，TCP都可以保证一个报文一定可以到达接收端。</li>
<li>字节流：用户消息通过TCP传输协议时，消息可能会被操作系统分组成多个TCP报文，如果接收方的程序不知道「消息的边界」，是无法读出一个有效的用户消息。并且TCP报文是有序的，当前一个TCP报文没有收到的时候，即使它先收到后面的TCP报文，那么也不能扔给应用层去处理，而碰到重复的TCP报文会自动丢弃。</li>
</ul>
<h2 id="什么是TCP连接"><a href="#什么是TCP连接" class="headerlink" title="什么是TCP连接"></a>什么是TCP连接</h2><p>简单来说，用来保证可靠性和流量控制维护的某些信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</p>
<p>所以建立一个TCP连接需要客户端与服务器达成上述三个信息的共识。</p>
<ul>
<li>Socket：由IP地址和端口号组成</li>
<li>序列号：用来解决乱序问题</li>
<li>窗口大小：用来做流量控制</li>
</ul>
<blockquote>
<p>如何唯一确定一个 TCP 连接呢？</p>
</blockquote>
<p>通过TCP的四元组可以唯一的确定一个连接，四元组包括：源地址、源端口、目标地址和目标端口。</p>
<p>源地址和目标地址的字段（32位）是在IP头中，作用是通过IP协议发送报文给对方的主机。</p>
<p>源端口和目标端口的字段是在TCP头中，作用是告诉TCP协议应该把报文发送给哪一个进程。</p>
<h2 id="UDP和TCP的区别"><a href="#UDP和TCP的区别" class="headerlink" title="UDP和TCP的区别"></a>UDP和TCP的区别</h2><p>UDP不提供复杂的控制机制，利用IP提供面向「无连接」的通信服务。</p>
<p>UDP协议非常的简单，头部只有8个字节（64位），UDP的头部格式如下：</p>
<img data-src="/images/TCP三次握手与四次挥手/udp-head.png" alt="UDP 头部格式" />

<ul>
<li>目标和源端口：主要告诉UDP协议应该把报文发送给那个进程。</li>
<li>包长度：该字段保存了UDP头部的长度和数据的长度之和。</li>
<li>校验和：校验和是为了提供可靠的UDP首部和数据而设计的，防止收到在网络传输受损的UDP包。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li><p>连接</p>
<ul>
<li>TCP是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP是不需要连接的，可以直接开始传输数据。</li>
</ul>
</li>
<li><p>服务对象</p>
<ul>
<li>TCP是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP支持一对一、一对多的交互通信。</li>
</ul>
</li>
<li><p>可靠性</p>
<ul>
<li>TCP是可靠交付数据的，数据库无差错、不丢失、不重复、按序到达。</li>
<li>UDP是尽最大努力交付，不保证数据的可靠的交付。</li>
</ul>
</li>
<li><p>拥塞控制、流量控制</p>
<ul>
<li>TCP有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP则不同，即使网络非常拥堵了，也不会影响UDP的发送速率。</li>
</ul>
</li>
<li><p>首部开销</p>
<ul>
<li><p>TCP首部长度较长，会有一定的开销，首部在没有使用选项字段时是<code>20</code>个字节，如果使用了选择字段则会变得更长。-</p>
</li>
<li><p>UDP首部只有8个字节，并且是固定不变的，开销很小。</p>
</li>
</ul>
</li>
<li><p>传输方式</p>
<ul>
<li><p>TCP是流式传输，没有边界，但保证顺序和可靠性。</p>
</li>
<li><p>UDP是一个包一个包的发送，是有边界的，但可能会存在丢包和乱序。</p>
</li>
</ul>
</li>
<li><p>分片不同</p>
<ul>
<li>TCP的数据大小如果大于MSS的大小，会在传输层进行分片，目标主机收到之后，也同样会在传输层组装TCP数据包，如果中途叠了一个分片，只需要传输丢失的这一个分片就行。</li>
<li>UDP的数据大小如果大于MTU的大小，就会在IP层进行分片，目标主机接收到之后，在IP层组装完数据，接着再传给传输层。</li>
</ul>
</li>
</ol>
<h3 id="TCP和UDP的应用场景"><a href="#TCP和UDP的应用场景" class="headerlink" title="TCP和UDP的应用场景"></a>TCP和UDP的应用场景</h3><p>由于TCP是面向连接的，可以保证，数据额交付的可靠性，因此常用于：</p>
<ul>
<li><code>FTP</code>文件传输</li>
<li>HTTP&#x2F;HTTPS</li>
</ul>
<p>而UDP面向无连接，他可以随时发送数据，再加上UDP本身的处理既简单又高效，因此常用于：</p>
<ul>
<li>包总量较少的通信，如<code>DNS</code>、<code>SMTP</code>等</li>
<li>视频、音频等多媒体通信</li>
<li>广播通信</li>
</ul>
<blockquote>
<p>为什么UDP头部没有首部长度字段，而TCP头部有首部长度字段？</p>
</blockquote>
<p>原因是TCP首部中的选项字段长度是可变的，而UDP首部是固定长度的，不会发生变化，所以使用UDP通信的双方都按照约定好的UDP首部长度来进行通信，不需要一个专门的字段来记录首部长度。</p>
<h1 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h1><h2 id="TCP三次握手的过程"><a href="#TCP三次握手的过程" class="headerlink" title="TCP三次握手的过程"></a>TCP三次握手的过程</h2><p>TCP是面向连接的协议，所以使用TCP前必须先建立连接，而建立连接是通过三次握手来进行的，三次握手的过程如下：</p>
<img data-src="/images/TCP三次握手与四次挥手/TCP三次握手.png" alt="TCP 三次握手" style="zoom:80%;" />

<p>开始服务器和客户端都处于<code>CLOSE</code>状态，然后先是服务端主动开始监听某个端口，处于<code>LISTEN</code>状态</p>
<img data-src="/images/TCP三次握手与四次挥手/first.png" alt="第一个报文—— SYN 报文" style="zoom:80%;" />

<p>之后，客户端向服务器发送第一个报文，客户端随机初始化一个序列号(<code>client_isn</code>)，将此序号至于TCP首部的「序号」字段，同时把<code>SYN</code>标志置为1，表示<code>SYN</code>报文。接着把第一个<code>SYN</code>报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于<code>SYN-SNET</code>状态。</p>
<p><img data-src="/images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/second.png" alt="第二个报文 —— SYN + ACK 报文"></p>
<p>服务器收到客户端的<code>SYN</code>报文后，首先服务端也随机初始化自己的序号(<code>server_isn</code>)，将次序号填入TCP首部的「序号」字段中，其次把TCP首部的「确认应答号」字段填入<code>client-isn + 1</code>，接着把<code>SYN</code>和<code>ACK</code>标志置为1.最后吧该报文发送给客户端，该报文也不包含应用层数据，之后服务端处于<code>SYN-RCVD</code>状态。</p>
<p><img data-src="/images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/third.png" alt="第三个报文 —— ACK 报文"></p>
<p>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先改应答报文TCP首部<code>ACK</code>标志位置为1，其次「确认应答号」字段填入<code>server-isn + 1</code>，最后吧报文发送给服务端，这次报文可以携带客户导服务器的数据，只有客户端处于<code>ESTABLISHED</code>状态。</p>
<p>服务器收到客户端的应答报文后，也进入<code>ESTABLISHED</code>状态。</p>
<p>从上面的过程可以发现，<strong>第三次握手是可以携带数据的，前两次握手不能携带数据</strong>。</p>
<p>一旦完成了三次握手，双方都处于<code>ESTABLISHED</code>状态，此时连接就已经建立完成，客户端和服务端就可以相互发送数据了。</p>
<h2 id="为什么是三次握手而不是两次、四次？"><a href="#为什么是三次握手而不是两次、四次？" class="headerlink" title="为什么是三次握手而不是两次、四次？"></a>为什么是三次握手而不是两次、四次？</h2><p>前面我们知道了<strong>TCP连接</strong>是：用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合包括<strong>Socket、序列号和窗口大小</strong>。</p>
<p>所以问题变成了为什么三次握手才可以初始化Socket、序列号和窗口大小并建立TCP连接。</p>
<p>从三个方面来说分别是：</p>
<ul>
<li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li>
<li>三次握手才可以同步双方的初始序列</li>
<li>三次握手才可以避免资源浪费</li>
</ul>
<h3 id="避免历史连接"><a href="#避免历史连接" class="headerlink" title="避免历史连接"></a>避免历史连接</h3><p>RFC 973中支出的TCP连接使用三次握手的主要原因：</p>
<blockquote>
<p>The principle reason for the three-way handshake is to prevent old connection initiations from casing confusion.</p>
</blockquote>
<p>简单来说，三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。</p>
<p>考虑一个场景，，客户端先发送了 SYN（seq &#x3D; 90） 报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq &#x3D; 100） 报文（注意不是重传 SYN，重传的 SYN 的序列号是一样的），下图为三次握手的序列图：</p>
<img data-src="/images/TCP三次握手与四次挥手/prevent-history-connection.png" alt="三次握手避免历史连接" style="zoom:80%;" />

<p>而如果是两次握手就建立连接，那就回变成下面这样，被动接收方在第一次收到报文之后就会进入<code>ESTABLISHED</code>状态，并没有阻止掉历史连接，导致「被动发起方」建立了一个历史连接，又白白发送了数据，浪费了「被动发起方的资源」。</p>
<p><img data-src="/images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/two-handshake.png" alt="两次握手无法阻止历史连接"></p>
<p>所以要解决这种现象，最好就是在「被动发起方」发送数据之前，就要组织掉历史连接，这样就不会造成资源的浪费，而三次握手就可以很好的解决这一问题。</p>
<h3 id="同步双方初始序列号"><a href="#同步双方初始序列号" class="headerlink" title="同步双方初始序列号"></a>同步双方初始序列号</h3><p>TCP通信的双方，都必须维护一个「序列号」，序列号是可靠传输的一个关键因素，他的作用包括：</p>
<ul>
<li>接收方可以除去重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中，那些是已经被对方接受的（通过ACK报文中的序列号知道）；</li>
</ul>
<img data-src="/images/TCP三次握手与四次挥手/serial-number.png" alt="四次握手与三次握手" style="zoom: 67%;" />

<p>四次握手也可以可靠的同步双方的初始化序号，但由于第二部和第三步就可以优化成一步，所以就成了「三次握手」。</p>
<p>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<h3 id="避免资源浪费"><a href="#避免资源浪费" class="headerlink" title="避免资源浪费"></a>避免资源浪费</h3><p>如果只有「两次握手」当客户端的<code>SYN</code>请求连接在网络中阻塞，客户端没有收到<code>ACK</code>报文，就会重新发送<code>SYN</code>，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的<code>ACK</code>确认信号，所以没接收到一个<code>SYN</code>就只能先主动建立一个连接，这在网络阻塞的时候会造成不必要的资源浪费。</p>
<img data-src="/images/TCP三次握手与四次挥手/two-handshake-problem.png" alt="两次握手会造成资源浪费" style="zoom:80%;" />

<p>如果客户端的<code>SYN</code>阻塞了，重复发送多次<code>SYN</code>报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成资源的浪费。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>TCP建立连接时，通过三次握手能防止历史连接的建立，可以减少双方不必要的资源开销，可以帮助双方同步初始化序列号。序列号可以保证数据包不重复、不丢弃和按序传输。</p>
<p>不使用两次握手和四次握手的原因：</p>
<ul>
<li>两次握手：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>四次握手：三次握手理论上已经最少可靠的建立连接，所以不需要使用更多的通信次数。</li>
</ul>
<h2 id="为什么每次建立TCP连接时，初始化序列都要求不一样"><a href="#为什么每次建立TCP连接时，初始化序列都要求不一样" class="headerlink" title="为什么每次建立TCP连接时，初始化序列都要求不一样"></a>为什么每次建立TCP连接时，初始化序列都要求不一样</h2><p>主要有两个方面的原因：</p>
<ul>
<li>为了防止历史报文被下一个相同四元组的连接接收；</li>
<li>为了安全性，防止黑客伪造相同序列号的TCP报文被对方接收。</li>
</ul>
<h1 id="TCP断开连接"><a href="#TCP断开连接" class="headerlink" title="TCP断开连接"></a>TCP断开连接</h1><h2 id="TCP四次挥手的过程"><a href="#TCP四次挥手的过程" class="headerlink" title="TCP四次挥手的过程"></a>TCP四次挥手的过程</h2><p>TCP断开连接的方式是通过四次挥手的方式，双方都可以主动断开连接，断开连接后朱继忠的资源将被释放，四次挥手的过程如下图：</p>
<p><img data-src="/images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/close-connection.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p>
<ul>
<li>客户端打算关闭连接，此时会发送一个TCP首部<code>FIN</code>标志位被置为1的报文，即<code>FIN</code>报文，之后客户端进入<code>FIN_WAIT_1</code>状态。</li>
<li>服务端收到该报文后，就像客户端发送<code>ACK</code>应答报文，接着服务端进入<code>CLOSE_WAIT</code>状态。</li>
<li>客户端收到服务端的<code>ACK</code>应答报文后，进入<code>FIN_WAIT_2</code>状态。</li>
<li>等待服务端处理完数据后，也向客户端发送<code>FIN</code>报文，之后服务端进入<code>LAST_ACK</code>状态 。</li>
<li>服务器收到 <code>ACK</code>应答报文之后，就进入<code>CLOSE</code>状态，至此服务端已完成连接的关闭。</li>
<li>客户端经过<code>2MSL</code>后，自动进入<code>CLOSE</code>状态，客户端也完成了连接的关闭。</li>
</ul>
<p>以上过程为主动关闭连接的过程，主动关闭才有<code>TIME_WAIT</code>状态。</p>
<h3 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h3><ul>
<li>关闭连接时，客户端向服务器发送<code>FIN</code>时，仅仅表示客户端不会再发送数据了，但是还可以接收数据。</li>
<li>服务器收到客户端的<code>FIN</code>报文时，先回一个<code>ACK</code>应答报文，而服务端还可能有数据需要处理和发送，等服务端不要在发送数据时，才发送<code>FIN</code>报文给客户端，来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的<code>FIN</code>和<code>ACK</code>一般是分开发送的，因此需要四次挥手。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86">小林coding-三次握手与四次挥手</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP四层模型</title>
    <url>/2022/08/01/TCP-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>TCP&#x2F;IP网络模型适用于不同设备上进程间的通信，共分为四层分，从上到下分别是<strong>应用层、传输层、网络层、网络接口层</strong></p>
<h1 id="应用层（Application-Layer）"><a href="#应用层（Application-Layer）" class="headerlink" title="应用层（Application Layer）"></a>应用层（Application Layer）</h1><p>应用层是最上层的，我们能直接接触到的层，我们日常所使用的软件都是在应用层上实现的。</p>
<p>应用层不关心数据是如何传输的，就和我们寄快递的时候只需要把包裹交给快递员，我们不关心包裹是如何运输的。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>应用层的协议包括HTTP、FTP、Telnet、DNS、SMTP等。</p>
<h1 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h1><p>传输层是为应用层提供网络支持的，在传输层有两个传输协议，分别是TCP和UDP。</p>
<h2 id="TCP（Transmission-Control-Protocol）"><a href="#TCP（Transmission-Control-Protocol）" class="headerlink" title="TCP（Transmission Control Protocol）"></a>TCP（Transmission Control Protocol）</h2><p>TCP的全称是传输控制协议，大部分应用传输层协议使用的都是TCP，TCP为了保证数据能够可靠的传输到目的地，有流量控制、超时重传、拥塞控制等特性。</p>
<h2 id="UDP（User-Datagram-Protocol）"><a href="#UDP（User-Datagram-Protocol）" class="headerlink" title="UDP（User Datagram Protocol）"></a>UDP（User Datagram Protocol）</h2><p>UDP全称是用户报文协议，UDP相对TCP来说就很简单，只负责发送数据包，至于数据包能否正常抵达目的地，UDP不能保证；但是换一个角度来说，UDP少干了这么多，那他的实时性相对TCP来说更好，传输效率也更高。</p>
<p>通常来说一台设备上会运行多个应用进程，为了区分数据要发送的具体进程，传输层中需要指定<strong>端口号</strong>来区分不同的进程和应用。</p>
<span id="more"></span>

<h1 id="网络层（Internet-Layer）"><a href="#网络层（Internet-Layer）" class="headerlink" title="网络层（Internet Layer）"></a>网络层（Internet Layer）</h1><p>负责将数据从一个设备发送到另一个设备的并不是传输层，传输层设计的理念是，简单、高效、专注，实际场景中的网络环节错综复杂，网络层就来是负责数据实际传输。</p>
<p>网络层最常用的是<strong>IP协议（Internet Protocol）</strong>，IP协议会将传输层的报文作为数据部分，再加上IP数据包组装成IP报文。</p>
<img data-src="/images/TCP-IP四层模型/12.jpg" alt="img" style="zoom:80%;" />

<p>网络层负责将数据从一个设备传输到另一个设备，而为了确定目标设备，网络层需要有区分设备单的编号，这个编号就是IP地址。</p>
<p>对于IPv4协议，IP地址共32位（32个bit），共分成四段（例如：192.168.1.1），每段8位。如果只有单纯的IP地址，虽然做到了设备区分，但是殉职起来就特别麻烦，世界上那么多设备，一个个去匹配显然是非常不科学的。</p>
<p>因此需要借助<strong>子网掩码</strong>来将IP地址分为两种意义：</p>
<ul>
<li>一个是网络号，负责标识IP地址是属于哪一个[子网]的；</li>
<li>一个是主机号，负责标识同一子网下的不同主机；</li>
</ul>
<p>举个栗子，比如192.168.1.1&#x2F;24，后面的<code>/24</code>表示的就是子网掩码<code>255.255.255.0</code>，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，其中共有24个1，为了简化子网掩码的表示，就用<code>/24</code>来代替。</p>
<p>网络号&#x3D;IP地址<strong>按位与</strong>子网掩码</p>
<p>主机号&#x3D;IP地址<strong>按位与</strong>子网掩码取反</p>
<h1 id="网络接口层（Link-Layer）"><a href="#网络接口层（Link-Layer）" class="headerlink" title="网络接口层（Link Layer）"></a>网络接口层（Link Layer）</h1><p>网络层生成完IP头部之后，接下来要交给网络接口层在IP头前面加上MAC头，并封装成数据帧（Data Frame）发送到网络上。</p>
<p>IP头中的接收方IP表示网络包的目的地，通过这个地址我们就可以判断要将包发送到那里，但是在以太网的世界中，这个思路行不通！</p>
<p>以太网是一种在局域网内，把附近的设备连接起来，使其可以互相通讯的技术。我们电脑上的以太网口、WiFi接口，以太网交换机、路由器上的千兆、万兆网口，还有网线，都是以太网的组成部分。</p>
<p>以太网判断网络包目的地的方式和IP不同，不需要采用互相匹配的方式才能在以太网中将包发往目的地，而MAC头就是干这个用的，所以在以太网进行通讯需要用到MAC地址。</p>
<p>MAC头是以太网使用的头，包含了发送方和接收方的MAC地址等信息，我们可以通过ARP协议获取对方的MAC地址。</p>
<p>所以网络接口层主要为网络提供链路级别的传输服务，负责在以太网、WiFi这样的底层网络上发送原始数据包，工作在网卡这个层次，使用MAC地址来别试网络中的设备。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TCP&#x2F;IP网络的四层结构总结如下图：</p>
<img data-src="/images/TCP-IP四层模型/tcpip参考模型.png" alt="img" style="zoom:80%;" />

<p>每一层的封装结构如下图：</p>
<img data-src="/images/TCP-IP四层模型/封装.png" alt="img"  />

<p>网络接口层的传输单位是帧（frame），IP层的传输单位是包（package），TCP层的传输单位是段（segment），HTTP的传输单位则是消息或报文（message），这些单位其实并没有本质上的区别，可以统称为数据包。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.xiaolincoding.com/network/1_base/tcp_ip_model.html">小林coding TCP&#x2F;IP 网络模型有哪几层？</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal学习</title>
    <url>/2024/08/02/ThreadLocal%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h1><p><strong>ThreadLocal</strong>顾名思义，就是线程局部变量，也可以叫线程变量。可以让不同的线程访问自己独有的变量，而不会影响其他线程变量，实现了线程隔离级别的变量存储。</p>
<p>常见的使用场景包括：</p>
<ul>
<li>会话管理：在web应用中，可以使用线程变量来存储请求中的相关信息，这样在后续处理请求的过程中都可以方便的获取到请求相关的信息，比如用户的相关信息。</li>
<li>数据库连接管理：在并发访问数据库的场景下，使用线程变量管理数据库的连接，这样每个线程都有自己独立的数据库连接，避免线程之间数据不一致和连接冲突的问题。</li>
</ul>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p><img data-src="/../images/ThreadLocal%E5%AD%A6%E4%B9%A0/IMG-20240802115006316.png"></p>
<p><code>Thread</code>类中有一个<code>threadLocals</code>的属性，这是一个<code>ThreadLocalMap</code>对象。<code>ThreadLocalMap</code>可以被看做是一个集合，其内部维护一个<code>Entry[]</code>数组，用来保存<code>ThreadLocal</code>的引用。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用<code>ThreadLocal</code>的get方法时，其实是从<code>Thread</code>类中去取<code>threadLocals</code>的值，<code>getMap</code>方法就是从当前的<code>thread</code>对象里面取出<code>threadLocals</code>，如果取出来为<code>null</code>就说说明当前线程还没有创建过<code>ThreadLocalMap</code>就会调用<code>setInitialValue</code>方法来初始化一个<code>ThreadLocalMap</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，<code>ThreadLocal</code>是通过在每个线程对象的实例中都维护一个<code>threadLocalMap</code>，然后将<code>ThreadLocal</code>作为map的key（准确来说是<code>ThreadLocal</code>对象的哈希值和此时<code>Entry</code>数组的长度按位与），value就是我们set的对应值，这样每个线程都会有自己的一个map，我们也可以在这一个线程中的任意地方来获取这个map中的值，并且不同线程之间不会互相影响。</p>
<h1 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h1><h2 id="1-不会存在内存泄漏的情况"><a href="#1-不会存在内存泄漏的情况" class="headerlink" title="1. 不会存在内存泄漏的情况"></a>1. 不会存在内存泄漏的情况</h2><p>不使用线程池创建而单独创建线程时，这种情况下因为<code>ThreadLocalMap</code>是<code>Thread</code>类的一个成员变量，会随着线程的消亡而消亡，即使我们不手动将value移除，<code>ThreadLocalMap</code>也不会存在，其中的Entry数组也不会存在。</p>
<p>在实际项目中一般也不会这样去使用<code>ThreadLocal</code>，这样使用也毫无意义，并且通常情况下我们都是用线程池来创建对象，线程池中的核心线程基本会伴随着应用程序的整个生命周期。</p>
<p>另一种情况是我们实例化的<code>ThreadLocal</code>对象是一个长生命周期的，通常就是static修饰的静态类变量，这种情况下<code>ThreadLocal</code>对象的生命周期和应用程序一样长，一般不将其人为赋值为<code>null</code>，就不会出现弱引用的情况，GC也就不会将其给回收掉。但是在我们使用完变量之后还是要将其remove掉，否则另一个用户发起会话可能会错误的读取到上一个用户的值。</p>
<h2 id="2-存在内存泄漏的情况"><a href="#2-存在内存泄漏的情况" class="headerlink" title="2.存在内存泄漏的情况"></a>2.存在内存泄漏的情况</h2><p>当我们创建的<code>ThreadLocal</code>对象是短生命周期的，随着<code>ThreadLocal</code>对象变成<code>null</code>之后，GC会回收<code>ThreadLocalMap</code>中弱引用的<code>ThreadLocal</code>对象，而它对应的value由于是一个强引用的对象，无法被回收，这个时候value和线程的生命周期一样长，就会一直占着内存造成内存泄漏问题。</p>
<h2 id="为什么key是弱引用"><a href="#为什么key是弱引用" class="headerlink" title="为什么key是弱引用"></a>为什么key是弱引用</h2><p>弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>简单理解就是当垃圾回收时，该对象只被<code>WeakReference</code>对象的弱引用字段（T reference）所引用，而未被任何强类型的对象引用，那么，该弱引用的对象就会被回收。</p>
<ol>
<li>假设 Entry 的 key 是对 <code>ThreadLocal</code> 对象的强引用：这个 Entry 又持有 <code>ThreadLocal</code> 对象和 value 对象的强引用。如果在其他地方都没有对这个 <code>ThreadLocla</code> 对象的引用了，然后在使用 ThreadLocalMap 的过程中又没有正确地在用完后就调用 remove 方法，所以这个 <code>ThreadLocal</code> 对象和所关联的 value 对象就会跟随着线程一直存在，这样就会可能会造成内存泄漏问题。<br>特别是在使用线程池的时候，核心线程是会一直存在直到程序结束，如果这些线程中的 <code>ThreadLocalMap</code> 中的数据没有被及时清理，就会一直占用内存，而且在线程复用时可能会导致数据错乱的危险。</li>
<li>Entry 的 key 是对 <code>ThreadLocal</code> 对象的弱引用：弱引用就意味着，如果没有其他引用对象的强引用关系，那么这个仅被弱引用引用着的对象在下次 GC 时就会被回收掉，这样在一定程度上降低内存泄漏的风险。但同时也引入了新的问题，key 虽然被回收了，但是 value 对象还在，我们无法获取，也无法删除，这样也会存在内存泄漏的风险。虽然 <code>ThreadLocalMap</code> 中在进行 set 和 get 操作时会进行启发式清理和探测式清理，清理一部分 key 为 null 的 Entry 对象，<strong>但是这也只是一种后备选择方案，最重要的还是开发人员在编写代码时记得在使用完数据后及时调用 remove() 方法手动清理</strong>。</li>
</ol>
<h1 id="清理策略"><a href="#清理策略" class="headerlink" title="清理策略"></a>清理策略</h1><p><code>ThreadLocalMap</code>一共有两种清理策略，分别是<strong>探测式清理</strong>和<strong>启发式清理</strong>。</p>
<ul>
<li>探测式清理：源码中的<code>expungeStaleEntry()</code>方法</li>
<li>启发式清理：源码中的<code>cleanSomeSlots()</code>方法</li>
</ul>
<h2 id="1-探测式清理"><a href="#1-探测式清理" class="headerlink" title="1. 探测式清理"></a>1. 探测式清理</h2><p>探测式清理会从指定的位置（也就是<code>staleSlot</code>）开始向后探测清理过期的数据，将过期的数据，也就是<code>key==null</code>的<code>Entry</code>设置为null，沿途中碰到未过期的数据，就将此数据<code>rehash</code>后重新在table数组中定位，如果定位到的位置已经有数据了，则会依次向后遍历，将未过期的数据放到最靠近此位置并且<code>Entry==null</code>的位置，是的rehash后的Entry数据里正确的桶的位置更近一些。</p>
<p>简单总结就是探测式清理会将<code>key==null</code>位置的Entry也置为null，不为空的则会重新计算哈希值分配位置，如果重新分配的位置上有元素了，就往后延续。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-启发式清理"><a href="#2-启发式清理" class="headerlink" title="2. 启发式清理"></a>2. 启发式清理</h2><p>启发式清理需要接受两个参数，分别是：</p>
<ol>
<li>探测式清理后返回的下标</li>
<li>数组的总长度</li>
</ol>
<p>从源码可以看出，启发式清理从传入的下标<code>i</code>开始向后遍历，如果发现过期的Entry就会再次触发探测式清理，并将n重置为table长度，经过数组长度的2的整数次幂的梁旭遍历之后如果没有发现过期的Entry，就人为数组中没有过期的Entry了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="literal">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-哪些地方会触发这两种清理方式"><a href="#3-哪些地方会触发这两种清理方式" class="headerlink" title="3. 哪些地方会触发这两种清理方式"></a>3. 哪些地方会触发这两种清理方式</h2><ol>
<li>set() 方法中，遇到<code>key==null</code>的情况会触发一轮<strong>探测式清理</strong></li>
<li>set()方法最后会执行一次<strong>启发式清理</strong></li>
<li>rehash()方法会调用一次<strong>探测式清理</strong></li>
<li>get()方法中入到key过期的时候也会触发一次<strong>探测式清理</strong></li>
<li>启发式清理过程中遇到<code>key==null</code>时会触发<strong>探测式清理</strong></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu系统Apache2部署SSL证书</title>
    <url>/2020/04/25/Ubuntu%E7%B3%BB%E7%BB%9FApache2%E9%83%A8%E7%BD%B2SSL%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<p>本文档为您介绍了如何在Ubuntu系统以及Apache2中安装阿里云SSL证书。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>操作系统：Ubuntu</p>
<p>Web服务器：Apache 2</p>
<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li>已从<a href="https://yundunnext.console.aliyun.com/?p=cas#/overview/cn-hangzhou">SSL证书控制台</a>下载Apache服务器证书。</li>
<li>已安装Open SSL。</li>
</ul>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol>
<li><p>运行以下命令在apache2目录下创建ssl目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /etc/apache2/ssl</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行以下命令将下载的阿里云证书文件复制到ssl目录中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -r YourDomainName_public.crt /etc/apache2/ssl</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -r YourDomainName_chain.crt /etc/apache2/ssl</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -r YourDomainName.key /etc/apache2/ssl</span><br></pre></td></tr></table></figure>

<span id="more"></span>
</li>
<li><p>运行以下命令启用SSL模块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo a2enmod ssl</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/Ubuntu%E7%B3%BB%E7%BB%9FApache2%E9%83%A8%E7%BD%B2SSL%E8%AF%81%E4%B9%A6/znDyZLWRAsv2f4t.png" alt="image.png"></p>
<p>SSL模块启用后可执行<code>ls /etc/apache2/sites-available</code>查看目录下生成的default-ssl.conf文件。</p>
<p><strong>说明：</strong> 443端口是网络浏览端口，主要用于HTTPS服务。SSL模块启用后会自动放行443端口。若443端口未自动放行，可执行<code>vi /etc/apache2/ports.conf</code>并添加<code>Listen 443</code>手动放行。</p>
</li>
<li><p>运行以下命令修改SSL配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/apache2/sites-available/YourDomainName-ssl.conf</span><br></pre></td></tr></table></figure>

<p>在default-ssl.conf文件中找到以下参数进行修改后保存并退出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;IfModules mod_ssl.c&gt;</span><br><span class="line">&lt;VirtualHost *:443&gt;  </span><br><span class="line">ServerName   <span class="comment">#修改为证书绑定的域名www.YourDomainName.com。</span></span><br><span class="line">SSLCertificateFile /etc/apache2/ssl/www.YourDomainName_public.crt   </span><br><span class="line"><span class="comment">#将/etc/apache2/ssl/www.YourDomainName.com_public.crt替换为证书文件路径+证书文件名。</span></span><br><span class="line">SSLCertificateKeyFile /etc/ssl/apache2/www.YourDomainName.com.key   </span><br><span class="line"><span class="comment">#将/etc/apache2/ssl/www.YourDomainName.com.key替换为证书秘钥文件路径+证书秘钥文件名。</span></span><br><span class="line">SSLCertificateChainFile /etc/apache2/ssl/www.YourDomainName.com_chain.crt  </span><br><span class="line"><span class="comment">#将/etc/apache2/ssl/www.YourDomainName.com_chain.crt替换为证书链文件路径+证书链文件名。</span></span><br><span class="line">						</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/Ubuntu%E7%B3%BB%E7%BB%9FApache2%E9%83%A8%E7%BD%B2SSL%E8%AF%81%E4%B9%A6/XESFU87K4QfY92A.png" alt="image.png"></p>
<p>&#x2F;sites-available：该目录存放的是可用的虚拟主机；&#x2F;sites-enabled：该目录存放的是已经启用的虚拟主机。</p>
<p><strong>说明：</strong> default-ssl.conf文件可能存放在&#x2F;etc&#x2F;apache2&#x2F;sites-available或&#x2F;etc&#x2F;apache2&#x2F;sites-enabled目录中。</p>
</li>
<li><p>运行以下命令把default-ssl.conf映射至&#x2F;etc&#x2F;apache2&#x2F;sites-enabled文件夹中建立软链接、实现二者之间的自动关联。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ln -s /etc/apache2/sites-available/YourDomainName-ssl.conf /etc/apache2/sites-enabled/YourDomainName-ssl.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行以下命令重新加载Apache 2配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/apache2 force-reload</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/Ubuntu%E7%B3%BB%E7%BB%9FApache2%E9%83%A8%E7%BD%B2SSL%E8%AF%81%E4%B9%A6/4Rn27NQuZgTDoFK.png" alt="image.png"></p>
</li>
<li><p>运行以下命令重启Apache 2服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/apache2 restart</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/Ubuntu%E7%B3%BB%E7%BB%9FApache2%E9%83%A8%E7%BD%B2SSL%E8%AF%81%E4%B9%A6/13p6Xtfh49s8VQi.png" alt="image.png"></p>
</li>
</ol>
<h2 id="后续操作"><a href="#后续操作" class="headerlink" title="后续操作"></a>后续操作</h2><p>Apache 2服务重启成功后，您可在浏览器中输入<a href="https://www.yourdomainname.com验证证书安装结果.浏览器地址栏显示绿色的小锁标识说明证书安装成功./">https://www.YourDomainName.com验证证书安装结果。浏览器地址栏显示绿色的小锁标识说明证书安装成功。</a></p>
<p><a href="https://help.aliyun.com/document_detail/102450.html?spm=a2c4g.11186623.2.16.641a5d990B7ZJl#title-8vo-dzo-1in">原文地址</a></p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>docker的基本使用</title>
    <url>/2020/03/28/docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img data-src="/images/docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/z6JqkpsQT2orBhE.png" alt="docker.jpg"></p>
<blockquote>
<p>前几天学了一下docker，一方面是记录一下这些命令，另一方面为了复习一下，所以写了下面这些！有什么问题还请指正！</p>
</blockquote>
<h2 id="在Linux中下载docker"><a href="#在Linux中下载docker" class="headerlink" title="在Linux中下载docker"></a>在Linux中下载docker</h2><p>CentOS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker</span><br></pre></td></tr></table></figure>

<p>ubunte</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install docker.io</span><br></pre></td></tr></table></figure>

<blockquote>
<p>找不到包的话update一下</p>
<p>CentOS<code>yum update</code></p>
<p>Ubuntu<code>apt-get update</code></p>
</blockquote>
<span id="more"></span>

<h2 id="更换docker镜像源"><a href="#更换docker镜像源" class="headerlink" title="更换docker镜像源"></a>更换docker镜像源</h2><p>在<code>/etc/docker/</code> 目录下修改或者新建<code>daemon.json</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://registry.docker-cn.com&quot;</span>]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Docker国内其他源：</p>
<p>Docker 官方中国区</p>
<p><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></p>
<p>网易</p>
<p><a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></p>
<p>中国科技大学</p>
<p><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></p>
<p>阿里云的源需要注册，我没有去折腾</p>
<h2 id="镜像相关的命令"><a href="#镜像相关的命令" class="headerlink" title="镜像相关的命令"></a>镜像相关的命令</h2><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search 镜像名</span><br></pre></td></tr></table></figure>

<p>这个没什么好说的，就是根据你给出的镜像名列出仓库中有的相关的镜像 </p>
<p>可以加条件 -s star数</p>
<p>比如<code>docker search -s 50 mysql</code>就是star数在50K以上的镜像才会被列出来</p>
<p>等于就是增加搜索的条件，还有其他的参数可以自己查</p>
<h3 id="从仓库pull镜像"><a href="#从仓库pull镜像" class="headerlink" title="从仓库pull镜像"></a>从仓库pull镜像</h3><p>这个命令就和git的pull差不多意思，git pull拉的是代码；docker pull拉的是镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名:版本号</span><br><span class="line">版本号不写默认就是latest，最新的</span><br></pre></td></tr></table></figure>

<p>比如拉MySQL的镜像：<code>docker pull mysql</code></p>
<h3 id="删除一个镜像"><a href="#删除一个镜像" class="headerlink" title="删除一个镜像"></a>删除一个镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像名或ID</span><br></pre></td></tr></table></figure>

<h3 id="打包镜像"><a href="#打包镜像" class="headerlink" title="打包镜像"></a>打包镜像</h3><blockquote>
<p>将镜像打包，方便移植到其他设备运行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o 打包后的名字.tar 镜像名</span><br></pre></td></tr></table></figure>

<h3 id="导入打包的镜像"><a href="#导入打包的镜像" class="headerlink" title="导入打包的镜像"></a>导入打包的镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load &lt; 包名</span><br></pre></td></tr></table></figure>



<h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><h3 id="由镜像创建一个容器并运行"><a href="#由镜像创建一个容器并运行" class="headerlink" title="由镜像创建一个容器并运行"></a>由镜像创建一个容器并运行</h3><p>这里就以mysql为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -di --name=mysql -p 3306:3306 -e TZ=Asia/Shanghai MYSQL_ROOT_PASSWORD=123456 mysql --lower_case_table_names=1</span><br></pre></td></tr></table></figure>

<p>mysql的参数比较多一点</p>
<blockquote>
<p>-d表示后台运行</p>
<p>-i表示交互式的操作（我也不太明白什么意思，后面弄明白了再更新）</p>
<p>–name是给生成的容器取名字</p>
<p>-p是端口的映射，冒号前面的是宿主机的端口，后面的是容器中的端口，意思就是容器中3306的端口映射到宿主机的3306端口，直接访问宿主机的3306端口就可以访问到docker中的MySQL。如果要在宿主机直接连接MySQL，可以ip a看一下docker的在宿主机的ip，然后通过那个ip的3306端口就可以访问了</p>
<p>MYSQL_ROOT_PASSWORD 这个是这只mysql的root用户密码</p>
<p>–lower_case_table_names&#x3D;1 这个是不区分表的大小写，当初就是应为这个才入了docker的坑，直接在服务装的MySQL打死改不了这个大小写不敏感，一个项目里面刚好有有很多表是大写，数据库里面是小写的，我就是不想改成小写（傲娇脸），然后折腾几天都没能改好，后来就考虑了docker。在Windows下运行没问题，因为Windows本来就不区分大小写，到Linux下面就区分大小写了，项目部署 好久，都没能跑起来，报错找不到表，我当时还莫名其妙，明明有这个表怎么找不到呢，后来发现了这个坑。</p>
</blockquote>
<p>运行Tomcat就简单些：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -dp 8080:8080 tomcat镜像ID</span><br></pre></td></tr></table></figure>

<p>上面都是在后台运行的，如果想要直接在</p>
<h3 id="停止容器的运行"><a href="#停止容器的运行" class="headerlink" title="停止容器的运行"></a>停止容器的运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop 容器名</span><br></pre></td></tr></table></figure>

<h3 id="启动创建的镜像"><a href="#启动创建的镜像" class="headerlink" title="启动创建的镜像"></a>启动创建的镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start 容器名</span><br></pre></td></tr></table></figure>

<p><strong>重启就是restart啦</strong></p>
<h3 id="进入到容器中"><a href="#进入到容器中" class="headerlink" title="进入到容器中"></a>进入到容器中</h3><blockquote>
<p>一个容器其实就是一个小的Linux环境，但是做了很多精简，只保留了必要的部分</p>
</blockquote>
<p>有两种方式：</p>
<p>第一种：<code>docker attach 容器名字或者ID </code></p>
<p>第二种：<code>docker exec -it 容器名或ID /bin/bash</code></p>
<p>这两个的区别，如果第一种方式进去在exit，那会退出并且停止容器的运行，第二种exit不会停止运行</p>
<h3 id="删除一个容器"><a href="#删除一个容器" class="headerlink" title="删除一个容器"></a>删除一个容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> 容器名或ID</span><br></pre></td></tr></table></figure>

<h3 id="由容器创建一个镜像"><a href="#由容器创建一个镜像" class="headerlink" title="由容器创建一个镜像"></a>由容器创建一个镜像</h3><blockquote>
<p>你从远程仓库拉的默认镜像，经过个性化的配置之后，就可以这样创建一个自己的镜像，然后在把镜像打包成压缩包，传到其他设备，导入之后就又可以在其他设备运行了</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit -a 这个镜像的作者 -m 提交时候的文字说明 容器名 创建的镜像名</span><br></pre></td></tr></table></figure>

<h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -aq</span><br></pre></td></tr></table></figure>

<p>什么都不加就只会列出当前正在运行的容器</p>
<p>加上<code>-a</code>是列出所有的镜像，<code>-q</code>表示静默模式，只显示容器编号</p>
<p><code>docker rm (docker ps -aq)</code>这个组合命令就是删除所有的容器</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu中设置http强制重定向为https</title>
    <url>/2020/04/25/http%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%BAhttps/</url>
    <content><![CDATA[<h3 id="1-开启重定向"><a href="#1-开启重定向" class="headerlink" title="1.开启重定向"></a>1.开启重定向</h3><p>a2enmod rewrite</p>
<h3 id="2-设置http端口重定向"><a href="#2-设置http端口重定向" class="headerlink" title="2.设置http端口重定向"></a>2.设置http端口重定向</h3><p>将下面这段放到要重定向的站点配置文件里面，放在&lt;\VirtualHost *:80&gt;&lt;\VirtualHost&gt; 标签内的任何位置都行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RewriteEngine on</span><br><span class="line">RewriteCond  %&#123;HTTPS&#125; !=on</span><br><span class="line">RewriteRule  ^(.*)  https://%&#123;SERVER_NAME&#125;<span class="variable">$1</span> [L,R]</span><br></pre></td></tr></table></figure>

<h3 id="重启apach2"><a href="#重启apach2" class="headerlink" title="重启apach2"></a>重启apach2</h3><p>service apache2 restart</p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>git的基本使用</title>
    <url>/2020/03/14/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<img data-src="/images/git的基本使用/HjQNKBory3xwiJv.jpg" alt="git.jpg" style="zoom:50%;" />

<blockquote>
<p>git是一个前几年兴起的很好用的版本管理工具，用了半年多了体验还是很不错了，也是现在比较主流的版本管理工具。现在分享一下git的基操，但是最好是要理解好这些命令的作用，否则后果可能很严重（手动滑稽），我自己就有过这样的经历。另外，最好是有Linux的命令基础，没有的话理解起来很吃力。</p>
</blockquote>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="配置全局的邮箱和用户名"><a href="#配置全局的邮箱和用户名" class="headerlink" title="配置全局的邮箱和用户名"></a>配置全局的邮箱和用户名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;云代码托管平台（github、gitlab或者gitee）的用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;注册的邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个也可以在c盘用户的根目录下面打开<code>.gitconfig</code>文件进行配置</p>
<span id="more"></span>

<img data-src="/images/git的基本使用/mbg5o7HP3jOErcf.png" alt="image.png" style="zoom: 50%;" />

<img data-src="/images/git的基本使用/Wy3QFZUBHwsOLcJ.png" alt="image.png" style="zoom: 50%;" />

<p><strong>命令里面不加global就只是对当前仓库的配置</strong></p>
<h3 id="生成ssh秘钥对"><a href="#生成ssh秘钥对" class="headerlink" title="生成ssh秘钥对"></a>生成ssh秘钥对</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f 秘钥名称 -C <span class="string">&#x27;注册邮箱&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在用户根目录下会生成一个.ssh的文件夹</p>
<p>开始里面会有两个文件,后缀是<code>.pub</code>的是公钥,另一个是私钥</p>
<img data-src="/images/git的基本使用/FWH2QwClGYJgdpt.png" alt="image.png" style="zoom: 50%;" />

<p>用记事本或者其他的编辑器打开这个文件，复制其全部内容，以GitHub为例：点击<code>new ssh key</code></p>
<p><img data-src="/images/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/mEh4VgXdPOrCbkx.png"></p>
<p>将其粘贴到Key的框框中，手动打码（嘿嘿嘿），然后点击add ssh key就大功告成了</p>
<p><img data-src="/images/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/y25IoJunEg41TXW.png"></p>
<p>然后在git bash中输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/PE3MsvfSURqHyc2.png"></p>
<p>如果是这样就表示，添加成功了（只要GitHub上没提示有问题，其实一般都没有问题，这一步可以跳过）</p>
<h2 id="git上传GitHub的基本步骤"><a href="#git上传GitHub的基本步骤" class="headerlink" title="git上传GitHub的基本步骤"></a>git上传GitHub的基本步骤</h2><h3 id="第一步、创建一个仓库或者clone一个仓库"><a href="#第一步、创建一个仓库或者clone一个仓库" class="headerlink" title="第一步、创建一个仓库或者clone一个仓库"></a>第一步、创建一个仓库或者clone一个仓库</h3><p>从远程仓库clone项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 仓库地址</span><br></pre></td></tr></table></figure>

<p>clone下来的项目会包含版本信息不用再初始化了，直接可以进入第二步</p>
<p>在本地创建git仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>这个命令的作用就是初始化一个git的版本管理仓库</p>
<p>执行完这个命令之后，git bash当前所在的文件夹下面会生成一个.git的文件夹</p>
<p>初始化完之后就可以在这个文件夹下面写项目了，写完项目之后↓</p>
<h3 id="第二步、将文件添加到索引中"><a href="#第二步、将文件添加到索引中" class="headerlink" title="第二步、将文件添加到索引中"></a>第二步、将文件添加到索引中</h3><p>将git bash当前所在文件夹下面的所有文件添加到索引中，除了被忽略的（gitignore又有另外一套学问，在这里不详细说了）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p><code>.</code>表示当前文件夹下面的所有文件和文件夹，但是踩过一个坑，<strong>git不会将空文件夹加入索引</strong>，要添加就要在那个空文件夹下面随便放一个文件可以是<code>.gitignore</code></p>
<p>可以参考对应的官方文档：<img data-src="/images/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/QDTdRA357Sqz8Jo.png"></p>
<h3 id="第三步、将索引中的文件提交到本地的版本库"><a href="#第三步、将索引中的文件提交到本地的版本库" class="headerlink" title="第三步、将索引中的文件提交到本地的版本库"></a>第三步、将索引中的文件提交到本地的版本库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m<span class="string">&#x27;提交的信息&#x27;</span></span><br></pre></td></tr></table></figure>

<p>引号里面一般是写这次提交修复了什么问题，或者增加了什么功能</p>
<h3 id="第四步、添加远程仓库地址"><a href="#第四步、添加远程仓库地址" class="headerlink" title="第四步、添加远程仓库地址"></a>第四步、添加远程仓库地址</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add 远程仓库在本地的名字 远程仓库地址</span><br></pre></td></tr></table></figure>

<p>远程仓库在本地的名字随便取什么都行，不知道取什么名字的话就origin吧</p>
<p>远程仓库的地址打开github的页面复制 </p>
<img data-src="/images/git的基本使用/cINP5TOfSA2Qo83.png" alt="image.png" style="zoom:50%;" />

<h3 id="第五步、从远程仓库同步版本库信息"><a href="#第五步、从远程仓库同步版本库信息" class="headerlink" title="第五步、从远程仓库同步版本库信息"></a>第五步、从远程仓库同步版本库信息</h3><p><strong>如果是第一次建立仓库，远程仓库没有东西，可以跳过这步</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull 上一步自己给远程仓库取得名字 分支名</span><br></pre></td></tr></table></figure>

<p>每次pull之前一定要进行前面三步（2-4步），要不然你pull之前改的代码可能就全没了，白改了</p>
<p>这一步也最好放在改代码之前就进行，那么久可以不用进行前面三步了</p>
<h3 id="第六步、将本地版本库的信息提交到远程仓库"><a href="#第六步、将本地版本库的信息提交到远程仓库" class="headerlink" title="第六步、将本地版本库的信息提交到远程仓库"></a>第六步、将本地版本库的信息提交到远程仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push 上上一步自己给远程仓库取得名字 分支名</span><br></pre></td></tr></table></figure>

<p>上传到远程仓库的分支本地也一定要有，否则则会报错</p>
<p>如果没创建分支的话，默认就只有一个master分支</p>
<h2 id="git的版本管理"><a href="#git的版本管理" class="headerlink" title="git的版本管理"></a>git的版本管理</h2><p>查看提交过的历史信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>回滚到之前的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard 版本哈希值</span><br></pre></td></tr></table></figure>

<p>举个栗子：</p>
<img data-src="/images/git的基本使用/aDfrmI7inANe14X.png" alt="image.png" style="zoom:67%;" />

<blockquote>
<p>如果你看到了这里，最后再看点东西吧，新人可能会分不清GitHub和git，说一下这个问题。</p>
<p>GitHub就是GitHub，git就是git，这是两个东西。非要说联系的话就是GitHub是基于git的云版本管理仓库，可以很多人一起用一个仓库开发，这就是多人协作，也可以把它当做代码的备份仓库，现在GitHub的私有仓库免费了，可以试试。GitHub和GitLab或者国内的gitee都是差不多的东西，都是基于git的云代码管理仓库。而git就是一个本地的版本控制软件，每次改完代码之后都可以commit提交到本地的版本库，如果哪次改错了很多东西，也改不回去了，这个时候git就派上用场了，可以用git回滚到之前commit过的一个版本。其实git还有很多其他的强大功能，留到下一篇再讲。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ Idea配置类和方法的注释模板</title>
    <url>/2020/04/15/idea%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="设置类的注释模板"><a href="#设置类的注释模板" class="headerlink" title="设置类的注释模板"></a>设置类的注释模板</h2><p><img data-src="/../images/idea%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/SZLA4oF5vn3hMyG.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> $&#123;USER&#125;</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> $&#123;DATE&#125; $&#123;TIME&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="设置方法的注释模板"><a href="#设置方法的注释模板" class="headerlink" title="设置方法的注释模板"></a>设置方法的注释模板</h2><ol>
<li><p><img data-src="/images/idea%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/xjalmy8dg3Y5WtQ.png" alt="image.png"></p>
<p>也可以选2，先新建一个模板组，而这里是直接选的已经有得user组，然后添加template</p>
</li>
<li><p>根据自己的习惯给模板取个名字，填在Abbreviation里面</p>
<p><strong>模板里面开头是没有&#x2F;的</strong>，加上斜杠如果在方法体外写注释，变量名和返回值类型获取不到显示是空白的</p>
</li>
<li><p>点下面的define设置模板生成的地方，选择java下面的所有，或者选everywhere也行</p>
<p><img data-src="/images/idea%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/TmfWIo75LX3dqcQ.png"></p>
</li>
<li><p>右下角的expand with是模板补全的按键，可以根据自己的习惯改一下</p>
</li>
<li><p>把模板贴到文本框里面之后就可以点Edit variables了</p>
<p><img data-src="/images/idea%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/U8CyvX5ElThioqa.png" alt="image.png"></p>
</li>
<li><p>保存之后可以再一个方法前面&#x2F;** + 回车就行了，这就是为什么我名字取为**</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* </span><br><span class="line">* $description$ </span><br><span class="line">* </span><br><span class="line">$params$</span><br><span class="line">* <span class="meta">@return</span> $returns$</span><br><span class="line">* <span class="meta">@author</span> muggle</span><br><span class="line">* <span class="meta">@since</span> $date$ $time$</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>params对应的表达式：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">groovyScript(<span class="string">&quot;def result=&#x27;&#x27;; def params=\&quot;$&#123;_1&#125;\&quot;.replaceAll(&#x27;[\\\\[|\\\\]|\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;result+=&#x27;* @param &#x27; + params[i] + &#x27;\\t&#x27; + ((i &lt; params.size() - 1) ? &#x27;\\n&#x27; : &#x27;&#x27;)&#125;; return result&quot;</span>, methodParameters())</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件</category>
        <category>配置</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot在IDEA中的热部署</title>
    <url>/2020/03/15/spring-boot%E5%9C%A8IDEA%E4%B8%AD%E7%9A%84%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<blockquote>
<p>热部署用起来真的很爽，节约了开发的时间，让开发调试事半功倍，下面就来介绍一下热部署在idea中的热部署</p>
</blockquote>
<span id="more"></span>

<h2 id="开启idea的自动编译"><a href="#开启idea的自动编译" class="headerlink" title="开启idea的自动编译"></a>开启idea的自动编译</h2><p>打开顶部工具栏 File -&gt; Settings -&gt; Default Settings -&gt; Build -&gt; Compiler 然后勾选 Build project automatically </p>
<p><img data-src="https://i.loli.net/2020/04/01/VHKm5DiQIF1cwTs.png" alt="image.png"></p>
<h2 id="开启idea的热部署策略"><a href="#开启idea的热部署策略" class="headerlink" title="开启idea的热部署策略"></a>开启idea的热部署策略</h2><p>顶部菜单- &gt;Edit Configurations-&gt;SpringBoot插件-&gt;目标项目-&gt;勾选热更新</p>
<p><img data-src="https://i.loli.net/2020/04/01/DFohgObmEYvM8In.png" alt="image.png"></p>
<h2 id="在项目中添加热部署插件"><a href="#在项目中添加热部署插件" class="headerlink" title="在项目中添加热部署插件"></a>在项目中添加热部署插件</h2><p>在pom文件中加入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>配置完之后，静态文件有改变直接在浏览器中刷新就能看见效果了，不用再等待项目的重新启动了，自从用了热部署之后就在也离不开了﻿ ε≡٩(๑&gt;₃&lt;)۶</p>
</blockquote>
]]></content>
      <categories>
        <category>软件</category>
        <category>配置</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>sublime text3下载插件</title>
    <url>/2020/02/26/sublime%E4%B8%8B%E8%BD%BD%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h5 id="1-在github上下载Package-Control的安装包"><a href="#1-在github上下载Package-Control的安装包" class="headerlink" title="1.在github上下载Package Control的安装包"></a>1.在github上下载Package Control的安装包</h5><p><a href="https://github.com/wbond/sublime_package_control">https://github.com/wbond/sublime_package_control</a> </p>
<h5 id="2-打开sublime存放插件的目录：在sublime菜单栏-gt-gt-首选项-gt-gt-浏览插件"><a href="#2-打开sublime存放插件的目录：在sublime菜单栏-gt-gt-首选项-gt-gt-浏览插件" class="headerlink" title="2.打开sublime存放插件的目录：在sublime菜单栏&gt;&gt;首选项&gt;&gt;浏览插件"></a>2.打开sublime存放插件的目录：在sublime菜单栏&gt;&gt;首选项&gt;&gt;浏览插件</h5><span id="more"></span>

<img data-src="/images/sublime下载插件/image-20200428221639527.png" alt="image-20200428221639527" style="zoom:67%;" />

<p>找到下载的文件，解压，将文件夹重命名为“Package Control”复制到sublime存放插件的目录</p>
<h5 id="3-https-packagecontrol-io-这个被墙了-下载插件不下来，把下载链接改为国内的"><a href="#3-https-packagecontrol-io-这个被墙了-下载插件不下来，把下载链接改为国内的" class="headerlink" title="3.https://packagecontrol.io 这个被墙了 下载插件不下来，把下载链接改为国内的."></a>3.<code>https://packagecontrol.io</code> 这个被墙了 下载插件不下来，把下载链接改为国内的.</h5><p><img data-src="/images/sublime%E4%B8%8B%E8%BD%BD%E6%8F%92%E4%BB%B6/LGq7aPkejfiBXRz.png" alt="qwqwd.png"></p>
<p>修改User文件下的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;bootstrapped&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="string">&quot;channels&quot;</span>:</span><br><span class="line"> [</span><br><span class="line">  <span class="string">&quot;https://erhan.in/channel_v3.json&quot;</span></span><br><span class="line"> ],</span><br><span class="line"> <span class="string">&quot;in_process_packages&quot;</span>:</span><br><span class="line"> [</span><br><span class="line"> ],</span><br><span class="line"> <span class="string">&quot;installed_packages&quot;</span>:</span><br><span class="line"> [</span><br><span class="line">  <span class="string">&quot;ChineseLocalizations&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Package Control&quot;</span></span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-重启sublime-text3"><a href="#4-重启sublime-text3" class="headerlink" title="4.重启sublime text3"></a>4.重启sublime text3</h5>]]></content>
      <categories>
        <category>软件</category>
        <category>配置</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo一键部署到云服务器</title>
    <url>/2020/03/01/hexo%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote>
<p>&amp;emsp;&amp;emsp;之前折腾了好久，用Rsync，ftp，stfp都试过了，都没弄成，在网上看的教程很多也是基于git的，也就是在服务器建一个git的钩子，指定一个目录作为远程仓库地址，可以通过ssh连接，然后在本地可以直接上传，最后才选择的这个方案。在成功之前踩了好多坑，配sftp的时候用百度上的坑爹教程，导致服务器都连不上，最后还是选择则了用git做仓库的方式来上传，这个教程很简单，相对于其他的同样的方法，只是不知道会不会有安全问题。</p>
</blockquote>
<h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><h3 id="1-配置Git-hooks"><a href="#1-配置Git-hooks" class="headerlink" title="1. 配置Git hooks"></a>1. 配置Git hooks</h3><ol>
<li><p>创建Git裸仓库</p>
<p>blog.git作为远程Git仓库，Hexo在本地生成的博客静态文件可以通过push与其同步。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/blog.git &amp;&amp; <span class="built_in">cd</span> ~/blog.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure>
</li>
<li><p>在hooks目录下新建一个脚本文件<code>post-receive</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> hooks/post-receive</span><br></pre></td></tr></table></figure>

<p>   <code>post-receive</code>脚本将在blog.git仓库接收到push时执行</p>
<p>   脚本非常简单，就是删除原有的&#x2F;var&#x2F;www&#x2F;html&#x2F;blog目录，然后从blog.git仓库clone新的博客静态文件</p>
<p>   <code>vim hooks/post-receive</code> 将下面内容写入<code>post-receive</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">rm</span> -rf /var/www/html/blog</span><br><span class="line">git <span class="built_in">clone</span> /root/blog.git /var/www/html/blog</span><br></pre></td></tr></table></figure>


</li>
<li><p>给post-receive脚本执行权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x hooks/post-receive</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置好之后可以测试一下，就在本地clone那个远程仓库</p>
</li>
</ol>
<h3 id="2-修改hexo配置文件"><a href="#2-修改hexo配置文件" class="headerlink" title="2.修改hexo配置文件"></a>2.修改hexo配置文件</h3><p>修改hexo根目录下的_config.yml文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  repo: <span class="string">&#x27;root@服务器IP:blog.git&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="补充一点"><a href="#补充一点" class="headerlink" title="补充一点"></a>补充一点</h3><p>如果之前有在同一台服务器上配置过git的裸库，需要在用户目录的<code>.ssh</code>目录下，将<code>known_hosts</code>文件中的主机记录删除掉，否则可能会报错。</p>
<img data-src="https://i.loli.net/2020/04/25/Nk1QSac4IE2TxRz.png" alt="image.png" style="zoom:80%;" />

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&amp;emsp;&amp;emsp;这个方法和其他复杂一点的方法区别就是，没有专门建一个git的用户用来上传，就直接用root用户上传，就自己用的话应该问题也不大🤔</p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>zerotier代理局域网流量</title>
    <url>/2023/09/03/zerotier%E4%BB%A3%E7%90%86%E5%B1%80%E5%9F%9F%E7%BD%91%E6%B5%81%E9%87%8F/</url>
    <content><![CDATA[<p>在ubuntu或debian下安装zerotier，并代理局域网所有流量</p>
<ol>
<li><p>首先去zerotier官网按照其安装命令安装zerotier</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s https://install.zerotier.com | bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>加入zerotier虚拟局域网</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zerotier-cli <span class="built_in">join</span> &lt;network <span class="built_in">id</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启流量转发</p>
<p>临时生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1&quot;</span> &gt;/proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>

<p>永久生效：</p>
<p>修改 <code>/etc/sysctl.conf</code> 文件，将 <code>net.ipv4.ip_forward=1</code> 注释去掉，并运行下列命令生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<ol>
<li><p>添加路由规则</p>
<p>只需要修改第一行的两个变量值，第一个为物理网卡的名称，第二个变量是zerotier虚拟网卡的名称，可用<code>ip addr</code>或<code>ifconfig</code>查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PHY_IFACE=eth0; ZT_IFACE=zt6ovszj4d</span><br><span class="line">iptables -t nat -A POSTROUTING ! -o <span class="variable">$PHY_IFACE</span> -j MASQUERADE</span><br><span class="line">iptables -A FORWARD -i <span class="variable">$ZT_IFACE</span> -j ACCEPT</span><br><span class="line">iptables -A FORWARD -o <span class="variable">$ZT_IFACE</span> -j ACCEPT</span><br><span class="line">iptables-save</span><br></pre></td></tr></table></figure>
</li>
<li><p>若是使用的PVE下的lxc容器，则需要再PVE的shell中修改该lxc容器配置文件，加上一下两行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lxc.cgroup2.devices.allow: c 10:200 rwm</span><br><span class="line">lxc.mount.entry: /dev/net/tun dev/net/tun none <span class="built_in">bind</span>,create=file</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​	因为系统重启后iptables中的内容会丢失，所以需要每次开机对其进行设置，下面有两种方法</p>
<h3 id="一、使用cron定时任务"><a href="#一、使用cron定时任务" class="headerlink" title="一、使用cron定时任务"></a>一、使用cron定时任务</h3><p>将上面的路由规则写成一个脚本，取名为<code>route_config.sh</code></p>
<p>然后再定时任务中加上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@reboot /path/to/your/script   #脚本的位置</span><br></pre></td></tr></table></figure>

<p>当然，要给脚本赋予执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x route_config.sh</span><br></pre></td></tr></table></figure>

<p>这样设置之后每次开机就会运行一遍上面的脚本</p>
<h3 id="二、将脚本放到系统启动目录"><a href="#二、将脚本放到系统启动目录" class="headerlink" title="二、将脚本放到系统启动目录"></a>二、将脚本放到系统启动目录</h3><p>为了在系统启动时应用已保存的规则，我们需要创建一个<code>iptables</code>启动脚本。首先手动运行一下上面的路由转发规则，然后创建一个名为<code>iptables</code>的文件，并将以下内容添加到该文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">iptables-restore &lt; /etc/iptables.up.rules</span><br></pre></td></tr></table></figure>

<p>保存文件并将其移动到<code>/etc/network/if-up.d/</code>目录中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mv iptables /etc/network/if-up.d/iptables</span><br></pre></td></tr></table></figure>

<p>赋予该文件执行权限：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">sudo <span class="keyword">chmod</span> +<span class="keyword">x</span> /etc/network/<span class="keyword">if</span>-up.d/iptables</span><br></pre></td></tr></table></figure>

<p>这将确保规则在系统启动时自动加载。</p>
]]></content>
      <tags>
        <tag>zerotier</tag>
      </tags>
  </entry>
  <entry>
    <title>vim快捷键快速参考</title>
    <url>/2021/09/17/vim%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="指令模式"><a href="#指令模式" class="headerlink" title="指令模式"></a>指令模式</h1><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>:q</td>
<td>一般退出</td>
</tr>
<tr>
<td>:q!</td>
<td>强制退出不保存</td>
</tr>
<tr>
<td>:wq</td>
<td>保存退出</td>
</tr>
<tr>
<td>:w fileName</td>
<td>另存为文件名fileName</td>
</tr>
<tr>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>取消行号显示</td>
</tr>
</tbody></table>
<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>dw</td>
<td>删除一个词</td>
</tr>
<tr>
<td>dgg</td>
<td>删除至文件开头</td>
</tr>
<tr>
<td>dG</td>
<td>删除至文件末尾</td>
</tr>
<tr>
<td>dd</td>
<td>删除当前行</td>
</tr>
<tr>
<td>d$</td>
<td>删除本行光标后面的内容</td>
</tr>
<tr>
<td>d0</td>
<td>删除本行光标前面的内容</td>
</tr>
</tbody></table>
<h1 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h1><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td>p（小写）</td>
<td>在当前行之后粘贴</td>
</tr>
<tr>
<td>P（大写）</td>
<td>在当前行之前粘贴</td>
</tr>
</tbody></table>
<h1 id="撤销-x2F-恢复"><a href="#撤销-x2F-恢复" class="headerlink" title="撤销&#x2F;恢复"></a>撤销&#x2F;恢复</h1><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>撤销</td>
</tr>
<tr>
<td>ctrl+r</td>
<td>恢复</td>
</tr>
</tbody></table>
<h1 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h1><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;text</td>
<td>在文档后面部分搜索text</td>
</tr>
<tr>
<td>?text</td>
<td>在文档前面部分搜索text</td>
</tr>
<tr>
<td>n</td>
<td>移动到后一个搜索结果</td>
</tr>
<tr>
<td>N</td>
<td>移动到前一个搜索结果</td>
</tr>
<tr>
<td>:%s&#x2F;origin&#x2F;replace&#x2F;g</td>
<td>将所有origin替换为replace</td>
</tr>
</tbody></table>
<h1 id="光标操作"><a href="#光标操作" class="headerlink" title="光标操作"></a>光标操作</h1><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>w</td>
<td>以单词为间隔向后移动</td>
</tr>
<tr>
<td>W</td>
<td>以单位为间隔向后移动，并忽略标点</td>
</tr>
<tr>
<td>b</td>
<td>以单词为间隔向前移动</td>
</tr>
<tr>
<td>B</td>
<td>以单词为间隔向前移动，并忽略标点</td>
</tr>
<tr>
<td>G</td>
<td>移动到文档末尾</td>
</tr>
<tr>
<td>gg</td>
<td>移动到文档第一行</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>软件</category>
        <category>使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu安装系统后硬盘只使用一半问题</title>
    <url>/2022/09/19/ubuntu%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%A1%AC%E7%9B%98%E5%8F%AA%E4%BD%BF%E7%94%A8%E4%B8%80%E5%8D%8A%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>ubuntu server 安装时默认使用lvm进行磁盘管理，只使用磁盘空间的一半，如果要把另一半也用起来，需要如下处理:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用以下方式将空间全部分给这个盘</span></span><br><span class="line">sudo lvextend -l +100%FREE /dev/mapper/ubuntu–vg-ubuntu–lv</span><br><span class="line"><span class="comment"># 重新计算磁盘大小</span></span><br><span class="line">sudo resize2fs /dev/mapper/ubuntu–vg-ubuntu–lv</span><br></pre></td></tr></table></figure>

<p>其中<code>/dev/mapper/ubuntu–vg-ubuntu–lv</code>可以通过’df -h’查看</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>《摔跤吧！爸爸》观后感</title>
    <url>/2020/06/25/%E3%80%8A%E6%91%94%E8%B7%A4%E5%90%A7%EF%BC%81%E7%88%B8%E7%88%B8%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="ba6cf64838c441af18b6e167d55dfe2d151e85516310f94c9d0136fca6aa3d2b">99b23c07cf5459d82b841027c3c80769d0f7a6e686739cd75293781e6406538097982004ec16c3791d29ef42f2800f31f1795fb6981b6cfdd79ee08914a56c20e8c44b72ac4fa8153d3bd5dfab6010c9a4407f36a0eef85fc54f0dd244f64f5e9e6092ea29751a9506563679310075cf829db26ae55bd828a56af710b7df239541f513c05e4de9a86c8a28faa6af301c597f3d068da9322ca0d527447ead38d736387fd07a702391ff3e43c91a68ecf98aac99f64d15341a489c282804a9bfa0f6d84be7fe856d1d828774b4ba3b463df33b96fed6f2fcfc83a343b3eac529be0b36df2453bdb52a317377d9a082deb98a96bbe0b51544167066f97fd0a7fd505791ad295bc52faa5920c9142ecb05c7d6d4a14532df653442eb5b4a103e7b4361f5345a17d4af9f544af195fe030f4c12270dcb80f9d5844f62e655a8790e6319931f815fd3b6ce3608b85973459e6de6b0df6d113d07d445aa97b29eae21fbb48900e025cbe9ee666dcbdc7e1777e41ee4f65d707fd1504ccb96a77ad6303130dc4321dd0e3ae73857674bc77aee92d696c0b1a6a96da938aaa36558a622c629a5ceddd755011eda72c206ddb1d0892989851b6b7d640f2af4c14cccbca14df559994a0209719383e958d614edeadcbd83934597e2aee942916efb9441307035ca0510d04d793ddde1d4a66137885d3562a807de01574edcfdc24b3ca269519ea1c1ae989aa8842f6d643ced3fa16620a7618be9d7bd639916ee9dc1b871767e245f092b0c4fdf456595c19fa1f09c8120d6f684282d562915cc022907d1569af81423ca9dd37310f4aeaf9b81176f2ac8c264944102e4fbef1653ddfe36c04c25b203120819125e5b858c94e3e190dfc275cf79712ccdf229c890bf0dbeb297c04958a601dce3f191af9c954f39941d88aeeb15e76328f987911124cf0bca897d4971ef35b5c97c3515bee836d4c54b0ef7cb87b427007cd06c4cb8353cf1c3f15122ee2f3d53fbbb5f1bb2368715edb5834c17008b58214aced01c9c7093c052cdfd777593ea3e4f3d2699e8a8bd51f04aedfef23d59239fa8d3ffa172f525537c8619458dabd3cf4ea30abcc13bbb7a29e443df40b1b61eba6ab55e6f763b11970a17367d9fd663e5d37b3e7cda975414d93067717799f7d76e9aaf3e079adffc692355c1ff591ec18b077816d9235a38c98f12baba3e77f480152333dd746ff22c0b2a237c418cf267eee31e48af4faa79d9b9d82198e8ef251c7c6ee22a3b9fc3d003af258934e36668d687c9d874c7f4cfad7bd0c1e7e93555c4d8989740f5cdc3c8d83445046b50853d40a26010bab9eeeae515234d0d8f86b8a017a1d02da6ff098c332bae501e70c03a3cb0730e7b11f41f62a5ceae8ccb9eb08298f441a55c5d09da088c9c0fdc7f2b73058fe4ff7733be1e2fe10e14efa9442829b1f95a0b577c891bf18d15e33f253d8ceb221f00051da5d873136d1e2c17add037d39283db4f9b420c7fc8e71560ac6438cda3c626c6165045b350531ef014104023476a1601b4aeb3d9c556c85b09819ad4b6ccb66d9ac28c07cc532109e7104fd3fe90f4abaebbf2e838da990a1998737e51ed552714ffb6c032a989ddc8ec6a0fe8e829b5021114f8a8a59be80d26db9de5e4380e478f913fccc5f7cd6681cc59602c46f65eecdfae184c33189f269b4780dc998e244f4bca25211a58c9bfc67d4a63fb81c651365dbba961dd14f01e8e4f3fdb576c7f26a62642262402d45d82c61ccdbbb4c6c889f0c82d2bcad3666bb97044468c0930c2aa1f49b958a3d4fa9dc13e1ccf3b59435b2966b11f91857573351be91c3fa3e6aa2dcd9122e5fac87bd731fb5dd9f7ef78c3ab146861b8fe9186731556871666638718510c13e776173a8332f6cb5b1df6b2c5acbd5d09651b5052c8da155504eb0768f6be4bed43d4f33510088d9ea127c4bcdcfa6036c9200f58d69060a87a7175daf89cf0522b5e599e946f48233e5fdcf139d504942062969fbc07f6bb298e4f9864719ae0910e4d11d297321b344a0eb6d216aa81e491d27133e2a970fc93d4affcbacc1a5a38524c9cf003cb22198d0b916290eec2e94c38d249e24f9217c83d2ed45c91cfc1040dff1704c0697eee29ac59e6ce99f1898da6fa7873245e392f405606d938c257d0be62662a8bfe94d793e8552e06bb5b3cfbc5705eca37e66b6328454d105a6226acf76ebbc1d1afc4fc3e6464ccb3198c731b4a0d7978297e31333c140a497f65612f41418306dd3fc8f61f1d48f2c1046f9d966d84b755d6dd2bd89862196f6f7829625be4889bb79bee6166673bae2a9c50ac56cc5b3749585686b48f3673e309750330734de18b68f0ece7fbc38ab3c939d5e67c8a91f5c01d67f6e9f019797a0cf9ee795dab0a9c50b816c58e114243798ef2dcf98a12fd30421a3804f5e1c63710bd685dba15a58084e52ffeef41957ca1d7a06abe21a608ef1f29521a4408ac914a56395896081d75345c8e8ebccbcf8e5e29f00d2979bc6187692d6010895681ded09b42e85f8beef27ae13923928c3b5ebda5a03058088805f2544e5fc47957f8ce63505bebcab159f53eb09cd99a8eb0e468350b5112fe352d64f46cf0a9adca02cd920691b5a11bc8b46cd9fed78fd4db2663352fc90dcdaa203a1ac318e6b923683f4f89135e653f77288b47a49a84a65dd1d4670c3bda5f4db77788fe58695692ed0f07036b2525588bbabc3024ce7f72f3d17d5d8c4b849a319e0d6c577e2dab60d18a6acd34748000b790ea3e9becc813b743897e2cff6ecd9c8783553e3c442785173d05c4ec590cd81faa979c77cb204cbf2baac9acb03d79bbb2510ac69887a8ece35c3d698a0b9ff25128b09157b6e6d88275ddbc8757a780d18354039ef471549fd6ca4b44378f715b2b18a5052b1c2b9533b62c5b5ea2c6ea33af814871104657fcac8626b05c55b34abcd1aa4d5d498026cc956b8ee8332120564f9afd039642684ce51c8bcaa562e055f92abf66d0e231f974a668919c142104d6d0054fab38bc1fac2f610614545918e3429d6d0e6aeb328ced59e7b75541f7c7be9a2f19290914f1e227d38b895d44be4f1ab4a441e3c5b7a57c1324946d3bba769816a46e83d1d13524685af12bd311462cda394e4b47e335b6ebf0c5308cb7e6d359937167aeb323bc3b353a0958ff941a0e06e0907a8bd822c3227ee02e10a2e164e1337165c3d012ae63fc6783ca1672f0984e1620d16ac9206365681ed245bc0631ef692b7ea3347ffc968cfeb450bcdd2be20f431bc8f4fd18aad353929631b98a61d7e7eb2319c693ba4096ab98cb22b34cb0f2b3374eba2a6bccfc33014f8c796ae9dc697c1a32ad9835120615fa0d56e243daa79ed049facbbdc52d3c87fd7ff17940d6ca8f3c5f965071c22e198ce4c21541121f23c830c0c71d3550e110ef99d2a95c16adefb818f05ad570847cbdb835be0fbd2a639ee85d1a2ada8a522b77b481d00ffa933868e5c294d90567b53acbdaae0301e76580a586801d9221debb048e8e05e5b1a1201df70bda26a3baf6a0132c110e0c3f7529550e43dc9c52321efa8e6ccdc84652e15c75c47410c093f2868028df71de533ec8b524cfd05b28c1c27141db532a79727ba246b6897e7d1f66b14e6fdbb20c0ea677fad8c08749ce08d7c386ef657777f47f0146df5ba84cc83794f847e9208105c9daeab2eda2bacf094a1d4a1d946a7d9ccd23af8beb19c64c8befa7d4eb7fb8761a330aa39686ac4f44cfd329ac819b1d32e416e06abda042ef3c579ec2c871e0156e785547bcbdc347493d69734fe19fae407d2d502f92783a9c4874969e67229adc7322a9b0179834107c2db503c3d61aa7c4c819f9b0872b0acf1574335509d574e8a5bd24a926e516fd04f05befe30f543e93e31b1805638f0590419cd99bfbb46c48982692bca00561f921782cc964089074f3fe50a7c931652cba1b403442e31f0c4605ec4e18243f555531f06989bf30e5d6db707592da5db57dd8f9bdc654717ca0688978b61ff8e97bb70602d70998da4e8c8d6389970f59f0bfc448d1445ef54d6905cb72131ea62827c9e03a808e1b29f61b368aff3c8c5a67c8dfa364ec9d12ed8ea77bd98b8fb1e0ae80a1cb1438307f3d28efd54384ea06ce31cdd66a027ecb72b27d966a4a7fe64f2df2e08286e4105c40177b0dd1e9fd358d35d296291f0efa6c9526a77cd032c9c06dff6969e490a4c10f59e86d06a994660e932a5add3ae683b3d023b6bbed6332abf249ebd393e71272e26e78a3bbfd6c483e17a80decaf944061a9f60259241642470a03160942fbb96acc35dbfabe41559d7019ced2d95759aa31dae820288ac11e30198b798d90ed7b1cf6adc5c40c05e1ff08e7767bd8d25815144ec0d480a8c193553891acf2e8511aaec37be05c48dca000d463600a45b17d48253ce40ee426d0e0a24c78a819ce340c0a197768b5364eb2bdb82ea1347c8b94c43f3ca3e54b1bafc7d8e20664dd215fe342b9426ebb170a294b3448de9e0210ec7d0f0e691cdc777d0e50a020ebbdc549f5981930ea50a2155956db2d277fefd0c14e13b8e0c05c1c61c3e4344ed3ed78c0d845cc30e48a33d6d97a14d7690529cf6802e1bbdc8b26d7ae61692520474fc1992a1e6de664e7f72477d460377bb66944bb81bb9b0240ee297fa30b87735737dfead64f67d84954340e5c5b1618b1facd11f7ae6dda0e9c634365838c227f9843549f3d8b0505e22a5e1dc372b9d163d6cda3e1edee3c33ea96044e2bf7b2d1f534f3e30be77204b73f4cbaff8b517f94b9ff36a995f597c8dc9b76295c229095083f1751bd35260cbcb8c4cc51602f9fa9ed6efbb9c9e27a5302435d40e9e5a1a0016bb30655f5eeaf74caa200836c4f95a3935839cb4d10a13af143aaa2accecf73f0fa2c3ff695beb3e0d12ead2c63e66af5f70893295a448288f0b25f9e165cf8235e50745b5710d52bf45f9dc52b1fc5bebfbab9b380f09bfddeed4e829affab8491211805b11859069b8c9518dd5f620a0d8297ef8141f39fbfdd97215aa5ec40f6034f7de01987245147411016278d11c9358db9432b3c2bb1c3853523cb7f6336563bf9a904fb64dd0ed6d4c6276375acb94a83215996690cf52dde592dc5aa2ba0a587d6635592d826a0b13f43208a7fa046ca157145b058d406abb679f67922cf58f8d23ce3d99b6588cfbf01fd543d35319a69580d9d97f711cc1e6507413b35e9711e088e5cc0c997585d5b5845feec064dfd53600ffb177ddce4d1365d8c690abaf24a0cb2c3265a63978b9cfc94ee4ef42bdc84cfeebd03f11917da70722ef638eccdeb42f703ee5e046048c937f540cb0b284fb4b229baef1cc81bd8c231dfad1fcc471d7a34f57db15aadfaa9b39c9531fe2b0b0edc5cc02ee775c93adf35b3dd30b0611c856307a81154ff4edaa6620fdcef48b9c93da31d405756893080cf09cf5a5b95a4d4069fc583f099af96a02d4c777c150eb7eda6f4ca6b50715f3de896f40fd6d790d07ae26d7be04a8d1a99556a4f6badee77e99c39537cf141b79d0d44a982d553315871240b4d22687c4893572a6eca772f217b82c104a0d2c1b5741b21b192e9785ff9aa340580e834bfeec22ca42e47830fc9ce22eda7dbf502f91b50679a56432d152d956afc0fe7cf40950be20d2debf135913f74e52c3e6f6b8f60e8b8235fcf4f49b5ba3635bac57bdeb6c6f80f2f55a8c8f43d642925fbf5dd9062595c661002fbd32bca5ba5aa4850ddcc67762ee2e69e64ed5502f60f234d06a88d3beb10892414a47bce5b40239708d8018cf08e688e90624b4acfda12c51ac286b732b6407a1af511a984162bf67ec6d2f1948324f3f2b639cd1dfd1deeeaf406a853786b0c09878d37f45ecc0744a596e177fc03cc1a4ad9d1cf04f883c9e13fd1c1e0ba05e437bbabf796eb767d04f2409a4f040a54dfdf77baee1f1ecb174fda0556a07ac4d63c7feeb179979a2395279cad436b8b281d4d2a54fcf58ea08ad06131902a33658ccef32b16815a0624f2946aebd71459f430f31522b1d1a60a205d11719ffdf535e819c9bbfa1150f9df3ea21510d74cd8ee04256aa5f19285903b63fb247ac96215f48af31298c4348173415ca252c2102dd471c69ceaf2b65d3a44a61e4ace14a3c346e19d1005f7a58e24ac41f275c7dfbd408da1ef610c1fd05a37c7adae1e95fde580c855317e63c53b0ae02e681392e84536576250ae9eee8cad2692eddeed9c4b0dd4eca6402db6dc8b52c4754d1b73e286bb370f341b19c2610ae624647aa0354ee86819a3f5c0e40cd4aa1a0a9b5c9346785d4d2600efc7b5b19a83535609c3cf13c0f1fa205ac577857c9dcad44302f8bd9bc9d540995b1663aec92bf0440bbb942deab71f9ec5d7740299a9a672fb5b9216402f1095e2c53026d43e1abe52c183a521cb7c33116c0608f50a2d9a0aece3edc2a4c55f0942e7a5fc6a6ac97bab4796547571570f49af8f2c9424bec9e9315eb13080b534b7a888bd89f0a76be75b831cdaa402d0b9ef732deead31c5a7ff1dd4d12b227d5a72d4402821820b79d5824c5266127f287bbbf54ab92aca5ae9b2e1cfa338833d45e77b3532a55868a61e655b685dddf57da16f5aebbc833f9cadde0d301e5a8d1e9d3f8790fc8e845bf4d22ce3b981f4069481bf5a94b843be05e48b58435afa3ffb9f5f4a0bdfbdfe8e469320c94fdbbd21586addb0ef9553621af6324b08cfe45a55c61be00900594ebda72d5824a10a31160f8646fbbecdb95c318d5a5f6b56686628130bb98a971bf0b12065b6750da366057a3a4d5837ef0efdbc314bf3960b6d283d8a214d4f0027d9c2cda97ebfbd8edfe49ffd580956c27cfd7ad53360a2c4727e6d5b5ae0dd56fd81b7e58d2dfdc97dddc33bf27eb11c4097ff9b19b119c3ff9b527fb3f4e8f22a45904fc2135ccc20756513f799e7ae4ecd88638634c5e04f59ff09eadfa9fcb3425543a643a08d0f6e0b24a045d2225ac66cc5aa240d7aa33c16d3d2fa96af1773b9cc39bdc79facf49357d501f6b5ca6d6f47c33bd548108dbf1fa0f5e81f3f52f54d078d004017d9df0564ae9ed9231d26798302412b7e1aa3b6d5d0ef51945f451f0e95c157fe8b64b03a06962e5d5a397738e6b020ce9be71a5679e97940f974f0ca39b4c3ff2a81b24a9eeda9fac2e536b8c074bb289767d7d37f5faaf79e9f02304307869ed7539b2ab12bbf0906db8f890c0837b41d908d4b97e27db5ab33e7680876994641d8b44a43d4874bf239e3191575fcc6a9122370a5c1c94fb19229078317dfcddf4cb6432381d4eebd33c4fd9a007dc4b9e296411c12b768423d89c770d3905058</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码进行查看</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>感悟</category>
        <category>影视</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/2024/08/07/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>中介者模式也称为调停者模式，它通过一个中介对象来封装一组对象之间的交互，从而使这些对象不需要直接相互引用。这样可以降低对象之间的耦合度，使系统更容易维护和扩展。</p>
<p>当一个系统中的对象有很多且多个对象之间有复杂的相互依赖关系时，其结构图可能是下面这样的。</p>
<p><img data-src="/../images/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/IMG-20240807211323820.png"></p>
<p>这种依赖关系很难理清，这时我们可以引入一个中介者对象来进行协调和交互。中介者模式可以使得系统的网状结构变成以中介者为中心的星形结构，每个具体对象不再通过直接的联系与另一个对象发生相互作用，而是通过“中介者”对象与另一个对象发生相互作用。</p>
<p><img data-src="/../images/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/IMG-20240807211305203.png"></p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>中介者模式包括以下几个重要角色：</p>
<ul>
<li><strong>抽象中介者（Mediator）：</strong> 定义中介者的接口，用于各个具体同事对象之间的通信。</li>
<li><strong>具体中介者（Concrete Mediator）：</strong> 实现抽象中介者接口，负责协调各个具体同事对象的交互关系，它需要知道所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令。</li>
<li><strong>抽象同事类（Colleague）：</strong> 定义同事类的接口，维护一个对中介者对象的引用，用于通信。</li>
<li><strong>具体同事类（Concrete Colleague）：</strong> 实现抽象同事类接口，每个具体同事类只知道自己的行为，而不了解其他同事类的情况，因为它们都需要与中介者通信，通过中介者协调与其他同事对象的交互。</li>
</ul>
<span id="more"></span>
<h1 id="简易实现"><a href="#简易实现" class="headerlink" title="简易实现"></a>简易实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象中介者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Colleague colleague)</span>;</span><br><span class="line">    <span class="comment">// 定义一个抽象的发送消息方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message, Player player)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体中介者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Colleague&gt; colleagues = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">((Colleague colleague)</span> &#123;</span><br><span class="line">        colleagues.add(colleague);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message, Colleague colleague)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Colleague c : colleagues) &#123;</span><br><span class="line">            <span class="comment">// 排除发送消息的同事对象</span></span><br><span class="line">            <span class="keyword">if</span> (c != colleague) &#123;</span><br><span class="line">                c.receive(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同事对象</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Colleague</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事对象1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteColleague1</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        mediator.send(message, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteColleague1 received: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事对象2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleague2</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteColleague2</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        mediator.send(message, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteColleague2 received: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建中介者</span></span><br><span class="line">        <span class="type">Mediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteMediator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建同事对象</span></span><br><span class="line">        <span class="type">Colleague</span> <span class="variable">colleague1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteColleague1</span>(mediator);</span><br><span class="line">        <span class="type">Colleague</span> <span class="variable">colleague2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteColleague2</span>(mediator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册同事对象到中介者</span></span><br><span class="line">        mediator.register(colleague1);</span><br><span class="line">        mediator.register(colleague2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同事对象之间发送消息</span></span><br><span class="line">        colleague1.send(<span class="string">&quot;Hello from Colleague1!&quot;</span>);</span><br><span class="line">        colleague2.send(<span class="string">&quot;Hi from Colleague2!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>中介者模式使得同事对象不需要知道彼此的细节，只需要与中介者进行通信，简化了系统的复杂度，也降低了各对象之间的耦合度，但是这也会使得中介者对象变得过于庞大和复杂，如果中介者对象出现问题，整个系统可能会受到影响。</p>
<p>中介者模式适用于当系统对象之间存在复杂的交互关系或者系统需要在不同对象之间进行灵活的通信时使用，可以使得问题简化。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树相关基础理论</title>
    <url>/2024/08/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h1><p>常见的二叉树主要有两种形式，分别是:满二叉树和完全二叉树</p>
<h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p>
<p><img data-src="/../images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/IMG-20240804202252900.png"></p>
<p>这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。</p>
<span id="more"></span>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。</p>
<p><img data-src="/../images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/IMG-20240804203414801.png"></p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
<p><img data-src="/../images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/IMG-20240804203513249.png"></p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p><img data-src="/../images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/IMG-20240804203536738.png"></p>
<p>最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。</p>
<h1 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h1><p><strong>二叉树可以链式存储，也可以顺序存储。</strong></p>
<p>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</p>
<p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。</p>
<p>链式存储如图：</p>
<p><img data-src="/../images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/IMG-20240804203646280.png"></p>
<p>链式存储是大家很熟悉的一种方式，那么顺序存储是如何存储的呢？</p>
<p>其实就是用数组来存储二叉树，顺序存储的方式如图：</p>
<p><img data-src="/../images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/IMG-20240804203753180.png"></p>
<p>用数组来存储二叉树如何遍历的呢？</p>
<p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p>
<p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p>
<p><strong>所以大家要了解，用数组依然可以表示二叉树。</strong></p>
<h1 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h1><p>二叉树主要有两种遍历方式：</p>
<ol>
<li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li>
<li>广度优先遍历：一层一层的去遍历。</li>
</ol>
<p><strong>这两种遍历是图论中最基本的两种遍历方式</strong>，后面在介绍图论的时候 还会介绍到。</p>
<p>那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p>
<ul>
<li>深度优先遍历<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
</li>
<li>广度优先遍历<ul>
<li>层次遍历</li>
</ul>
</li>
</ul>
<p><strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，只要大家记住 前中后序指的就是中间节点的位置就可以了。</p>
<p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p>
<ul>
<li>前序遍历：中左右</li>
<li>中序遍历：左中右</li>
<li>后序遍历：左右中</li>
</ul>
<p><img data-src="/../images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/IMG-20240804204128746.png"></p>
<p>深度优先遍历通常采用递归的方式来实现，也就是实现前中后序遍历，使用递归是比较方便的，<strong>而栈其实就是递归的一种实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。</p>
<p>而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>令人心动的offer观后感</title>
    <url>/2020/03/12/%E4%BB%A4%E4%BA%BA%E5%BF%83%E5%8A%A8%E7%9A%84offer%E8%A7%82%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="6c1c458ce88f72fc88400a51cf0f9e508f7be0481dc8d14ddcead040ebb659c0">99b23c07cf5459d82b841027c3c8076910c6b0874ecc4cc89f084b05378807a14d57e8a9183ecbdf7499f8688395bde2cf48f1cbddaef63990e002c1c48b705782cebdc97da3a34b3c60a858a008620cf47aa72953cbdc6abc21d1c81849e1c932a86eff0f7a886ef3d4eb706a90d3cd8e68732af161c4b077c158c72f78d34788c1c20baa64ebd629e0b7c20977583260377175fa5146304bf0bf67c6ca45a4f8206bd5c98a61ead3c796a323cf60e5fe2560b1d4281e349e24e8a203bb2472881f890b10402eedf14098e37187f40b54a2e3b24c92b610e27535da73cae27ef1587d08ebd7510644960991c7668dc1d62b852fb3aa5c9603d22f24fb66e73ea4ca55d5a89e70b4dc11a2293795f4e7a33403a12401b13f96306b10d80b20f163aa37bcd21285c3de284723147968fb7b18113155101cf16e3615723ad5e5e1f6c94a563b9e19b8bab7ccfe09cb29fe5c6ca1b34e8c5cb03b63dbf9b3494c3eff25fe255ba4de24bef3ad29317fe4a57194949aa90b69b9061ae9631800e2ecfe238637b4674e299fc7de9464930dbc4ac185429260fdcafce54945ad3f40fd2dd5bd97aeadefa42a6ba21c2acdc1312af774909ae7849db2d1547afd1a4d5c02881fe4b9c1927b4e6a623610829d1393895bc2868ba0208934acb1ab6e96ab7c843782dd4e681d9ea74140f8ff87efebe604adc60680672368c1b7ce20a8f1768d83126767190d4b7cfc872c1cdf0156b9c1ff767a6507fbb6854d881bf8ee347ec72aea9ae5d4b1d200988623165849ea1f5eb039c0dec7fff66ac3b6490fafab422681ae2793b672de423d209ce3e211e4da6f2059ccb0cd838541b48e9fa61c06e6be51cf46bf339019c5fb242ed244c0ff3eeb83e5e2877f1358c71c162b43462fdb4b30935b39cc5dd6db30cc528df5960dd7cbbc162a5a29290adf93e548a7223733298fb5fae47dfa36fdaba15f7d17a7f7a842284a497622ebd916b758b03fdfaa0a343873222d220201496cdf5393834ac139d909c920a5d001a39289652f79578b42a4f6113ef3baf694af57bb87fd5af4584b458cebe8331214144b73ee82a87b2523eeb02c53a039171021a91f568d9c9bb0e88a3fa20508306c5e416f99107cd5b42912e30af847ed7bd3309c3f3b03995c9d4bc767cc6418096fd3747c4f37f13ad87d314b52622071d28ee6417e23b9ccae64d49a37d23672960b924b1b167c43259872d76a26f1eac0646da3e1708712706c870561fc5a3831fef37e890ef0d0bc100eefcc9ff9f32b26c5aebc91a6fa0d4dff3bf96d31b53648cbca11c5445c2cf47919af34ef4c62d8689641dc2683daaa9942f3b5035eee55c08d67289476924b6b27cd6d85f77bd6e1bfbbb2a2790bf423b74731cd3a97fe2b7da205507ac8f61d82d086d989b29de07eb7f917d1a47d9c348af93b6b14f357c6cf957f3bbc29edca1b5764996037d9729c693ff3512d25c8c97bec9c56205e6ccc4db068b75c07898b0f01273e1940884fac1a221dfe77548d643e7bf44914c28ed5527a8e857d70ffbb5e48ddae611af5383596854b72395caf910c767408c5343dbf54d8647c90804146b87066f4b2038ac8c41a0fc6adf04ae49743c92f0c55a16e698bdc911ad46541613d469dffcf35bf774969c49bea03cae075f978c188374b70bcc78ee23627f55285ee83f4659faf9c30d07bee1b105cc51fd79e1f1c4760e82b95c50ceee28c505c0e4697128d2d578da8a320a642b0a2bdc3474e2c291aee8acbe3d7ecc29b7f3782548a212f43c3c2fb3335269639a661f4706e1a980b5b67903d0bc6fdf5ca05765ead7420f962550b12015d9426d3b3d8c1c568c5428703970627bf4766f6f2f8c83ffbf4215bc48515b397269894ed32368ee2bcab2f6acbf9b63fe8bb3339cd85ec35a33963048b1eee8d990be3fe29eaf78381d84ac8c3252a880994708c986356c51b19d083abaa29854ede3d6ff29b8ee9c81b62a1407d9eddac15a4592de7de257b8c710c13af7265212acf96206d3df687cc4acd76d381eaddf09edfd7b0c7221ab59b14b6d5dbf61a8f98a77580e01c7771ecd3f03bf4037940d3454e08a2d39ccc10bf2556547fd343685238f9bd6ae691edfe2be40b9df67c47be23667fe7b760e24d50e2ad04376bd0a40bee5a28954e51e9879dfc0c2fd57dfa9d31698e4e7edfe42f98ee759600be605b7fcc1ea73a40d8b02b4838da1f4cc7e85f5eff5078474c190b7415c551d1172ed3d864e75663966ded6e03d1a2c7cd652e1d1f09c60762cc9c554077e1b9e564f16256b00d3aa59a159b699b85bdb8a498d6c2cdc7e6393bdda384d06fca1f1e30194c23832e550aa119d6c85bb300c14714046a29dfcd2bdb9fa99ff55f6cc9492e5f2da2ab77b9a82393aa12244a655b55dbc29340b1206aefd81f184a669a4a2b54cd9704a586597456ef90b5201d9ba8d64b54adf85c35d1fe4a96944c2ae3162d8b67c86768ca3ad5ecc1097d2a73d73cbfe8d5cfecbcaa0a99250964eb9c1103d2e45b3cc4d6d2c9f1a6cbaea00ff36301143925bc666c231a820015684dafcfb35f72206e7be6b95dd413d2d6fb3aa739ebdd13100c84094d75201566f413a7e8f43ff4b071d7322461d13bc55ee47cead8c10fa6e085e2ce40d09484b0b517746279239865fa3e2859d8b16c6fae787325bfd44c6f2bb2d24ec10b56d938bed5917d61bacd5d4c7c7c3333a313c457cc4353ec159d4a1cf751b37175c369d9ef4a7376fe80c53588d5f4427da284d0beb990e898ca0899f15a97a154353e32f4acc03dedb4033cd11ebff3f6407a92215d3d0f943c497fc804e555f62aa4c3275f6301d7d114bb989f1bbf5504b2da655759a1e71feb5acf8f9030f6ddd030f08df989706d233c99cedd39814f8c7c8538fb2db7c2024dd664efc33f9922968c481f1d9a49407ec649831b7c7ec8bdb05d81c26905c7f274cdf79724543049a7c3b1b4985d681d6580eda702334e8c6402405c90e153a939164b91bfcc8db4a2ba51ab4945ad83456f854c4352a080916ddcde13b6b281a728e6dcc876df50b1bb52bc64f0da0e10aaa2c2ae3655ab37cebdb05f34a0326af4c5cf9142c23ad931025301f1bb16ff8e0908d9d45f4ec4a0e6b244a4f98f991477ea730b55ee1a9dd7ee49f45f993a728afe1b7f2f0621eaceeaf726ef137d1981abd0e880d869c2ea95b7dfc18e4a1af50e7b7ec66309bd403996245bcb89a4e28ca6344bd6dc60b2369b207e1c3203887666568ce7aa2566b679556661107da76ff498d7f6383bec20a7d179fbe11bf9c1ebb83f21e2117759f04000b69b1d73480b7f52669669566759b562def0888ce4c4b19ea5d97f161f36252a53e9b71b763c43443015ba3d50add967ec5ae40314892cf51944df8ef2ee7d1a75ef60a3fd35104cbf894335dc93fac12500535c75197fc29bddcfc83ffe4e3c7b5acc079380408fac31c770bf4ba8ef99ef4fa76fdc3d1c875dd55306eda1edf527bdda735618b32ea3ec468769da18f2c55ddef93e76a4bab6883a4650e727cc557f1a50565de5fc959d14b46de3b6065a4c7f718d0f8f59cc8382b983714af7d0ee4f8e08fa217277b6f5d8614c704069e70ab8ddba4ab304e9c4e81b18a4597c17ea934e623946f86f4d8b21b1f5525685445fc98548ff323d666f7a811a91123d4804221f9b03d72337fe2ca72da9f13f4b48c633905b5af14cc154f4db41d8f4dd85a01d43bef30015ddbddaaeb65fd0425e25cb644b82714867db7bcb19f0a838002c1f49321f8f5ed48186bacc8f4b1db558cda0ea1e0de69bdb0304c1f1771db645ea4ed036c087257c3921fb051746a1f2f9357bc03eecbb4bb9bee4324812d5738b5285a5d4dff6d7b3b5bf1987da80d669a35d6d3a4a3ca1028084fb5052af0b600fb9e885aef815a840d69bb9303e27121e132671a1ad7d0bdae196fa935fa3b56999019232aa8172d14d53e620d8ae7a054fa2c438166f738609cf23d6fc468d9d1e9057e6e922d2cb94b71f145298dec038ee0d0abdadd5a86b2235010aca3c2d52259db5977a82f989dba62af95551fbcc7d5ff3dbf6d626f910bab2ec793309d5c1eca1024dfe74bcbf87c5d7a7ba7a96cc779a431eaa29c822045ab3ce8966e98fe5d0ef23dcea96e974b90f98aa2cadfcdbe8dfa240d7c1c7491cc203758d6d60fcfe377132f452a44b99823232369f684a9dff69df776ca902a4e808b4ece9869bd8f76f1bface7f7879b2fae365156cd070872b106291330e7c03ed33e6f14d44c63fea1ae5f8f36b92c5f0104f58b44b4af085073e62ebafb7352ccc00f18a370e38941d1b50416a11024876103ec69eed5cb6e33ecf9bc4dcc0a9f37b758c41590df301c9d3b95cba321c67ce4fefde2ca0cacbe1082027bf0e0a53c7ce08d27fcbde5fd5255592eba16956d7a3053ea7a7ba60e1f0a290c63f3cd1e4db15299ee45184c9a53f33ededc07fdb25d9bbf1507dc42c4588f7c8fc81d7ab587f1d9c848ffb6f229a828544d2995db48b6ce1fa9e5e0b7e39f5f3feccd5cc627382a76658e8d228ee35def5092179efe5f0ee0b3aac855f42c89e08557823938ce332dff15014e4f7dc4afe1927c705ed8404da1e6c7e3c2799735119a9aa375ec00dff6e6c4bde59cc96f1fdbd75915137379eda6b3046b36982aa1487bc91f0d4d1884b8a7dc07806b511d755fb307b704b84ece91bf506c7407d72e7323f0abf0947ce0df37af6fd8b3bfa8485c4122f5e6435dab2c0acc33d87d13b3b343e2471d5789a55ea495cd4455e7e637bf021c431a40f39c46831bcb91892bb7f81a3ab3c4be8c5128721500fa405a21a9cdade2e4dd9eabe2549ce1980490ceff55f22b1d2baeecadd861e267ce488a84cacdbd9cc3d5e255c4ec6a98d8b6a67287e229548124d837ebec03e20491463628dfa8d0b8abd8696ab4aab884829cfc9fcbb3071f068c0b77b441d3b208a06f555e70dfa77d55a144e43d3aebc126448446ff05dfdb12508a85baa77ceec19e76987fb5c66cbfdbc425f10cd8c741c73177401588504793cb96a1399637f2ee5159848ab74065b1f28ff4449ac1078e178e000033ac2c774307121a8daa2b16e26b68c8323b391564cf2a6a3ae68c3e14f5144525817dc981567ab818b2c4237c850eefc5f9057d75c3072ee58508852bc6069dec15cfeedc01d6c0a990da0beb12aee38fdc3f429158361ccec6541d63b56c60775470ce909e1d5f41be3072f6e8a4dc1c2d191db2124c8bff514f5f2b66621b5f88983b4662421b14ef69c7af78d3ac87e6856d9bdb4a0b56481aebcbe127236af25c9ac7fe0398ca00d0636d7f18f45279418c604986745f77d2883ef6be511a9a9647ad6d64c8dcea9dabea39658ea62c58c0d3390ddff92ad7330f871adf80b16a1c8912d101461d0aca547ea5798c7d4adc3c6d0936ac8310852b6546df35c686836047601fa6c81718985bdbd66b6cb83b8309eb01c968235d36cfe9823f6e9a94f5c185f8c8d0da21c782e7acb681fc2f5a332a733a2a520dd8ff162c7f6b31525e491165bd19e6a2b3cadedfe15b978157ed34368bef0bbed3fcb1011d63ed05cb6cdab59c62243bf199a7a4baf5a42198b7f1745c47313b97c27ae6df227f5222541962527104a411bd95a5a959eb0c65552b95673da4cccb2bfe15787f5cb87924e9d8c3708cff7512ac5b7699fe850c17c1ac1f30f7d86f76c73c67bb3cb49aa</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码进行查看</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>感悟</category>
        <category>影视</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>入坑hexo</title>
    <url>/2020/02/26/%E5%85%A5%E5%9D%91hexo/</url>
    <content><![CDATA[<p>经过两天的努力，终于把hexo配置好了，虽然有些地方还是不太满意，但也就只能到这里了，干不下去了，就这样用着吧。</p>
<p>现在是把它放在白嫖来的阿里云的服务器上，本来是放到GitHub上的，结果发现GitHub的加载速度实在是太“感人了”，我就放弃了。这个服务器今年八月份就过期了，之后不知道这个博客会何去何从，可能会自己再买一个，可能就不会再挂到服务器上了。</p>
<span id="more"></span>

<p>搞这个也算是完成了自己的一个夙愿吧，本来上学期在学校就想建一个博客，奈何在学校时间有限，当时是临近期末，还要备考，看了一下大概就放弃了（当时看见还要装一大堆东西就不想搞，不知道看的谁的教程，居然还要装ruby🌚）。趁着现在这个特殊时期，待在家没太多事，就折腾了两天，弄了一下。</p>
<p>现在对Markdown的语法还不是很熟，写起来不是很顺手，就上个学期搞课设的时候写了一点，排版还很丑（手动滑稽），明天抽空看一下练习一下吧，补几篇笔记。</p>
<p>就到这里吧。。。。。。</p>
<p>希望可以坚持写下去，不要白费两天的功夫。</p>
]]></content>
      <categories>
        <category>感悟</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>八路抢答器课程设计报告</title>
    <url>/2020/05/31/%E5%85%AB%E8%B7%AF%E6%8A%A2%E7%AD%94%E5%99%A8%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<blockquote>
<p>好久没更新过博客了，之前一段时间及比较忙，快要期末了，考试要准备，课程设计要做，中间还水了个自动打卡的脚本，闲下来的时间比较少（可能是打游戏去了），就一直没更新吧，上一次更新是两三周之前，虽然不存在什么有人催更的问题（滑稽），但是自己心里还是不舒服，于是就来水一篇博客。</p>
</blockquote>
<h1 id="1、-基本功能"><a href="#1、-基本功能" class="headerlink" title="1、 基本功能"></a>1、 基本功能</h1><ol>
<li>抢答器系统提供八路抢答，分别代表八支队伍，分别用按钮S1-S8表示，最先按下按钮的队伍对应的LED灯会亮起来，其他队再按下按钮无效。</li>
<li>当按下开始抢答按钮（reset）之后计时模块开始计时30S，扬声器会发出短暂报警，LED灯亮，若30秒之内有队伍按下抢答按钮，则计时模块停止计时，同时扬声器短暂报警；若30S内没有队伍按下抢答按钮，到了30S时计时停止，扬声器短暂报警，且LED灯熄灭。</li>
<li>抢答器系统设有清除按钮&#x2F;开始按钮（reset），第一次按下之后，代表抢答的LED灯亮，计时器开始计时，再次按下，所有的LED灯熄灭，计时器归零，系统回到初始状态。</li>
</ol>
<span id="more"></span>

<h1 id="2、方案设计"><a href="#2、方案设计" class="headerlink" title="2、方案设计"></a>2、方案设计</h1><p>电路分为两个主要的模块——抢答模块和计时模块，报警电路穿插在这两个模块之间，配合两个电路的特点，能够达到报警的效果。</p>
<p>具体结构框图如图1所示：</p>
<img data-src="/images/八路抢答器课设报告/image-20200531153300891.png" alt="图1" style="zoom:80%;" />



<h1 id="3、单元电路设计"><a href="#3、单元电路设计" class="headerlink" title="3、单元电路设计"></a>3、单元电路设计</h1><h2 id="3-1抢答模块的设计"><a href="#3-1抢答模块的设计" class="headerlink" title="3.1抢答模块的设计"></a>3.1抢答模块的设计</h2><p>电路仿真图如图2所示。该部分电路主要由74LS175和74LS20芯片构成。该电路主要功能是分辨出最先按下按钮的队伍，并将其锁定，其他队伍再按下按钮无效，同时对应队伍的LED灯亮起。</p>
<p>该电路主要原理是将D触发器输出的结果  经过两个四与非门，反馈给队伍抢答按钮的输入电平。当抢答还没开始的时候，D触发器输出Q都是低电平，  都为高电平，经过与非门之后就是输出为低电平，再将两个与非门或非，结果就为高电平，此时任何一个队伍按下按钮都是有效的。</p>
<p>当有一个队伍已经抢答成功，那么八个D触发器的输出经过两个四输入与非门之后，有一个与非的结果为高电平，再将两者或非，结果就为低电平，此时再有队伍按下抢答按钮就无效，LED灯的亮灭不会发生改变。</p>
<p>D触发器的时钟输入是由八个按钮的电平相或得到，只要有一个队伍在抢答有效的时间内按下按钮，并且在此之前没有其他队伍按下抢答按钮，就会产生一个上升沿；若已有队伍抢答成功，再有队伍按下按钮，电平不会发生变化，时钟不会检测到上升沿。</p>
<p>清零效果的实现主要是利用D触发器的 ~CLR端，清零按钮默认是高电平状态，当按下之后会出现一个低电平的信号，输送给 ~CLR端，达到清零效果。</p>
 <img data-src="/images/八路抢答器课设报告/image-20200531153428970.png" alt="图2" style="zoom:80%;" />



<p>​    抢答部分的报警电路是有一个蜂鸣器构成，高电平引脚接的是74LS175的时钟端口，第一个队伍按下按钮之后时钟端会产生一个高电平信号，蜂鸣器得到这个高电平信号之后会，发出短暂的响声，提示已有队伍抢答成功。</p>
<h2 id="3-2计时模块的设计"><a href="#3-2计时模块的设计" class="headerlink" title="3.2计时模块的设计"></a>3.2计时模块的设计</h2><p>电路仿真图如图3所示。计时模块主要有74LS73、74161和74LS00芯片构成。计时模块的个位数字0-9是74161芯片来控制的，使用反馈清零法，使其在0-9之间循环；十位的数字0-3是由74LS73芯片来控制的，它的时钟信号是74161的置数信号，每当74161需要置数，74LS73就会收到一个时钟脉冲，十位的计数就加一，74161的置数的信号也相当于进位信号。</p>
<p>计时模块的“开关”主要是用74LS73芯片中的JK触发器构成的一个T触发器来实现的，JK触发器的时钟信号是由前面的清零按钮控制，按下清零按钮之后会产生一个下降沿，触发器的输出发生翻转，也就模拟了开关状态的改变。当计时器十位数字为3时，也就是30秒的计时时间到了，74LS73这时Q1和Q2都为高电平，将其接到74LS00的与非门上面，与非的结果为0。再将这个与非的结果和上面JK触发器输出的电平相与得到计时模块的总开关，只要这两者有一个为低电平，总开关就是断开的，计时模块停止工作。比如：当计时器到了30秒的时候74LS73输出Q1和Q2与非的结果为0，此时，计时模块停止工作，数码管显示停留在30秒的时候。计时模块有一个LED指示灯，当“开关”接通时，指示灯亮，当计时到达30秒或者还未开始抢答时，指示灯熄灭。</p>
<p>​    计时的时钟脉冲是由前面抢答模块的D触发器输出四个四个相与非，再将两个与非的结果或非和74LS73的Q1、Q2或非的结果以及一个1HZ的方波信号三个信号相与的结果，只要有一个条件不满足，计数器就会停止计数。比如：已有人抢答成功，那么第一个条件不满足，计时器停止计数；计时器计时到了30秒，那么第二个条件不满足，计数器停止计数。</p>
<p>​    计时模块的报警电路有两部分，一个是计时时间到了30秒，蜂鸣器报警，另一个是抢答开始，蜂鸣器发出报警。第一部分蜂鸣器的高电平端口接到计时模块的电源上，低电平端口接到74LS73输出结果相与非后的端口，计时到了30秒时，74LS73输出结果相与非后的结果为0，高低电平端口有电位差，蜂鸣器发出报警声，同时计时模块的“开关”会断开，所以蜂鸣器的高电平端口也会变为低电平，所以蜂鸣器只会短暂报警。第二部分蜂鸣器的高电平端口接到计时模块的JK触发器的输出端，低电平端口接清零按钮的输出。初始状况蜂鸣器高低电平的电位差为-5V，在按下开始抢答按钮的一瞬间，点位差变成5V蜂鸣器会发出短暂报警声。</p>
 <img data-src="/images/八路抢答器课设报告/image-20200531153526098.png" alt="图3" style="zoom:80%;" />

<h1 id="4、主要元器件的选择"><a href="#4、主要元器件的选择" class="headerlink" title="4、主要元器件的选择"></a>4、主要元器件的选择</h1><p>此八路抢答系统主要由两块74LS175、两块74LS73一块74LS20、一块74LS00、一块74161芯片以及若干非门和与门组成。</p>
<p>所有元器件列表：</p>
<table>
<thead>
<tr>
<th>器件名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>74LS175（D触发器）</td>
<td>2片</td>
</tr>
<tr>
<td>74LS73（JK触发器）</td>
<td>2片</td>
</tr>
<tr>
<td>74LS20（四输入与非门）</td>
<td>1片</td>
</tr>
<tr>
<td>74LS00（二输入与非门）</td>
<td>1片</td>
</tr>
<tr>
<td>74161（十六进制计数器）</td>
<td>1片</td>
</tr>
<tr>
<td>LED</td>
<td>9个</td>
</tr>
<tr>
<td>电阻（470Ω）</td>
<td>9个</td>
</tr>
<tr>
<td>两输入或门</td>
<td>8个</td>
</tr>
<tr>
<td>两输入或非门</td>
<td>1个</td>
</tr>
<tr>
<td>三输入与门</td>
<td>1个</td>
</tr>
<tr>
<td>两输入与门</td>
<td>1个</td>
</tr>
<tr>
<td>PB_DPST按钮</td>
<td>9个</td>
</tr>
<tr>
<td>蜂鸣器</td>
<td>3个</td>
</tr>
<tr>
<td>数码管</td>
<td>2个</td>
</tr>
</tbody></table>
<p>74LS175引脚和逻辑功能表：</p>
<p>   <img data-src="/images/%E5%85%AB%E8%B7%AF%E6%8A%A2%E7%AD%94%E5%99%A8%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A/image-20200531153551489.png" alt="image-20200531153551489"></p>
<p><img data-src="/images/%E5%85%AB%E8%B7%AF%E6%8A%A2%E7%AD%94%E5%99%A8%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A/image-20200531153558547.png" alt="image-20200531153558547"></p>
<p>74LS73引脚和逻辑图：</p>
<p>   <img data-src="/images/%E5%85%AB%E8%B7%AF%E6%8A%A2%E7%AD%94%E5%99%A8%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A/image-20200531153605422.png" alt="image-20200531153605422"></p>
<p><img data-src="/images/%E5%85%AB%E8%B7%AF%E6%8A%A2%E7%AD%94%E5%99%A8%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A/image-20200531153611215.png" alt="image-20200531153611215"></p>
<p>74161引脚和逻辑图：</p>
<p>   <img data-src="/images/%E5%85%AB%E8%B7%AF%E6%8A%A2%E7%AD%94%E5%99%A8%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A/image-20200531153618898.png" alt="image-20200531153618898"></p>
<p><img data-src="/images/%E5%85%AB%E8%B7%AF%E6%8A%A2%E7%AD%94%E5%99%A8%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A/image-20200531153622958.png" alt="image-20200531153622958"></p>
<h1 id="5、调试结果及分析"><a href="#5、调试结果及分析" class="headerlink" title="5、调试结果及分析"></a>5、调试结果及分析</h1><h2 id="5-1调试中存在的问题"><a href="#5-1调试中存在的问题" class="headerlink" title="5.1调试中存在的问题"></a>5.1调试中存在的问题</h2><p>1.多个队伍同时按下抢答按钮会显示都抢答成功</p>
<p>造成这一结果的原因，一方面可能是仿真电路的时间步长和实际的时间步长不一致，仿真需要实时的计，算运行的比实际电路要慢很多，就造成了第一个按下的信号还没反馈回去，第二个按下按钮队伍的信号也一起发出来了，最后就出现多个队伍对应的LED亮起；另一方面可能是反馈回给按钮的信号延迟太高，比第一个按下按钮的队伍和第二个按下按钮的队伍的时间差还要长，也是导致第一次按下按钮信号没反馈回去，第二次的信号就发出去了。这种情况就是电路设计的问题了，但是受条件限制，无法搭建实际的电路，只能用仿真调试，具体的原因也无法进一步探究。</p>
<p>2.蜂鸣器不响（只能响一个）</p>
<p>  在Multisim仿真里面，用示波器测了蜂鸣器两个端口的电位波形，蜂鸣器两个端口有正向的电位差但是蜂鸣器不会响。经过多次的调试发现需要把蜂鸣器单独拿出来并给它一个正向的电位差，再将其接到实际电路中，这样蜂鸣器就可以响了，但是三个蜂鸣器都经过这样的操作之后，只有最后一个能响。造成这种现象的原因应该是Multisim仿真软件的问题，示波器测得的信号没有问题，不能搭建实际的电路也无法进一步验证。</p>
<h1 id="6、心得体会"><a href="#6、心得体会" class="headerlink" title="6、心得体会"></a>6、心得体会</h1><p>​    经过这次八路抢答器的课程设计，我收获颇多。一是加深了计数器、触发器、编码器、译码器的理解，熟悉的掌握了计数器、D触发器和JK触发器的使用，能将用所学的理论知识实际运用起来。二是明白了，自己想象的、构思的和实际做起来是有一定的差异的，刚开始选这个题目的时候就觉得这个题不难，第一天构思的时候也觉得还好，但是在Multisim搭建电路的时候出现了很多意料之外的问题，有的可能是软件的问题，有的就确实是自己搭建的电路有问题，用到的芯片多了结构复杂起来了，一个地方不小心接错了一根线就会导致整个电路出现问题。还有一点体会就是自己之前画的仿真电路，过一段时间可能就不记得为什么要那么画了，然后又要自己重新推导一遍。</p>
<p>​    在这次的课程设计中也发现了自己的许多问题，许多还要提高的部分。第一个是对很多元器件、芯片不熟悉，每次使用都要找逻辑功能表，很不方便。另一点是自己设计逻辑电路图的布局和走线还有待加强，这次课程设计的题目涉及到的模块和功能相对较多，各种元器件的布局以及走线就显得很重要了。</p>
<p>​    总之，经过这次的课程设计，发现了自己存在的许多问题，也有很多的收获，希望在之后的学习中可以进一步提高。</p>
]]></content>
      <categories>
        <category>数字与逻辑电路</category>
      </categories>
      <tags>
        <tag>数字与逻辑电路</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2024/08/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>单例模式是一个典型的<strong>创建型设计模式</strong>，核心思想是保证一个类只存在一个实例，并提供一个全局访问点来访问这个实例。</p>
<ul>
<li>只有一个实例是指在整个应用程序中只存在该类的一个实例对象，而不是创建多个相同类型的对象。</li>
<li>全局访问点是指为了让其他类能够获取到这个唯一实例，该类要提供一个全局访问点，通常是一个静态方法，通过这个方法来获得这个唯一的实例。</li>
</ul>
<h1 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h1><p>简单来说，单例模式有以下几个优点让我们考虑来使用：</p>
<ol>
<li>全局控制：只有一个实例的话可以严格控制客户端怎样访问它以及何时访问它，简单的说就是对唯一实例的受控访问。</li>
<li>节省资源：因为要保证只能存在一个实例，就避免了多次创建相同的对象，从而节省了系统资源，而且多个模块可以通过单例模式共享数据。</li>
<li>懒加载：单例模式可以实现懒加载，只有在需要的时候才进行实例化，这可以提高程序的性能。</li>
</ol>
<span id="more"></span>

<h1 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h1><ol>
<li>私有化构造函数，复制外部代码直接创建类的实例</li>
<li>私有静态实例变量，用来保存该类的唯一实例</li>
<li>共有的静态方法，提供一个全局的访问点以供其他地方获取唯一的实例</li>
</ol>
<h1 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h1><p>单例模式的实现有多种，包括懒汉式、饿汉式等。</p>
<p>饿汉式是指在类的加载时就完成了实例的创建，不管创建之后需不需要马上使用，先创建再说，所以叫“饿汉”。</p>
<p>而懒汉式指的是在第一次获取该实例对象时，才创建该实例，已经创建好之后就直接返回，也就是需要的时候再创建。</p>
<p>在多线程环境中，懒汉式因为不会提前将对象创建好，所以可能会存在多个线程同时来获取该类的唯一实例，会存在现场安全问题，可能会导致创建多个实例，这种情况下我们可能采取一些同步机制，例如使用互斥锁来确保在任意时刻只有一个线程可以执行实例的创建。</p>
<p>饿汉式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton1</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式，用双检索来保证线程安全同时提高程序性能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton2 instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton2.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式中的实例使用<code>volatile</code>关键字修饰，它主要有两个作用：</p>
<p>1、保证可见性：<code>volatile</code>修饰的变量被修改时其他线程都可见，避免了线程间的数据不一致问题，因为<code>volatile</code>修饰的变量读写都会直接操作主内存，避免了线程本地内存和主内存数据不一致的问题。</p>
<p>2、禁止指令重排：重排序是指编译器和处理器为了优化程序性能面对指令序列进行重新排序的一种手段，有时候会改变程序予以的先后顺序。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2024/08/01/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>原型模式一种创建型设计模式，该模式的核心思想是基于现有的对象创建新的对象，而不是从头开始创建。</p>
<p>在原型模式中，通常有一个原型对象，它被用作创建新对象的模板。新对象通过复制原型对象的属性和状态来创建，而无需知道具体的创建细节。</p>
<h1 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h1><p>如果一个对象的创建过程比较复杂时（比如需要经过一系列的计算和资源消耗），那每次创建该对象都需要消耗资源，而通过原型模式就可以复制现有的一个对象来迅速创建&#x2F;克隆一个新对象，不必关心具体的创建细节，可以降低对象创建的成本。</p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>实现原型模式需要给【原型对象】声明一个克隆方法，执行该方法会创建一个当前类的新对象，并将原始对象中的成员变量复制到新生成的对象中，而不必实例化。并且在这个过程中只需要调用原型对象的克隆方法，而无需知道原型对象的具体类型。</p>
<span id="more"></span>
<p>原型模式包含两个重点模块：</p>
<ul>
<li>抽象原型接口<code>prototype</code>: 声明一个克隆自身的方法<code>clone</code></li>
<li>具体原型类<code>ConcretePrototype</code>: 实现<code>clone</code>方法，复制当前对象并返回一个新对象。</li>
</ul>
<h1 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h1><p>原型模式的实现过程即上面描述模块的实现过程：</p>
<ul>
<li>创建一个抽象类或接口，声明一个克隆方法<code>clone</code></li>
<li>实现具体原型类，重写克隆方法</li>
<li>客户端中实例化具体原型类的对象，并调用其克隆方法来创建新的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 定义抽象原型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Prototype <span class="title function_">clone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建具体原型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcretePrototype</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(<span class="built_in">this</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建原型对象</span></span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">original</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(<span class="string">&quot;Original Data&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆原型对象</span></span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">clone</span> <span class="operator">=</span> original.clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出克隆对象的数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Clone Data: &quot;</span> + ((ConcretePrototype) clone).getData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>相比于直接实例化对象，通过原型模式复制对象可以减少资源消耗，提高性能，尤其在对象的创建过程复杂或对象的创建代价较大的情况下。当需要频繁创建相似对象、并且可以通过克隆避免重复初始化工作的场景时可以考虑使用原型模式，在克隆对象的时候还可以动态地添加或删除原型对象的属性，创造出相似但不完全相同的对象，提高了灵活性。</p>
<p>但是使用原型模式也需要考虑到如果对象的内部状态包含了引用类型的成员变量，那么实现深拷贝就会变得较为复杂，需要考虑引用类型对象的克隆问题。</p>
<p>原型模式在现有的很多语言中都有应用，比如以下几个经典例子。</p>
<ul>
<li>Java 提供了 <code>Object</code> 类的 <code>clone()</code> 方法，可以实现对象的浅拷贝。类需要实现 <code>Cloneable</code> 接口并重写 <code>clone()</code> 方法。</li>
<li>在 .NET 中，<code>ICloneable</code> 接口提供了 <code>Clone</code> 方法，可以用于实现对象的克隆。</li>
<li>Spring 框架中的 Bean 的作用域之一是原型作用域（Prototype Scope），在这个作用域下，Spring 框架会为每次请求创建一个新的 Bean 实例，类似于原型模式。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/2024/08/06/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>命令模式允许将请求封装成一个对象（命令对象，包含执行操作所需的所有信息），并将命令对象按照一定的顺序存储在队列中，然后再逐一调用执行，这些命令也可以支持反向操作，进行撤销和重做。</p>
<p>这样发送者只需要触发命令就可以完成操作，不需要知道接受者的具体操作，从而实现两者间的解耦。</p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p><img data-src="/../images/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/IMG-20240806103109431.png"></p>
<ul>
<li>命令接口<code>Command</code>：接口或者抽象类，定义执行操作的接口。</li>
<li>具体命令类<code>ConcreteCommand</code>: 实现命令接口，执行具体操作，在调用<code>execute</code>方法时使“接收者对象”根据命令完成具体的任务，比如遥控器中的“开机”，“关机”命令。</li>
<li>接收者类<code>Receiver</code>: 接受并执行命令的对象，可以是任何对象，遥控器可以控制空调，也可以控制电视机，电视机和空调负责执行具体操作，是接收者。</li>
<li>调用者类<code>Invoker</code>: 发起请求的对象，有一个将命令作为参数传递的方法。它不关心命令的具体实现，只负责调用命令对象的 <code>execute()</code> 方法来传递请求，在本例中，控制遥控器的“人”就是调用者。<span id="more"></span></li>
</ul>
<h1 id="简易实现"><a href="#简易实现" class="headerlink" title="简易实现"></a>简易实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义执行操作的接口，包含一个execute方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现命令接口，执行具体的操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="comment">// 接收者对象</span></span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteCommand</span><span class="params">(Receiver receiver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用接收者相应的操作</span></span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接受者类，知道如何实施和执行一个请求相关的操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体调用者，调用命令对象执行请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用者类中可以维护一个命令队列或者“撤销栈”，以支持批处理和撤销命令。</span></span><br><span class="line"><span class="comment">// 调用者类：命令队列和撤销请求</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Command&gt; commandQueue; <span class="comment">// 命令队列</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Command&gt; undoStack;    <span class="comment">// 撤销栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.commandQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.undoStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置命令并执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAndExecuteCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">        commandQueue.offer(command);</span><br><span class="line">        undoStack.push(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 撤销上一个命令</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undoLastCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!undoStack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Command</span> <span class="variable">lastCommand</span> <span class="operator">=</span> undoStack.pop();</span><br><span class="line">            lastCommand.undo(); <span class="comment">// 需要命令类实现 undo 方法</span></span><br><span class="line">            commandQueue.remove(lastCommand);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No command to undo.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行命令队列中的所有命令</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCommandsInQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Command command : commandQueue) &#123;</span><br><span class="line">            command.execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>();</span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteCommand</span>(receiver);</span><br><span class="line">        <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invoker</span>(command);</span><br><span class="line"></span><br><span class="line">        invoker.executeCommand();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>命令模式在需要将请求封装成对象、支持撤销和重做、设计命令队列等情况下，都是一个有效的设计模式。</p>
<ul>
<li><strong>撤销操作：</strong> 需要支持撤销操作，命令模式可以存储历史命令，轻松实现撤销功能。</li>
<li><strong>队列请求：</strong> 命令模式可以将请求排队，形成一个命令队列，依次执行命令。</li>
<li><strong>可扩展性：</strong> 可以很容易地添加新的命令类和接收者类，而不影响现有的代码。新增命令不需要修改现有代码，符合开闭原则。</li>
</ul>
<p>但是对于每个命令，都会有一个具体命令类，这可能导致类的数量急剧增加，增加了系统的复杂性。</p>
<p>命令模式同样有着很多现实场景的应用，比如Git中的很多操作，如提交（commit）、合并（merge）等，都可以看作是命令模式的应用，用户通过执行相应的命令来操作版本库。Java的GUI编程中，很多事件处理机制也都使用了命令模式。例如，每个按钮都有一个关联的 <code>Action</code>，它代表一个命令，按钮的点击触发 <code>Action</code> 的执行。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基本数据类型和包装类型</title>
    <url>/2023/12/25/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h1><p><img data-src="/../images/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB/primitive-type-vs-packaging-type.png" alt="基本类型 vs 包装类型"></p>
<ul>
<li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li>
<li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li>
<li><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li>
<li><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li>
<li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li>
</ul>
<p><strong>为什么说是几乎所有对象实例都存在于堆中呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p>
<p>⚠️ 注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasicTypeVar</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="包装类的缓存机制"><a href="#包装类的缓存机制" class="headerlink" title="包装类的缓存机制"></a>包装类的缓存机制</h1><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
<h2 id="Integer缓存源码"><a href="#Integer缓存源码" class="headerlink" title="Integer缓存源码"></a>Integer缓存源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Float</span> <span class="variable">i11</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line"><span class="type">Float</span> <span class="variable">i22</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Double</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>



<p>下面的代码的输出结果是 <code>true</code> 还是 <code>false</code> 呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure>

<p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p>
<p>因此，答案是 <code>false</code> 。</p>
<p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p>
<h1 id="自动装箱和拆箱的原理"><a href="#自动装箱和拆箱的原理" class="headerlink" title="自动装箱和拆箱的原理"></a>自动装箱和拆箱的原理</h1><h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h2><ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p>装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p>
<p>因此，</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li>
</ul>
<p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<hr>
<p>参考：<a href="https://javaguide.cn/java/basis/java-basic-questions-01.html">JavaGuide（常见面试总结上）</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>在Ubuntu服务器上安装MySQL8</title>
    <url>/2020/03/01/%E5%9C%A8Ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85mysql8/</url>
    <content><![CDATA[<p>在<a href="http://dev.mysql.com/downloads/repo/apt/%EF%BC%8C%E4%B8%8B%E8%BD%BD%E4%B8%80%E4%B8%AAmysql-apt-config_0%E2%80%A6%E2%80%A6._all.deb%EF%BC%8C%E4%BC%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%EF%BC%8C%E7%94%A8dpkg">http://dev.mysql.com/downloads/repo/apt/，下载一个mysql-apt-config_0……._all.deb，传到服务器上，用dpkg</a> -i mysql-apt-config_0._…..all.deb安装执行，选择mysql8，OK之后回到终端窗口</p>
<p>执行sudo apt update</p>
<p>然后使用sudo apt install mysql-server命令，就会安装MySQL8.0</p>
]]></content>
      <categories>
        <category>软件</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/2024/08/09/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>备忘录模式允许在不暴露对象实现的情况下捕获对象的内部状态，并在对象之外保存这个状态，仪表后续可以还原到之前的状态，有点类似<code>Ctrl+Z</code>。</p>
<p><img data-src="/../images/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/IMG-20240809161012326.png"></p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>备忘录模式包括一下几个重要角色：</p>
<ul>
<li>发起人<code>Originator</code>： 需要还原状态的那个对象，负责创建一个【备忘录】，并使用备忘录记录当前时刻的内部状态。</li>
<li>备忘录<code>Memento</code>: 存储发起人对象的内部状态，它可以包含发起人的部分或全部状态信息，但是对外部是不可见的，只有发起人能够访问备忘录对象的状态。</li>
</ul>
<p>备忘录有两个接口，<strong>发起人</strong>能够通过<strong>宽接口</strong>访问数据，<strong>管理者</strong>只能看到<strong>窄接口</strong>，并将备忘录传递给其他对象。</p>
<ul>
<li>管理者<code>Caretaker</code>: 负责存储备忘录对象，但并不了解其内部结构，管理者可以存储多个备忘录对象。</li>
<li>客户端：在需要恢复状态时，客户端可以从管理者那里获取备忘录对象，并将其传递给发起人进行状态的恢复。</li>
</ul>
<p><img data-src="/../images/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/IMG-20240809163915464.png"></p>
<span id="more"></span>
<h1 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h1><p>创建发起人，可以创建备忘录对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 创建备忘录对象</span></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">createMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(state);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 通过备忘录对象恢复状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreFromMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建备忘录类：保存发起人对象的状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">	<span class="comment">// 保存发起人的状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建管理者：维护一组备忘录对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Memento&gt; mementos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        mementos.add(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">getMemento</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mementos.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端使用备忘录模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建发起人对象</span></span><br><span class="line">        <span class="type">Originator</span> <span class="variable">originator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Originator</span>();</span><br><span class="line">        originator.setState(<span class="string">&quot;State 1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建管理者对象</span></span><br><span class="line">        <span class="type">Caretaker</span> <span class="variable">caretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caretaker</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存当前状态</span></span><br><span class="line">        caretaker.addMemento(originator.createMemento());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        originator.setState(<span class="string">&quot;State 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次保存当前状态</span></span><br><span class="line">        caretaker.addMemento(originator.createMemento());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复到先前状态</span></span><br><span class="line">        originator.restoreFromMemento(caretaker.getMemento(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Current State: &quot;</span> + originator.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>备忘录模式在保证了对象内部状态的封装和私有性前提下可以轻松地添加新的备忘录和发起人，实现“备份”，不过 备份对象往往会消耗较多的内存，资源消耗增加。</p>
<p>备忘录模式常常用来实现撤销和重做功能，比如在Java Swing GUI编程中，<code>javax.swing.undo</code>包中的撤销（undo）和重做（redo）机制使用了备忘录模式。<code>UndoManager</code>和<code>UndoableEdit</code>接口是与备忘录模式相关的主要类和接口。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>大二下学期总结</title>
    <url>/2020/07/09/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="aa3dfea4f24cd683ddff13030c08f03c6e3f3ab355b2c8d36abdf37df33fdb61">99b23c07cf5459d82b841027c3c8076927a9f0a9aac67be1dcfd0dc9dc4fe5873617ad29598f65a1927df3de1b4486a33ba82c048b4287ace2fd325eb537aee8472803d5a6a9beaaf29fb27454f2159c92b55f972810575f0f04b1d25cc578a430dd703994e8226676683ef8147f3ab03ee00238849367a202a76f6d3263ff457db9c736eb09b1ae094d772ac18066704ea0c587ecf8a132f659b02f2b268fb2ed4e850d2714792add21de86591f2ace392abf28f83dbc72c129f285c122715d117b8df6d3e092d496607539a63bb81d4e0636fc7d22100d5bec9d8cbb84de997fe01eedfa98a3f5b4fc83ae9223acf8b1e62fd64d68ab75655a1891876a0eaf9c1b40b053db049c898629917977e5c6f2713fcf95abb1be87a544c96a807287d7af73c1495e30883a179da92cff7ffc11652e4b8cb8ef9c983d6ba2653a6d5c503e263711615d5d01176faf9c4346b2de6864cbb98f7cbcb0ff0970eb878769c2d1be18bea7ab79c4c99909867e82182c4b74b0ff6be0205c59a12474534a8068a95ed97350b8f9e8a2bab55150d150b0b48724156559bb5fb9a326ecfc5cfce23fe0132d6968c22603f80ef27947a3303f818ef7650fa7253c974f47aafd9ceded8ab760dee57747122c36f81f113ea2f66bb508cd64613da4a8a823bb48ad69b05fa97ce771ad90d30f8f181ef05924ac831089e7ceb8bbfe0dc71a57346a7e8679a9dbebd35a850e62c0e0cddd59e3bd787d4ea4f2af2e3b49d55e3ecdad4957a1c46a75a6f15f9bb156f129ae39c3683b87f83a14f799d8da9034eeb5906cd35701bc290ec38446b9d675c86544dcb6cfa8abddae5148b33f4b7e52a6e0a62146bd73b73dca82007833d99f28cff3619adcba7754f95aaca2785427fc6506d29d80504b1dcd371836b390be2af35d071d34c1d3ecd76d9def892b96d0c068878d07a53de69c9a8cd710c2118c722184f47dc80c088a0397c81e206a271c1c36ae3d2899176be2c485ac69f410bcd8d8341ea0cbda0d2f80903bf43ea3ec47a86cfa32d6f5a4c9e622427a12073d16f9549c72cbaa17ec86368bf23baf2348c3e296d23aaf996be69edcff05b7da49d97c8aeb425395eb3cf1c758896db6150555ffeb84fa6e1095c86a8e715c4cbd9cc37b1258a237a76732df1e67ecaa856925cb33be4ea5335fd5e3d30c633978cff52ee760810710863a285be8b2422581b08177ea7a6ec3c2388ea54053d62f78266095318a88b8c0d8cac123322ad042a8175457b0be922de9305bfd10640d8907876945e895af6250fc13fc52eae88a6d496bd2b354c00596de3a46afddebbd6dd2e282b87a67119154eda70388128502847e89d98b41f75baff04d0126bfe9fe3f79824ec3c059e60ea936acfd2293b109114ab3623ca5395614f73e20ceee9ffe980a9b11cb6fa17b1a1d93dbed45921bb111c7012a52961e0d16153ef8cd35ebb090b053769f85a7954ce80164081b00417f6e6d9321612b0f8ffb0ec5ce34ebb91a8537561e549df9a0cd8aaf32b0c861e42fa2a2ddcb86c3f940d2f6398923f355b67d179f344af1474558e004f556be8cadcd714cf4a48ac7f867e59fc96f51ae7af394be35c887ae4fe1296e2f2d0d46e11f48df030d6c380f5304a61a875a347831f6710bcdba6ba53c03101cbee0fff2949e2bde18005065a456e42b41cc397cb59b08a4f48d39968688acb209ba4010d808ff77458e077745e0dff8a63b30dcd1495149d1a1ca624d949de676631e1c5a133e63fc74443c4a96a2a43d28e554d06bf351499b6067ba6ec4b7e0b82bdb3e078c7b63a77a4adcd52700a0e4dfa884e41cdeea841f5af5c8f570f7d3bd0086d04c4fb6fac9467d5ec3a85a6cf4e8f20bdfb1b6c01e04fdf71c03c61fed9cac585b65952103ed657339d8a9649f38b5633bd0296ba21d84409f69dd9a78e8df565117ee9b4b070585223d32dc230f9e11a922e8aee3d3770eef9f1968b1df5b1cca26a3af5917cc66844b388ebe1f4e011e903065a07a6445fcaae7d68a2d16381244f9445b93afc996e93da5108f92c5cb29e0ffa438eb840002a57ae82e6a5938abfb06a245e34fc035af3913b789498666c66d086798feb4b92a7c6b415901a80bc8d063c07216446871c117f1206e5f2b788dea882d8a99e96dccba76e3ac15577d017ad6d480581b5f59b7ad88e9ceedd5641981edfbcd53d7df6ffeac490f426465009b009cf78c4a1154765cccbd59b0fbbcd6506ec0864fed170d048c2feaf729d7a3e01e33e050608a019eed1db0e98ee56c3e49a3b31b2058f7fb6b500adb2a1a7f653158d772aaf00ab0104ca17c7c31ce4e6d15b26a26ad88836edfadf4214d9141d6c77dd4de9f273dd21edce82a2313b1b9ae3517405d4836b39e8be5438b443d59c43c35809f173c40f7becefe44c0fe755d358dda0b1f7c895df24c22de424ae04d71ee14e513dd037b3a582db1a8d4a6a8531e333cc3d781687b6738548cc5d2ec7d64465e7e39f397be9101a92a1b29094ce747b106be19fc7474d1e4a42fb772baa0dd81bd6b59cb9ac80a089dc9f891213fc25a533f6275486fc5e2bcdd957aba940b388bc80bb66b8dab90c8beec3afcc93db542bc56487ae7049c80fbd5635cdd53f726c7c1f5a7e9a2bd09de49bd0e0bf618eaa1ce1b6cce34f78d3c726b2a1b99ac16d77015cb73f9e9647cda0bd7677848b869a209a099ecdf878553acfbcc6a90520a93396e8e9dd933acc33a055fadb0c181420f5b4557ae2251929f9a708255c54175977f2534e8bc5931395d649ca11dca124d791a1ca4266ef05bbbde676d6da6eb0ffb7cec23c6bca86a44b678871ee71debd002a94a2b83ae7470913ba9f7b34c8a239b73ab9ed5e3183f50914418f5cdaf694d522beb6890bc63ddc41e02fb965438ab3f3128d653f4f3dc52a7c70cdfc24679e756859fe4134998c126c44e2c8f65c54135ce16b92e8417b14163fa514bfb4ee174ae846a1b2e1b11d364cc20f945568d345a4e1b43ebf86f975561fa270d658cb5f9a599c2598a7a064f40ed7037ee14734f09d594c85649884634044746a2f89ecc0af6ad9a2a6c8ede9ad27c32b4f2711b91850dc63e702fc74cbe30a49b67678374</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码进行查看</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>感悟</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用好学生优惠</title>
    <url>/2020/02/27/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%A5%BD%E5%AD%A6%E7%94%9F%E4%BC%98%E6%83%A0/</url>
    <content><![CDATA[<p><img data-src="/images/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%A5%BD%E5%AD%A6%E7%94%9F%E4%BC%98%E6%83%A0/loq428.png" alt=" loq428.png"></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本文介绍的是利用学生身份可以享受到的相关学生优惠权益，但也希望各位享受权利的同时不要忘记自己的义务，不要售卖、转手自己的学生优惠资格，使得其他同学无法受益。</p>
<p><strong>欢迎提交 issue 给我们你发现的实用资源！</strong> | 本文更新于 2019 年 05 月 12 日</p>
<p>点击 <code>watch</code> 可以得到更新信息哟！</p>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul>
<li>查看、利用、转载、引用本集锦请查看 <a href="https://github.com/ivmm/Student-resources/blob/master/lisence">License</a>。</li>
<li>一切官方的助学资金等，请咨询学校领导、辅导员、班主任，请勿向陌生账户转账！</li>
<li>校园借贷风险极高，请谨慎尝试。</li>
<li>对需要出示身份证、手持身份证的资源请保持谨慎。</li>
<li>保管好自己的学生证、身份证，不要随意丢弃。</li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>高考已经过去，你们也将迎来不同于以往的大学生活，大学或许对之前的12年管制式生活来说是解放了，不过你也知道的，解放后面是什么，脱离了父母和老师的管束以及适当的财务自主，你的生活并不会就无比精彩。</p>
<p>让自己的大学生活过得积极而精彩：</p>
<ol>
<li>多参加校级、省级、国家级的比赛，你的比较对象就不会是同班同学了而是同龄人，视野更大。</li>
<li>多上台讲讲，第一次第二次第三次可能会小心脏砰砰跳，后面真的就见怪不怪了，会自信很多。</li>
<li>不要再默默无闻了，让老师们注意到你，都大学了上课还不敢举个手？</li>
<li>做点义工，为社会做点贡献，工作了就真没时间了。</li>
<li>做人做事记得留个证据，留个发票，留个单子。</li>
<li>多向长辈们问候问候，偶尔放个长假了就去看看。</li>
</ol>
<p>那么就期待着9月开启你的上当受骗之旅吧，不过可能在6月买电脑买手机的时候就已经上当受骗。（逃～）</p>
<h1 id="学生包"><a href="#学生包" class="headerlink" title="学生包"></a>学生包</h1><p>各类学生优惠项目经过许多年的发展，很多学生包已经不单单只通过 edu 邮箱验证身份了，而且使用 @edu.cn 反而会降低申请成功率。 建议使用学生证、入学通知书等有学院官方标志和日期的工具来证明自己的身份。</p>
<ul>
<li>**<a href="https://education.github.com/pack">Github 学生包</a>**，高质量的开发工具集合，并提供 DIgitalocean 的 50美元代金券，免费域名一枚。</li>
<li>**<a href="https://imagine.microsoft.com/zh-cn/catalog">Microsoft Imagine 学生包</a>**，免费使用微软的开发软件，包括 Windows Server 系统，以及 Azure 学生订阅。</li>
<li>**<a href="https://aws.amazon.com/cn/education/awseducate/">AWS 学生包</a>**，亚马逊云计算的学生包，可以获得至少 $40 的优惠和教育培训。</li>
<li>**<a href="http://www.autodesk.com.cn/education/home">Autodesk 学生包</a>**，旗下 AutoCAD , 3DMAX , Maya 等软件，其（教育版）免费试用期可延长至三年。</li>
<li>**<a href="https://www.jetbrains.com/student/">JetBrains 学生包</a>**，免费使用各类开发工具和集成工具。</li>
<li>**<a href="https://edu.google.com/products/productivity-tools/">G Suite for Education</a>**，为教育用户提供的谷歌生产力工具套件（大陆不在申请区之内）。</li>
<li><strong><a href="http://www.lindo.com/index.php?option=com_content&view=article&id=120&Itemid=45">LINGO Educational Research License</a></strong>, LINGO 教育授权，著名线性与非线性求解器，求解优化模型的最佳选择，数学建模必备。</li>
</ul>
<h1 id="学生优惠"><a href="#学生优惠" class="headerlink" title="学生优惠"></a>学生优惠</h1><ul>
<li>**<a href="https://products.office.com/en-us/student?tab=students">Office in Education</a>**，微软家提供的免费 Office 365 教育优惠，中国大多数学校无缘申请。</li>
<li>**<a href="https://promotion.aliyun.com/ntms/act/campus2018.html?accounttraceid=22aca9b8-8f26-44f2-b514-d97cf21a6654&userCode=oitiwrd3">阿里云+云翼计划</a>**，118元&#x2F;年，阿里云ECS+OSS+域名+机器学习API+Clouder认证。  24岁以下实名认证即可获得，无需验证学生身份!!</li>
<li>**<a href="https://www.qcloud.com/act/campus">腾讯云+校园计划</a>**，10元一个月的云服务器租用，免费域名、云储存，需要抢购。</li>
<li>**<a href="https://developer.huaweicloud.com/campus">华为云+云创校园计划</a>**，9元&#x2F;月 24岁及以下免学生认证，实名认证即可购买，需要抢购。</li>
<li>**<a href="https://cloud.baidu.com/campaign/campus-2018/index.html">百度云启航校园计划</a>**，云服务器半年124元</li>
<li>**<a href="http://www.apple.com/cn-k12/shop">苹果教育商店</a>**，苹果设备优惠，Music和 Pro APP 优惠，暑假还会有学生优惠大促销。</li>
<li>**<a href="https://www.microsoftstore.com.cn/student?Icid=StoreNavi_EDU">微软教育商店</a>**，9折购买微软旗下的各种硬件设备。</li>
<li>**<a href="http://www.onthehub.com/">OnTheHub 教育商店</a>**，PD 和 VMware 的虚拟机优惠，以及更多软件优惠。</li>
<li>**<a href="https://www.siteground.com/student-hosting.htm">SiteGroud 学生计划</a>**，WP 官方推荐的主机托管商提供 $1.99&#x2F;月 高性能 CP 托管。</li>
<li>**<a href="https://www.spotify.com/hk-zh/student/">Spotify 学生优惠</a>**，Spotify Premium学生订阅半价优惠。</li>
<li>**<a href="https://pantheon.io/edu">Pantheon 学生版</a>**，专业高性能网站托管的学生优惠。</li>
<li>**<a href="http://coupon.dji.com/cn/edu">大疆教育优惠</a>**，大疆产品的教育折扣。</li>
<li>**<a href="https://todoist.com/education">Todoist教育优惠</a>**，强大的任务、思路整理工具提供半价教育优惠。</li>
<li>**<a href="https://setapp.com/educational-discount">SetAPP教育优惠</a>**，macOS 应用合集订阅包半价优惠，非常适合MAC学生党，每月4.99刀</li>
<li><strong><a href="http://app.eagle.cool/forum/topic/5354/%E6%88%91%E6%98%AF%E5%AD%A6%E7%94%9F%E6%88%96%E6%95%99%E5%B8%88-%E6%98%AF%E5%90%A6%E4%BA%AB%E6%9C%89%E4%BC%98%E6%83%A0%E4%BB%B7%E6%A0%BC">Eagle教育优惠</a></strong>, Win&#x2F;Mac系统，设计师图片管理工具，支持试用一个月，原价199，优惠价139，需提供身份和证件信息。优秀的本地图片管理工具，搭配学生版OneDrive进行同步管理，美滋滋。（目前已支持图片、视频、字体等类型文件的管理）</li>
</ul>
<h1 id="实用干货"><a href="#实用干货" class="headerlink" title="实用干货"></a>实用干货</h1><ul>
<li>**<a href="https://creativemarket.com/free-goods">CreativeMarket Free Goods</a>**，每周免费六款设计资源，电商、前端必备。</li>
<li>**<a href="https://www.axure.com/edu">Axure</a>**， 原型设计工具，产品、运营必备，学生、教师免费。</li>
<li>**<a href="https://www.adobe.com/cn/products/xd.html">Adobe XD</a>**，原型设计工具，<del>没想到吧我Adobe也有免费的东西啦XD</del> 官网直接提供免费版，奋起直追Mac的Sketch，Win党难得的福利。此外Adobe还提供对XD插件设计的奖励，<a href="https://www.adobe.io/apis/creativecloud/xd.html">可参与设计开发可供XD使用的插件</a>。</li>
<li>**<a href="http://education.minecraft.net/get-started">Minecraft</a>**， 我的世界教育免费版 ，仅支持邮箱。</li>
<li>**<a href="http://www.wolfram.com/mathematica/pricing/students-individuals.php">Mathematica</a>**， 现代科学计算软件，3折优惠 50刀，添加购物车后显示。</li>
<li>**<a href="https://www.tableau.com/zh-cn/academic">Tableau</a>**， 数据可视化分析软件，对学生、教室以及教育组织提供免费使用。</li>
</ul>
<h1 id="推荐软件"><a href="#推荐软件" class="headerlink" title="推荐软件"></a>推荐软件</h1><ul>
<li>**<a href="https://cloudconvert.com/">CloudConvert</a>**，转码神器，格式齐全的在线转码利器。</li>
<li>**<a href="https://smallpdf.com/">Smallpdf</a>**，专业文档转PDF，PDF转文档神器。</li>
<li>**<a href="https://github.com/drew-royster/canvasFileSync">Canvas File Sync</a>**，Syncs Canvas-LMS课程文件</li>
</ul>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ul>
<li><strong>少数派：</strong><a href="https://sspai.com/post/39430">在校师生福利：Apple、微软、Adobe 等产品如何通过教育优惠购买</a></li>
<li><strong>少数派：</strong><a href="https://sspai.com/post/43533">学生专属福利，你可能还不知道这些常用服务其实可以更便宜</a></li>
</ul>
<h1 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h1><p><strong>买电脑：</strong> 学生购买电脑多为笔记本，可关注 <a href="http://tieba.baidu.com/f?kw=%E7%AC%94%E8%AE%B0%E6%9C%AC&ie=utf-8">笔记本吧</a><br>如果为台式可关注 显卡吧&#x2F;图拉丁吧&#x2F;电脑吧 等专业硬件社区，或直接关注微信公众号“笔吧评测室”，由笔记本吧吧主和吧务团队运营，质量保证。</p>
<p><strong>如何科学提问：</strong> 《<a href="http://git.oschina.net/mifar/How-To-Ask-Questions-The-Smart-Way">提问的智慧</a>》 《<a href="https://github.com/octowhale/Stop-Ask-Questions-The-Stupid-Ways/blob/master/README.md">别像弱智一样提问</a>》</p>
<p><strong>搜索引擎：</strong> 为了你的身体健康、事业有成，请尽量<strong>减少使用百度</strong>的频率。</p>
<p><strong>PPT 制作：</strong>《<a href="https://www.mf8.biz/ppt-tips/">放 PPT 之前，请你注意这一些！</a>》</p>
<p>原作者博客：<a href="https://www.mf8.biz/">https://www.mf8.biz/</a></p>
]]></content>
      <categories>
        <category>羊毛</category>
      </categories>
      <tags>
        <tag>羊毛</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/2024/08/01/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>简单工厂模式的核心思想是将对象的创建封装在一个工厂类中，吧创建对象的的流程集中在这个工厂类里面。</p>
<p>简单工厂包括三个主要角色，工厂类、抽象对象、具体对象。</p>
<p><img data-src="/../images/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/IMG-20240801091343719.png"></p>
<ul>
<li>抽象对象描述对象的通用行为，通常使用接口或抽象类实现。</li>
<li>具体对象实现接口或继承抽象类，具体对象通过简单工厂的<code>if-else</code>逻辑来进行实例化。</li>
<li>工厂类负责创建产品，根据传递的不同参数创建不同的产品实例。</li>
</ul>
<span id="more"></span>

<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>工程方法模式是一种创建型设计模式，简单工厂模式只要一个工厂类，负责创建所有产品，如果添加新的产品，就需要修改工厂类的代码。而工厂方法模式引入了抽象工厂和具体工厂的概念，每个具体工厂负责创建一个具体产品，新添加的产品只需要添加新的工厂类，而不需要修改原来的代码，是的产品的生产更加灵活，支持拓展，符合开闭原则。</p>
<p>工厂方法模式通常有以下几个角色：</p>
<ul>
<li>抽象工厂：一个接口，包含抽象的工厂方法，用于创建产品对象。</li>
<li>具体工厂：实现抽象工厂接口，创建具体的产品。</li>
<li>抽象产品：定义产品的接口。</li>
<li>具体产品：实现抽象产品接口，是工厂创建的对象。</li>
</ul>
<blockquote>
<p>实际上工厂方法模式也很好理解，就拿“手机Phone”这个产品举例，手机是一个抽象产品，小米手机、华为手机、苹果手机是具体的产品实现，而不同品牌的手机在各自的生产厂家生产。</p>
</blockquote>
<p><img data-src="/../images/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/IMG-20240801091356309.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Huawei</span> <span class="keyword">implements</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;huawei call...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Xiaomi</span> <span class="keyword">implements</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;xiaomi call...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PhoneFactory</span> &#123;</span><br><span class="line">    Phone <span class="title function_">getPhone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuaweiFactory</span> <span class="keyword">implements</span> <span class="title class_">PhoneFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">getPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Huawei</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XiaomiFactory</span> <span class="keyword">implements</span> <span class="title class_">PhoneFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">getPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Xiaomi</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>工厂方法模式使得每个工厂类的职责单一，每个工厂只负责创建一种产品，当创建对象涉及一系列复杂的初始化逻辑，而这些逻辑在不同的子类中可能有所不同时，可以使用工厂方法模式将这些初始化逻辑封装在子类的工厂中。在现有的工具、库中，工厂方法模式也有广泛的应用，比如：</p>
<ul>
<li>Spring 框架中的 Bean 工厂：通过配置文件或注解，Spring 可以根据配置信息动态地创建和管理对象。</li>
<li>JDBC 中的 Connection 工厂：在 Java 数据库连接中，<code>DriverManager</code> 使用工厂方法模式来创建数据库连接。不同的数据库驱动（如 MySQL、PostgreSQL 等）都有对应的工厂来创建连接。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2024/08/01/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>建造者模式（也被成为生成器模式），是一种创建型设计模式，软件开发过程中有的时候需要创建很复杂的对象，而建造者模式的主要思想是将对象的构建过程分为多个步骤，并为每个步骤定义一个抽象的接口，具体的构建过程由实现了这些接口的具体建造者类来完成。同时有一个指导者类负责协调建造者的工作，按照一定的顺序或逻辑来执行构建步骤，最终生成产品。</p>
<p>例如加入我们创建一个计算机对象，而计算机由很多组件构成，例如CPU、内存、硬盘等，每个组件可能由不同的型号、配置和制造，这个时候计算机就可以被视为一个复杂对象，构造过程相对复杂，而我们使用建造者模式将计算机的构建过程封装在一个具体的建造者类中，而指导者则负责指导构建的步骤和顺序。</p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>建造者模式有以下几个关键角色：</p>
<ul>
<li>产品<code>Product</code>：被构建的复杂对象, 包含多个组成部分。</li>
<li>抽象建造者<code>Builder</code>: 定义构建产品各个部分的抽象接口和一个返回复杂产品的方法<code>getResult</code></li>
<li>具体建造者<code>Concrete Builder</code>：实现抽象建造者接口，构建产品的各个组成部分，并提供一个方法返回最终的产品。</li>
<li>指导者<code>Director</code>：调用具体建造者的方法，按照一定的顺序或逻辑来构建产品。</li>
</ul>
<p><img data-src="/../images/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/IMG-20240801155141419.png"></p>
<span id="more"></span>

<h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><p>定义产品类，包含产品的多个组成部分，这些属性和方法构成了产品的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String CPU;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String memory;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String board;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String disk;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String monitor;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCPU</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> CPU;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCPU</span><span class="params">(String CPU)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.CPU = CPU;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMemory</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> memory;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(String memory)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.memory = memory;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBoard</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> board;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBoard</span><span class="params">(String board)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.board = board;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDisk</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> disk;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDisk</span><span class="params">(String disk)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.disk = disk;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMonitor</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> monitor;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMonitor</span><span class="params">(String monitor)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.monitor = monitor;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义建造者接口，包含构建产品各个部分的抽象方法，这些方法通常用于设置产品的各个属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ComputerBuilder</span> &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildCPU</span><span class="params">(String cpu)</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildBoard</span><span class="params">(String board)</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildMemory</span><span class="params">(String memory)</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildDisk</span><span class="params">(String disk)</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildMonitor</span><span class="params">(String monitor)</span>;  </span><br><span class="line">  </span><br><span class="line">    Computer <span class="title function_">getComputer</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建具体的构造类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ComputerBuilder</span> &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildCPU</span><span class="params">(String cpu)</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildBoard</span><span class="params">(String board)</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildMemory</span><span class="params">(String memory)</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildDisk</span><span class="params">(String disk)</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildMonitor</span><span class="params">(String monitor)</span>;  </span><br><span class="line">  </span><br><span class="line">    Computer <span class="title function_">getComputer</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建指导者类：用来控制电脑的构建顺序和步骤</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerDirector</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ComputerBuilder builder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ComputerDirector</span><span class="params">(ComputerBuilder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        builder.buildBoard(<span class="string">&quot;ASUS ROG&quot;</span>);</span><br><span class="line">        builder.buildCPU(<span class="string">&quot;AMD Yes!&quot;</span>);</span><br><span class="line">        builder.buildDisk(<span class="string">&quot;ZhiTai TiPlus 7100&quot;</span>);</span><br><span class="line">        builder.buildMemory(<span class="string">&quot;Gloway DDR5 32G&quot;</span>);</span><br><span class="line">        builder.buildMonitor(<span class="string">&quot;ASUS ROG&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ComputerBuilder</span> <span class="variable">computerBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyComputerBuilder</span>();</span><br><span class="line">        <span class="type">ComputerDirector</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComputerDirector</span>(computerBuilder);</span><br><span class="line"></span><br><span class="line">        director.construct();</span><br><span class="line"></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> computerBuilder.getComputer();</span><br><span class="line"></span><br><span class="line">        System.out.println(computer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>使用建造者模式有下面几处优点：</p>
<ul>
<li>使用建造者模式可以<strong>将一个复杂对象的构建与其表示分离，</strong>通过将构建复杂对象的过程抽象出来，可以使客户端代码与具体的构建过程解耦</li>
<li><strong>同样的构建过程可以创建不同的表示</strong>，可以有多个具体的建造者(相互独立），可以更加灵活地创建不同组合的对象。</li>
</ul>
<p>对应的，建造者模式适用于复杂对象的创建，当对象构建过程相对复杂时可以考虑使用建造者模式，<strong>但是当产品的构建过程发生变化时，可能需要同时修改指导类和建造者类，这就使得重构变得相对困难</strong>。</p>
<p>建造者模式在现有的工具和库中也有着广泛的应用，比如JUnit 中的测试构建器<code>TestBuilder</code>就采用了建造者模式，用于构建测试对象。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/2024/08/01/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>抽象工厂模式提供了一个创建一系列相关或相互依赖的对象接口，而无需指定他们的具体类。</p>
<p>在工厂方法模式中，每个具体工厂只负责单一产品的创建，但是如果有多类产品，那么这些具体的产品都需要创建一个单独的工厂类，但是他们都是相互关联的，都属于同一个品牌，这就可以使用“抽象工厂模式”。</p>
<p>抽象工厂模式可以确保一系列相关的产品被一起创建，这些产品能够相互配合使用，再举个例子，有一些家具，比如沙发、茶几、椅子，都具有古典风格的和现代风格的，抽象工厂模式可以将生产现代风格的家具放在一个工厂类中，将生产古典风格的家具放在另一个工厂类中，这样每个工厂类就可以生产一系列的家具。</p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>抽象工厂模式包含多个抽象产品接口，多个具体产品类，一个抽象工厂接口和多个具体工厂，每个具体工厂负责创建一组相关的产品。</p>
<ul>
<li>抽象产品接口<code>AbstractProduct</code>: 定义产品的接口，可以定义多个抽象产品接口，比如说沙发、椅子、茶几都是抽象产品。</li>
<li>具体产品类<code>ConcreteProduct</code>: 实现抽象产品接口，产品的具体实现，古典风格和沙发和现代风格的沙发都是具体产品。</li>
<li>抽象工厂接口<code>AbstractFactory</code>: 声明一组用于创建产品的方法，每个方法对应一个产品。</li>
<li>具体工厂类<code>ConcreteFactory</code>： 实现抽象工厂接口，负责创建一组具体产品的对象，在本例中，生产古典风格的工厂和生产现代风格的工厂都是具体实例。<span id="more"></span></li>
</ul>
<h1 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h1><p>想要实现抽象工厂模式，需要遵循以下步骤：</p>
<ul>
<li>定义抽象产品接口（可以有多个），接口中声明产品的公共方法。</li>
<li>实现具体产品类，在类中实现抽象产品接口中的方法。</li>
<li>定义抽象工厂接口，声明一组用于创建产品的方法。</li>
<li>实现具体工厂类，分别实现抽象工厂接口中的方法，每个方法负责创建一组相关的产品。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 定义抽象产品</span></span><br><span class="line"><span class="comment">// 抽象产品A</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品B</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 实现具体产品类 </span></span><br><span class="line"><span class="comment">// 具体产品A1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA1</span> <span class="keyword">implements</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Concrete Product A1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA2</span> <span class="keyword">implements</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Concrete Product A2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB1</span> <span class="keyword">implements</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Concrete Product B1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB2</span> <span class="keyword">implements</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Concrete Product B2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 定义抽象工厂接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    ProductA <span class="title function_">createProductA</span><span class="params">()</span>;</span><br><span class="line">    ProductB <span class="title function_">createProductB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 实现具体工厂类</span></span><br><span class="line"><span class="comment">// 具体工厂1，生产产品A1和B1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂2,生产产品A2和B2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractFactoryExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用工厂1创建产品A1和产品B1</span></span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory1</span>();</span><br><span class="line">        <span class="type">ProductA</span> <span class="variable">productA1</span> <span class="operator">=</span> factory1.createProductA();</span><br><span class="line">        <span class="type">ProductB</span> <span class="variable">productB1</span> <span class="operator">=</span> factory1.createProductB();</span><br><span class="line">        productA1.display();</span><br><span class="line">        productB1.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用工厂2创建产品A2和产品B2</span></span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory2</span>();</span><br><span class="line">        <span class="type">ProductA</span> <span class="variable">productA2</span> <span class="operator">=</span> factory2.createProductA();</span><br><span class="line">        <span class="type">ProductB</span> <span class="variable">productB2</span> <span class="operator">=</span> factory2.createProductB();</span><br><span class="line">        productA2.display();</span><br><span class="line">        productB2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>抽象工厂模式能够保证一系列相关的产品一起使用，并且在不修改客户端代码的情况下，可以方便地替换整个产品系列。但是当需要增加新的产品类时，除了要增加新的具体产品类，还需要修改抽象工厂接口及其所有的具体工厂类，扩展性相对较差。因此抽象工厂模式特别适用于一系列相关或相互依赖的产品被一起创建的情况，典型的应用场景是<strong>使用抽象工厂模式来创建与不同数据库的连接对象。</strong></p>
<h3 id="简单工厂、工厂方法、抽象工厂的区别"><a href="#简单工厂、工厂方法、抽象工厂的区别" class="headerlink" title="简单工厂、工厂方法、抽象工厂的区别"></a>简单工厂、工厂方法、抽象工厂的区别</h3><ul>
<li>简单工厂模式：一个工厂方法创建所有具体产品</li>
<li>工厂方法模式：一个工厂方法创建一个具体产品</li>
<li>抽象工厂模式：一个工厂方法可以创建一类具体产品</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统--操作系统主要类型</title>
    <url>/2020/03/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%BB%E8%A6%81%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h2><h3 id="单道批处理系统处理流程"><a href="#单道批处理系统处理流程" class="headerlink" title="单道批处理系统处理流程"></a>单道批处理系统处理流程</h3><img data-src="/images/操作系统主要类型/4QMJfoxRIXGiu9C.png" alt="image.png" style="zoom:67%;" />

<h3 id="多道批处理操作系统处理流程"><a href="#多道批处理操作系统处理流程" class="headerlink" title="多道批处理操作系统处理流程"></a>多道批处理操作系统处理流程</h3><span id="more"></span>

<img data-src="/images/操作系统主要类型/shlfUxnFIu23wdZ.png" alt="image.png" style="zoom:67%;" />

<h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><p><strong>工作方式：</strong></p>
<p><img data-src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%BB%E8%A6%81%E7%B1%BB%E5%9E%8B/clip_image001.png"></p>
<p>特性：</p>
<ol>
<li>独立性   2. 同时性   3. 交互性   4.及时性</li>
</ol>
<h3 id="分时操作系统和批处理操作系统的区别"><a href="#分时操作系统和批处理操作系统的区别" class="headerlink" title="分时操作系统和批处理操作系统的区别"></a>分时操作系统和批处理操作系统的区别</h3><h4 id="1-追求目标不同"><a href="#1-追求目标不同" class="headerlink" title="1.追求目标不同"></a>1.追求目标不同</h4><p>批处理操作系统一提高系统利用率和吞吐量为主要目标</p>
<p>分时操作系统是为了满足人机交互的需求，方便用户使用</p>
<h4 id="2-使用作业不同"><a href="#2-使用作业不同" class="headerlink" title="2.使用作业不同"></a>2.使用作业不同</h4><p>批处理操作系统适合非交互性的大型作业</p>
<p>分时系统适合交互性的小型作业</p>
<h4 id="3-作业的控制方式不同"><a href="#3-作业的控制方式不同" class="headerlink" title="3.作业的控制方式不同"></a>3.作业的控制方式不同</h4><p>批处理系统是由用户利用作业控制语言，书写作业用户说明书，并预先提交给系统 属于脱机工作</p>
<p>分时系统是由用户直接从键盘敲入命令，来控制作业 属于联机工作</p>
<h4 id="4-资源利用率不同"><a href="#4-资源利用率不同" class="headerlink" title="4.资源利用率不同"></a>4.资源利用率不同</h4><p>批处理操作系统可以合理安排不同负载的作业，使得各种资源均匀工作，利用率高</p>
<p>分时操作系统，只有当多个终端作业使用同类型编译程序和公共子程序，且这些公共子程序是可重用代码的时候系统开销才会比较小</p>
<h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p><strong>主要功能和特征：</strong></p>
<ol>
<li>实时时钟管理</li>
<li>过载保护</li>
<li>高可靠性和安全性</li>
</ol>
<h3 id="分时操作系统和实时操作系统区别"><a href="#分时操作系统和实时操作系统区别" class="headerlink" title="分时操作系统和实时操作系统区别"></a>分时操作系统和实时操作系统区别</h3><h4 id="1-设计目标不同"><a href="#1-设计目标不同" class="headerlink" title="1.设计目标不同"></a>1.设计目标不同</h4><p>分时操作系统为用户提供一个通用的交互方式</p>
<p>实时操作系统则是为特殊用途提供的专用操作系统</p>
<h4 id="2-交互性强弱不同"><a href="#2-交互性强弱不同" class="headerlink" title="2.交互性强弱不同"></a>2.交互性强弱不同</h4><p>分时操作系统交互性强</p>
<p>实时操作系统交互性弱</p>
<h4 id="3-响应时间要求不同"><a href="#3-响应时间要求不同" class="headerlink" title="3.响应时间要求不同"></a>3.响应时间要求不同</h4><p>分时操作系统以用户能接受的响应时间为标准</p>
<p>实时操作系统与受控对象及应用场合有关，响应时间变化范围大</p>
<h2 id="微机操作系统"><a href="#微机操作系统" class="headerlink" title="微机操作系统"></a>微机操作系统</h2><p>1.单用户单任务（MS DOS）</p>
<p>2.单用户多任务（Windows）</p>
<p>3.多用户多任务</p>
<h2 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h2><h3 id="工作模式："><a href="#工作模式：" class="headerlink" title="工作模式："></a>工作模式：</h3><ol>
<li><p>客户服务器模式（client&#x2F;server，C&#x2F;S）模式</p>
</li>
<li><p>对等（Peer-to-Peer）模式</p>
</li>
</ol>
<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><ol>
<li>网络通信</li>
<li>资源管理</li>
<li>网络服务（SMTP）</li>
<li>网络管理</li>
<li>互操作能力（NFS）</li>
</ol>
<h2 id="多CPU操作系统"><a href="#多CPU操作系统" class="headerlink" title="多CPU操作系统"></a>多CPU操作系统</h2><h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h3><ol>
<li>分布式进程通信</li>
<li>分布式文件系统</li>
<li>分布式进程迁移</li>
<li>分布式进程同步</li>
<li>分布式进程死锁</li>
</ol>
<h2 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ol>
<li>微型化</li>
<li>可定制化</li>
<li>实时性</li>
<li>易移植性</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统--操作系统的中断</title>
    <url>/2020/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<h2 id="中断的概念"><a href="#中断的概念" class="headerlink" title="中断的概念"></a>中断的概念</h2><blockquote>
<p>中断是指在计算机执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得CPU暂时中断当前正在执行的程序而转去执行相应的时间处理程序。待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。</p>
</blockquote>
<h3 id="引入目的"><a href="#引入目的" class="headerlink" title="引入目的"></a>引入目的</h3><ol>
<li>解决CPU和I&#x2F;O设备之间的并行工作问题</li>
<li>实时实现控制</li>
</ol>
<h3 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a>中断的作用</h3><span id="more"></span>

<ol>
<li>实现CPU和I&#x2F;O设备并行工作</li>
<li>实现硬件故障处理</li>
<li>实现人机-联系</li>
<li>实现多道程序和分时操作</li>
<li>实现实时处理</li>
<li>实现应用程序和操作系统的联系</li>
<li>实现多处理机系统中处理机之间的联系</li>
</ol>
<h3 id="中断的特点"><a href="#中断的特点" class="headerlink" title="中断的特点"></a>中断的特点</h3><ul>
<li>随机性：在系统的运行过程中，中断事件随时可能出现</li>
<li>可恢复性：完成对某一事件的中断处理程序之后，系统会返回到原程序的断点处继续执行</li>
<li>自动性：在中断时间发生之后，进入中断、执行中断处理程序以及中断返回都是由系统自动完成的</li>
</ul>
<h3 id="中断在操作系统中的地位"><a href="#中断在操作系统中的地位" class="headerlink" title="中断在操作系统中的地位"></a>中断在操作系统中的地位</h3><ol>
<li>是多道程序并发执行的推动力</li>
<li>操作系统是由中断驱动的</li>
</ol>
<h2 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h2><pre class="mermaid">graph LR
A[中断]-->B[外中断]
B-->D[可屏蔽中断]
B-->E[不可屏蔽中断]
A-->C[内中断]
C-->F[自愿中断]
F-->G[系统调用]
F-->H[缺页中断]
F-->I[断点指令]
F-->J[其他程序性异常]
C-->K[强迫性中断]
K-->O[硬件故障中断]
K-->L[程序性中断]
K-->M[输入输出中断]
K-->N[外部中断]</pre>

<ul>
<li><p>内中断和外中断：中断来源是否来自计算机内部</p>
</li>
<li><p>外中断：来自CPU外的外部设备，通过硬件请求方式产生的强迫性中断</p>
</li>
<li><p>不可屏蔽中断：有就一定会执行中断</p>
</li>
<li><p>可屏蔽中断：在当前指令结束后，CPU根据中断允许标志位判断是否响应中断，通常用于CPU和外部设备之间的数据交换</p>
</li>
<li><p>强迫性中断：由随机事件和外部请求所引发的，引起强迫性中断的事件不是当前运行程序所期待的</p>
</li>
<li><p>自愿性中断：用户程序在使用中请求操作系统提供某种功能服务，通过执行一条访管指令，称为访管中断或陷阱，是当前运行程序所期待的，用户程序对操作系统的某种需求</p>
</li>
</ul>
<h2 id="中断的响应过程"><a href="#中断的响应过程" class="headerlink" title="中断的响应过程"></a>中断的响应过程</h2><pre class="mermaid">graph TB
A[发出中断信号]-->B[CPU完成当前指令的执行]
B-->C[CPU发送中断答应信号]-->D[关中断]
D-->E[CPU将PWS,PC和CS压入核心栈中]
E-->F[将中断处理程序的入口地址送入IP和CS]
F-->G[保存剩余的CPU状态信息]-->H[开中断]-->I[处理中断]
I-->J[恢复CPU的状态信息]-->K[恢复中断钱的PWS,PC和CS]</pre>

<h3 id="简单概括"><a href="#简单概括" class="headerlink" title="简单概括"></a>简单概括</h3><ol>
<li><p>发现中断源</p>
</li>
<li><p>保护和恢复现场</p>
</li>
<li><p>中断响应</p>
</li>
<li><p>保护现场和传递参数</p>
</li>
<li><p>执行相应的中断服务函数</p>
</li>
<li><p>恢复现场并退出中断</p>
</li>
</ol>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p><img data-src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%AD%E6%96%AD/RXkpNUiVHOa2Y48.png"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统--操作系统的形成与发展</title>
    <url>/2020/03/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BD%A2%E6%88%90%E4%B8%8E%E5%8F%91%E5%B1%95/</url>
    <content><![CDATA[<h2 id="操作系统的形成时期"><a href="#操作系统的形成时期" class="headerlink" title="操作系统的形成时期"></a>操作系统的形成时期</h2><h3 id="手动操作时期"><a href="#手动操作时期" class="headerlink" title="手动操作时期"></a>手动操作时期</h3><img data-src="/images/操作系统的形成与发展/vuMCXHTLqJBOh5t.png" alt="image.png" style="zoom:80%;" />

<h4 id="存在缺点"><a href="#存在缺点" class="headerlink" title="存在缺点"></a>存在缺点</h4><ol>
<li><p>用户独占全部计算机资源</p>
</li>
<li><p>CPU等待人工操作</p>
</li>
<li><p>CPU与I&#x2F;O设备串行操作</p>
</li>
</ol>
<h3 id="监控程序阶段（早起批处理阶段）"><a href="#监控程序阶段（早起批处理阶段）" class="headerlink" title="监控程序阶段（早起批处理阶段）"></a>监控程序阶段（早起批处理阶段）</h3><img data-src="/images/操作系统的形成与发展/4QMJfoxRIXGiu9C.png" alt="单道批处理系统流程图" style="zoom:67%;" />

<p>单道批处理系统流程图  </p>
<span id="more"></span>

<h2 id="操作系统的成熟阶段"><a href="#操作系统的成熟阶段" class="headerlink" title="操作系统的成熟阶段"></a>操作系统的成熟阶段</h2><h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ol>
<li>程序浮动与存储保护问题</li>
<li>CPU的调度和管理问题</li>
<li>其他资源的管理和调度问题</li>
</ol>
<h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ol>
<li>人机交互</li>
<li>共享主机</li>
<li>便于用户上机</li>
</ol>
<img data-src="/images/操作系统的形成与发展/vrjo1l8dPaFKY7c.png" alt="image.png" style="zoom:67%;" />

<h2 id="进一步发展时期"><a href="#进一步发展时期" class="headerlink" title="进一步发展时期"></a>进一步发展时期</h2>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统--操作系统的概述</title>
    <url>/2020/03/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="计算机的组成"><a href="#计算机的组成" class="headerlink" title="计算机的组成"></a>计算机的组成</h3><p>硬件+软件</p>
<h3 id="引入操作系统的目的"><a href="#引入操作系统的目的" class="headerlink" title="引入操作系统的目的"></a>引入操作系统的目的</h3><p>方便性、有效性、可扩充性和开放性</p>
<h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><ul>
<li>是计算机硬件和软件的管理者</li>
<li>是用户使用计算机硬件系统的借口</li>
<li>操作系统是扩展机&#x2F;虚拟机</li>
</ul>
<h3 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h3><p>操作系统是控制和管理计算机系统的软硬件资源、合理地组织计算机工作流程，</p>
<p>以及方便用户的程序和数据集合。</p>
<h4 id="单道批处理系统的特征"><a href="#单道批处理系统的特征" class="headerlink" title="单道批处理系统的特征"></a>单道批处理系统的特征</h4><ol>
<li><p>自动性:磁带上的一批作业能自动地逐个地依次运行，无需人工干预</p>
</li>
<li><p>顺序性:磁带上的各道作业是顺序地进入内存，各道作业的完成顺序与他们进入内存的顺序之间，在正常情况下应完全相同</p>
</li>
<li><p>单道性:内存中仅有一道程序运行。仅当该程序完成或发生异常情况时才换入其后继程序进入内存运行</p>
<span id="more"></span></li>
</ol>
<h3 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h3><ol>
<li>处理器管理</li>
<li>存储管理</li>
<li>设备管理</li>
<li>文件管理</li>
<li>用户接口</li>
<li>网络与通信管理</li>
</ol>
<h3 id="操作系统基本特征"><a href="#操作系统基本特征" class="headerlink" title="操作系统基本特征"></a>操作系统基本特征</h3><ol>
<li><p>并发性</p>
</li>
<li><p>共享性</p>
<p>a）互斥使用方式   b）同时使用方式</p>
</li>
<li><p>虚拟性</p>
</li>
<li><p>不确定性</p>
<p>a）“走走停停的执行方式”   b）执行结果的不确定性   c）不可预测性</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《时生》读后感</title>
    <url>/2020/03/13/%E6%97%B6%E7%94%9F%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="cc39bf6ec704a750dfffc865f757175a67089917c4acfc0b917b5695b484686b">99b23c07cf5459d82b841027c3c807692406904c9cdec0bc8f28066ea87dde19a1b9ceef5beb8f9ba13a0ed352d476ec6297e681670ed24acbded89053f870c412c04491a4f3d17ae06dca0fbea6f27895f5c864049aaa6a334cf5d9e3d716a02e7c3882526026a69c6884df09db35c26aaef80b4496e31649d95467330937ccbf61cc7e1a24c029190c5f69114cc37ea5da45a8d42ee31eba70926372eb022bde5d00e6ee0b4069570e2ac34e6463e2c779b6a2cd03d1f41336238f0baaef550b6865280bd66e51caaca436e2606a621f62ebece58aeeb3dacd3a06b560dc68589091072949b7f6e23452d4763397d1174110a6c8ef942ac4ed8563425788497d13fd83327b94433be26c81cba5bd90a2598caf86cc1cbb497d941853e944d7e5c8fc36c475613a8083360e6c04e4dfcc0cb323a3880c24fd636ec283a03949b5d3c8a207b7ff6cf8b6813bdb95a1acfaad1ddc10ed15305842d926bb061dabdd39eb3ac40782171986acaa9e3094d3fc57343bd9e1632b9fe5ca3679f03bbff5275b3f00d50a06436e9893f1eb125f006bc07c034213dff73e97a8fa5045cca9be4ce9f4e0c7a55d284888ff536c389fa49d9652f067c3e98391c9471622340182ee96b0d42619721fbc0c5c6e72914f4e283ee553a316534e7c00a21067eaade2cb45cb4915a3c9107dd14cbcffeca016e9618e45cd8f4061d52f9700704bcd8940741fc31b21c14fd111004d1e19edcef3b85b630716e8fa43dc2639cb9519b4c49fbf3b0c551286c2e7c018aa84036c687f74953607dd06421ff3e6156b4ac37df1959a74a901c3f2334cb4c49ef97826b2ce8d6b0116bfd4553a7dafb5bab058d1a38f3b7d5472a939935a63117a6c5673e01552c00dc45f61da2656a7d1928c9dc90184408d67a04a1fdf60dec2af7cb29403ec743a0a04cdc4855fb5171797a525e09946f1e5436ed6d1a899241f764067537832ef7fd7a099c07379892fa9d0349e25465a6f7cdb069d75cb5ba491fd5710579f4a26337f4f4cc2e432e7ecfd30bdf73b18d509ed0642187ccb1aea5cc6961a4156c7860eb464c357aeb625ec42b52f61af21e6f5b639d54801bf3018787247f4666bdfe15cd4539c38293518a7e06d98813f086d16661a92c63f8acb50bf83a9b51571a864f5f9b3fc5db286f910a110acc5968fc9c49fe62ac1b0a84aaab47965203949cb33da0712adab1a1309acec4d9f0006b6a7b015812f596597a4d294f40ad0837dedffe23abd0f863b771b28d6ac80f7ca13b1826243464ca8643d6aacb9c9b8279be8061a4ceecd77f414440e894d2b4a5633939c877f73e14a23110ffb120dbb9c80775d72038b7d6cad46efd54e18ba1eebc143c8c2fa9aae40c60a2794118ce068f908dc5b81e5428fdfebd867dd826cbed5ad50f0e320008d8d572792fbc04dfd8836b09e62a55009f4d0aa6d22f1e8b3b97aef561f901b471fb27551b17f4c1caed7eba0ec086d885752e1084efc542af26124fd5dde450f1c39da395addcce60517c967a44ca5f5862df91fccaf6c4ad087d7a8a6c62ae1795f9c1433507cda82eaea1179054f6c81c99fc7b1ff7a5f0787971e13b5de77143a226a9f9f0b2bbe7691159c7ccfc4fdebbc18cbde262d08b190d46a66a87368c78e51169f8782025698d47ac01b81883f8684cf37af874aa6c644d6d677d5d00cfedfd971779c93ad3c2ce6aac5118b758244f68b70aac3201a7ebe12fa222603eb2115c631482a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码进行查看</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>感悟</category>
        <category>小说</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法模式</title>
    <url>/2024/07/16/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在看HDA代码的时候发现其中对于归档任务和清理任务的设计用了模板方法的设计模式，详细学习记录了一下。</p>
<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>模板方法定义了一个算法的步骤，并允许子类为其中的一些步骤提供具体的实现方式。这种模式让子类在不需要改变整体结构的情况下，可以重新定义算法的具体步骤。<br>一般来说，我们在抽象类中定义一个算法的步骤和流程，子类按需重写抽象类中的抽象方法。</p>
<h1 id="具体实现案例"><a href="#具体实现案例" class="headerlink" title="具体实现案例"></a>具体实现案例</h1><span id="more"></span>

<ol>
<li>HDA示例<br>下面为HDA归档和清理任务的UML类图：<br><img data-src="/../images/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/IMG-20240716110435705.png"></li>
</ol>
<p>从上图可以很清楚的看出这几个类之间的结构，<code>ArchiveTask</code>和<code>CleanTask</code>作为具体的实现类，继承了抽象类<code>AbstractTask</code>，抽象类又实现了一个<code>ITask</code>的接口，接口中定义了算法中必须要实现的方法，强制性的定义了算法的必须要实现的方法，具体的任务执行方法<code>execute</code>和错误处理方法<code>HandleError</code>就要在两个子类中分别进行实现了，抽象类中提供了三个模板方法分别是<code>isInterrupt</code>、<code>getSummaryDescription</code>和<code>getErrorTableLog</code>，这是三个通用的方法，抽象出来放在父类中。</p>
<p>这里模板方法没有用到钩子方法，钩子方法是在模板方法的父类中定义一个方法，它默认可以不做任何事，子类可以根据实际情况来重写，这样的方法称为“钩子”。</p>
<p>HDA这里两个子类中还有很多相同的方法，可以再进一步抽象到父类中。</p>
<ol start="2">
<li>示例二<br><img data-src="/../images/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/IMG-20240716111224227.png"></li>
</ol>
<p>抽象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类AbstractDisplay</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractDisplay</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交给子类去实现的抽象方法(1) open</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交给子类去实现的抽象方法(2) print</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交给子类去实现的抽象方法(3) close</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本抽象类中实现的display方法，模板方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 首先打开…</span></span><br><span class="line">        open();</span><br><span class="line">        <span class="comment">// 循环调用5次print</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// …最后关闭。这就是display方法所实现的功能</span></span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>子类：CharDisplay</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CharDisplay是AbstractDisplay的子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharDisplay</span> <span class="keyword">extends</span> <span class="title class_">AbstractDisplay</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要显示的字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> ch;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CharDisplay</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="comment">// 保存在字段中</span></span><br><span class="line">        <span class="built_in">this</span>.ch = ch;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 显示开始字符&quot;&lt;&lt;&quot;</span></span><br><span class="line">        System.out.print(<span class="string">&quot;&lt;&lt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 显示保存在字段ch中的字符</span></span><br><span class="line">        System.out.print(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 显示结束字符&quot;&gt;&gt;&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>子类：StringDisplay</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * StringDisplay也是AbstractDisplay的子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDisplay</span> <span class="keyword">extends</span> <span class="title class_">AbstractDisplay</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要显示的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以字节为单位计算出的字符串长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringDisplay</span><span class="params">(String string)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.string = string;</span><br><span class="line">        <span class="comment">// 将字符串的字节长度也保存在字段中，以供后面使用</span></span><br><span class="line">        <span class="built_in">this</span>.width = string.getBytes().length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用该类的printLine方法画线</span></span><br><span class="line">        printLine();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 给保存在字段中的字符串前后分别加上&quot;|&quot;并显示出来</span></span><br><span class="line">        System.out.println(<span class="string">&quot;|&quot;</span> + string + <span class="string">&quot;|&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 与open方法一样，调用printLine方法画线</span></span><br><span class="line">        printLine();</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被open和close方法调用。由于可见性是private，因此只能在本类中被调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLine</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 显示表示方框的角的&quot;+&quot;</span></span><br><span class="line">        System.out.print(<span class="string">&quot;+&quot;</span>);                </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; width; i++) &#123;</span><br><span class="line">            <span class="comment">// 显示width个&quot;-&quot;,和&quot;+&quot;一起组成边框</span></span><br><span class="line">            System.out.print(<span class="string">&quot;-&quot;</span>);                      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 显示表示方框的角的&quot;+&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;+&quot;</span>);                </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成一个持有&#x27;H&#x27;的CharDisplay类的实例</span></span><br><span class="line">        <span class="type">AbstractDisplay</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharDisplay</span>(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成一个持有&quot;Hello, world.&quot;的StringDisplay类的实例</span></span><br><span class="line">        <span class="type">AbstractDisplay</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringDisplay</span>(<span class="string">&quot;Hello, world.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成一个持有&quot;你好，世界。&quot;的StringDisplay类的实例</span></span><br><span class="line">        <span class="type">AbstractDisplay</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringDisplay</span>(<span class="string">&quot;你好，世界。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 由于d1、d2和d3都是AbstractDisplay类的子类</span></span><br><span class="line"><span class="comment">         * 可以调用继承的display方法</span></span><br><span class="line"><span class="comment">         * 实际的程序行为取决于CharDisplay类和StringDisplay类的具体实现</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        d1.display();</span><br><span class="line">        d2.display();</span><br><span class="line">        d3.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;HHHHH&gt;&gt;</span><br><span class="line">+-------------+</span><br><span class="line">|Hello, world.|</span><br><span class="line">|Hello, world.|</span><br><span class="line">|Hello, world.|</span><br><span class="line">|Hello, world.|</span><br><span class="line">|Hello, world.|</span><br><span class="line">+-------------+</span><br><span class="line"></span><br><span class="line">+------------------+</span><br><span class="line">|你好，世界。|</span><br><span class="line">|你好，世界。|</span><br><span class="line">|你好，世界。|</span><br><span class="line">|你好，世界。|</span><br><span class="line">|你好，世界。|</span><br><span class="line">+------------------+</span><br><span class="line">Process finished with exit code 0</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>优点<ul>
<li>统一了算法，同时也提供了一定的灵活性。父类中的模板方法确保了算法的结构保持不变，同时由子类提供一些具体方法的实现。</li>
<li>实现了最大化的代码复用。父类中的模板方法和已实现的某些步骤子类可以直接复用，而如果模板方法需要修改也只要修改一个类即可，对子类的调用来说的透明的，不需要进行修改。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式基本规则</title>
    <url>/2024/08/04/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h1 id="常用元字符"><a href="#常用元字符" class="headerlink" title="常用元字符"></a>常用元字符</h1><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.</td>
<td align="left">匹配除换行(\r、\n)符以外的任意字符</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">匹配字母或数字或下划线</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配任意的空白符</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">匹配数字</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">匹配单词的开始或结束</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">匹配字符串的开始</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配字符串的结束</td>
</tr>
<tr>
<td align="left">[\s\S]</td>
<td align="left">匹配所有，\s是匹配所有空白符，包括换行,\S非空白符不包括换行</td>
</tr>
</tbody></table>
<h1 id="常用限定符"><a href="#常用限定符" class="headerlink" title="常用限定符"></a>常用限定符</h1><table>
<thead>
<tr>
<th align="left">代码&#x2F;语法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">*</td>
<td align="left">重复零次或更多次</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">重复一次或更多次</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">重复零次或一次</td>
</tr>
<tr>
<td align="left">n</td>
<td align="left">重复n次</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">重复n次或更多次</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">重复n到m次</td>
</tr>
</tbody></table>
<h1 id="常用反义词"><a href="#常用反义词" class="headerlink" title="常用反义词"></a>常用反义词</h1><table>
<thead>
<tr>
<th align="left">代码&#x2F;语法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\W</td>
<td align="left">匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配任意不是空白符的字符</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">匹配任意非数字的字符</td>
</tr>
<tr>
<td align="left">\B</td>
<td align="left">匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td align="left">[^x]</td>
<td align="left">匹配除了x以外的任意字符</td>
</tr>
<tr>
<td align="left">[^aeiou]</td>
<td align="left">匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody></table>
<h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><table>
<thead>
<tr>
<th>代码&#x2F;语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>exp1(?&#x3D;exp2)</strong></td>
<td>查找 exp2 前面的 exp1</td>
</tr>
<tr>
<td><strong>(?&lt;&#x3D;exp2)exp1</strong></td>
<td>查找 exp2 后面的 exp1</td>
</tr>
<tr>
<td><strong>exp1(?!exp2)</strong></td>
<td>查找后面不是 exp2 的 exp1</td>
</tr>
<tr>
<td><strong>(?&lt;!exp2)exp1</strong></td>
<td>查找前面不是 exp2 的 exp1</td>
</tr>
</tbody></table>
<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="https://www.runoob.com/regexp/regexp-syntax.html">https://www.runoob.com/regexp/regexp-syntax.html</a></p>
<p><a href="https://www.w3cschool.cn/tools/index?name=reg">正则表达式在线测试</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝、浅拷贝和引用拷贝</title>
    <url>/2024/01/07/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h1><ul>
<li>浅拷贝：对于对象内的引用数据类型，浅拷贝会直接复制其对象的地址，也就是拷贝对象和原对象公用一个内部对象。</li>
<li>深拷贝：会完全复制整个对象，包括对象所包含的内部对象，都是新创建的对象。</li>
</ul>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝的示例代码如下，我们这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p>
<p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

<p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p>
<span id="more"></span>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

<p>从输出结构就可以看出，显然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p>
<p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p>
<p><img data-src="/../images/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D/shallow&deep-copy.png" alt="浅拷贝、深拷贝、引用拷贝示意图"></p>
<p>参考：<a href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D">JavaGuide</a></p>
]]></content>
  </entry>
  <entry>
    <title>用ssh公钥配对登录服务器</title>
    <url>/2020/03/01/%E7%94%A8ssh%E5%85%AC%E9%92%A5%E9%85%8D%E5%AF%B9%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h3 id="1-生成公钥"><a href="#1-生成公钥" class="headerlink" title="1.生成公钥"></a>1.生成公钥</h3><p>ssh-keygen -t rsa -b 4096 -C “你的邮箱地址”</p>
<p><em>-t 指定加密算法； -b 指定生成的密钥长度； -C 一句话，一般都填邮箱地址。</em></p>
<p><em>更多参数说明可以在终端输入：ssh-keygen –help 查看</em></p>
<h3 id="2-将公钥写入远程主机"><a href="#2-将公钥写入远程主机" class="headerlink" title="2.将公钥写入远程主机"></a>2.将公钥写入远程主机</h3><p>在自己电脑上打开用户目录下的&#x2F;.ssh&#x2F;id_rsa.pub公钥文件，将其中的内容粘贴到服务器的、root&#x2F;.ssh&#x2F;authorized_keys目录的文件里面</p>
<h3 id="3-修改ssh配置文件，禁止密码登录，允许秘钥登录"><a href="#3-修改ssh配置文件，禁止密码登录，允许秘钥登录" class="headerlink" title="3.修改ssh配置文件，禁止密码登录，允许秘钥登录"></a>3.修改ssh配置文件，禁止密码登录，允许秘钥登录</h3><p>vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config </p>
<p>将里面的内容修改如下所示：</p>
<p># PubkeyAuthentication yes   中将#删除，允许秘钥登录</p>
<p>PasswordAuthentication yes  中yes修改为no，禁止密码登录</p>
<p><em>禁止密码登录可以防止暴力破解，虽然也没人来攻击</em></p>
<h3 id="4-重启ssh服务"><a href="#4-重启ssh服务" class="headerlink" title="4.重启ssh服务"></a>4.重启ssh服务</h3><p>service ssh restart</p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>研一学年总结与复盘</title>
    <url>/2023/10/12/%E7%A0%94%E4%B8%80%E5%AD%A6%E5%B9%B4%E6%80%BB%E7%BB%93%E4%B8%8E%E5%A4%8D%E7%9B%98/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b2a5510e90b42a7239f60c70d7c27a6a1a33e92e7fb3bce4d81996c4fe3aca40">99b23c07cf5459d82b841027c3c807698a1701dded89629b3aa053a0f5071939e188187b6b8e665c2dc48acb8fae7f1e9222cac1dca289ad01032f9c87f05e00e3a5ebfda7c07ff6f30e0747f3d43b57e43b95211d0f2a5029e5bef3d2b7f5b1b292c55689240030a03b34cd3c652c0dcd363fb89d8d9d03ed5e1bdb69369b83e9f3c728ef5aaee779dc63bfe6c1cf09faa793954ade9dece2cb5198b1148fb13d4eee3371b7cdb287b2f55623b362032732b156b9aff17d18a098910c07d7ce115d1f3acc38cb912e348df4e9402ca09dde9c6f988a8fd1ad2a0ce86bfb817248bae35eb3dcb8177ea3c633acedba5898b31b6ace39a7a2e45905de1615ee9a4fbf54194b9cdea637295418cd24f68b58092d467ef7bb7b98a59eef4bef632bc01db8c35c9ff11f09f581f744363f166801d1c5e0a48c6d8c5b62cb28aef3c506add145d0dfc6239077e103be01e1ab08517e255f6e8e6014122c28883b46a31cc29f1af6b56360eb0177c2eed2d62a869f0f94725b4f4c53722bdb367c9ecee3eb68fcfa598c16c50c6ed31302f1ed654b7180b1537d519ab438b04b36019fc9901b0ae0c830759a732de6e26a941d975894c8c751b15967b0dcebad59848c00d5871c5badb2cb50763b2383a87096763c3e5e80b5ded1171340773c723ee39d15b808b5df0d9bbb9521d0f7e045418508519e3662749923cd81abe77c43e7a07c4bba4c99f0f8c485d587c8fa7c0c8737489e2d8072af76bf9ff6b907a77145ae9e06595029d2d1a302a20e1ea1ac9cdb88f200bf30e6637366ef0e70f68d43e33e768a64d469bee967666ddf9ec958b5f0b8cc55d77526d102d15bde69151fa0e9dddea5dc772becd7747c6a220bc6ea270096ea981fff6b6abc0bb5189424f400660c3861c903446b0fc9a7a7711797957b4a6a8ca52d85658569135d56a53f9d414b4f2bfeeba8f001dc8f26e0e0724aa0065a36a483f95c85f5751ca8bcaaf5788f70fcc5da8fbe69d04997c5</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码进行查看</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2024/08/06/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>策略模式是一种行为型设计模式，他定义了一系列算法来使用不同的策略完成同一件工作，并将每个算法封装起来，使他们可以相互替换，而算法的变化不影响算法的使用。</p>
<p>比如电商网站对于商品的折扣策略会有不同的算法，比如新用户满减优惠，不同等级会员的折扣情况也不同，这种情况下会有大量的<code>if-else</code>，如果修改优惠政策，还要修改原来的代码，不符合开闭原则。</p>
<p>于是可以将不同的优惠算法封装成独立的类来避免大量的条件语句，如果新增优惠算法，也只需要添加新的策略类来实现，不需要修改原来的代码，调用的时候直接用不同的类来选择不同的优惠策略；</p>
<p><img data-src="/../images/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/IMG-20240806101212873.png"></p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>策略模式包含一下几个结构：</p>
<ul>
<li>策略接口<code>Strategy</code>：定义了所有支持的算法的各个接口</li>
<li>具体策略类<code>ConcreteStrategy</code>：实现了策略接口，提供具体的算法实现</li>
<li>上下文类<code>Context</code>：包含一个策略实例，并在需要的时候可以调用策略对象的方法</li>
</ul>
<span id="more"></span>
<h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 抽象策略抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 具体策略类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">extends</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Strategy A&quot;</span>);</span><br><span class="line">        <span class="comment">// 具体的策略1执行逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 具体策略类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">extends</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Strategy B&quot;</span>);</span><br><span class="line">        <span class="comment">// 具体的策略2执行逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 上下文类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置具体的策略</span></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.algorithmlnterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建上下文对象，并设置具体的策略</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">contextA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>());</span><br><span class="line">        <span class="comment">// 执行策略</span></span><br><span class="line">        contextA.contextInterface();</span><br><span class="line"></span><br><span class="line">        <span class="type">Context</span> <span class="variable">contextB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>());</span><br><span class="line">        contextB.contextInterface();u</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul>
<li>当一个系统根据业务场景需要动态地在集中算法中选择一种的时候，可以采用策略模式，例如根据用户的行为选择不同的计费策略。</li>
<li>代码中存在大量条件判断，条件判断的区别仅仅在于行为，也可以通过策略模式来消除这些条件语句。</li>
</ul>
<p>在已有的工具库中，Java 标准库中的 <code>Comparator</code> 接口就使用了策略模式，通过实现这个接口，可以创建不同的比较器（指定不同的排序策略）来满足不同的排序需求。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯单片机基本模块</title>
    <url>/2020/03/08/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="锁存器"><a href="#锁存器" class="headerlink" title="锁存器"></a>锁存器</h2><p>蓝桥杯这款单片机是用锁存器来实现引脚的复用的，所以代码写起来很麻烦，总是要开关锁存器</p>
<p>为了偷懒，可以用宏定义来定义每个锁存器打开的代码，也可以用函数来实现</p>
<p><strong>用宏定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Y4 P2 = (P2&amp;0x1f)|0x80;  <span class="comment">//led</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y5 P2 = (P2&amp;0x1f)|0xa0;  <span class="comment">//蜂鸣器和继电器</span></span></span><br><span class="line">P0 = <span class="number">0x40</span>; <span class="comment">//蜂鸣器</span></span><br><span class="line">P0 = <span class="number">0x10</span>；<span class="comment">//继电器</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y6 P2 = (P2&amp;0x1f)|0xc0; <span class="comment">//数码管位选</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y7 P2 = (P2&amp;0x1f)|0xe0; <span class="comment">//数码管段选</span></span></span><br></pre></td></tr></table></figure>

<p><strong>用函数：</strong></p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">select_channel</span><span class="params">(<span class="type">char</span> channel)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span>(channel)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0x80</span>; <span class="keyword">break</span>; <span class="comment">//led</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xa0</span>; <span class="keyword">break</span>; <span class="comment">//蜂鸣器和继电器</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xc0</span>; <span class="keyword">break</span>; <span class="comment">//数码管位选</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xe0</span>; <span class="keyword">break</span>; <span class="comment">//数码管段选</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数码管的显示问题"><a href="#数码管的显示问题" class="headerlink" title="数码管的显示问题"></a>数码管的显示问题</h2><p>初学者一般都是用延时来实现动态数码管的，但是当要实现的功能多起来了，用延时来实现动态数码管，数码管很容易会闪烁，整体效果就很不好了。</p>
<p>另外一种方法可以是用定时器来扫描数码管，每隔一段时间就进入中断服务函数执行数码管的扫描，只要中断间隔的时间小于人眼的视觉暂留（大概是0.1~0.4s），就看不出来数码管会闪烁了。但是这个方法也有缺点，缺点是整个系统每隔这么短的时间就必须要进入这个中断服务函数，很容易会影响、打断其他程序的执行。现在也有解决方法就是在不能被中断打断的功能执行前关掉中断的开关，执行完之后再打开，显然这个解决方法也只是权宜之计，关掉中断的开关有的时候会影响这个计时器的计时，获得的时间就不是很准确，但是误差会很小吧，十行代码51单片机几毫秒甚至更短的时间就可以执行完。所以第二种方法算是比较好的一种方法了，相对于第一种方法来说。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> smgd[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x07</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> smgw[]=&#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>&#125;;</span><br><span class="line"><span class="type">char</span> smgbuf[<span class="number">8</span>],smg_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">select_channel</span><span class="params">(<span class="type">char</span> channel)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span>(channel)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0x80</span>; <span class="keyword">break</span>; <span class="comment">//led</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xa0</span>; <span class="keyword">break</span>;	<span class="comment">//蜂鸣器和继电器</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xc0</span>; <span class="keyword">break</span>; <span class="comment">//数码管位选</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xe0</span>; <span class="keyword">break</span>; <span class="comment">//数码管段选</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>  <span class="comment">//总的初始化函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)</span><br><span class="line">    smgbuf[i] = <span class="number">10</span>;	<span class="comment">//做初始化，上电数码管全部是熄灭的</span></span><br><span class="line">  </span><br><span class="line">  P0 = <span class="number">0xff</span>;  <span class="comment">//关掉所有的LED</span></span><br><span class="line">  select_channel(<span class="number">4</span>);</span><br><span class="line">  P2&amp;= <span class="number">0x1f</span>;</span><br><span class="line">  </span><br><span class="line">  P0 = <span class="number">0x00</span>;  <span class="comment">//关掉继电器和蜂鸣器</span></span><br><span class="line">  select_channel(<span class="number">5</span>);</span><br><span class="line">  P2&amp;= <span class="number">0x1f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_timer</span><span class="params">()</span>	<span class="comment">//初始化计时器</span></span><br><span class="line">&#123;</span><br><span class="line">  TMOD = <span class="number">0x01</span>;</span><br><span class="line">  TH1 = <span class="number">0xf8</span>;</span><br><span class="line">  TL1 = <span class="number">0x2f</span>;<span class="comment">//2ms</span></span><br><span class="line">  EA = <span class="number">1</span>;</span><br><span class="line">  ET1 = <span class="number">1</span>;</span><br><span class="line">  TR1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">()</span>  <span class="comment">//数码管显示函数</span></span><br><span class="line">&#123;</span><br><span class="line">  smg_num++;</span><br><span class="line">  <span class="keyword">if</span>(smg_num &gt;= <span class="number">8</span>)</span><br><span class="line">    smg_num = <span class="number">0</span>;  <span class="comment">//从0-7循环扫描每一个数码管</span></span><br><span class="line">  </span><br><span class="line">  P0 = <span class="number">0xff</span>;</span><br><span class="line">	select_channel(<span class="number">7</span>);</span><br><span class="line">	P2&amp;= <span class="number">0x1f</span>;		<span class="comment">//消影</span></span><br><span class="line">	</span><br><span class="line">	P0 = <span class="number">0x00</span>;</span><br><span class="line">	select_channel(<span class="number">6</span>);</span><br><span class="line">	P0 = smgw[smg_num];</span><br><span class="line">	P2&amp;= <span class="number">0x1f</span>;</span><br><span class="line">	</span><br><span class="line">	P0 = <span class="number">0xff</span>;</span><br><span class="line">	select_channel(<span class="number">7</span>);</span><br><span class="line">	P0 = ~smgd[smgbuf[smg_num]];</span><br><span class="line">	P2&amp;= <span class="number">0x1f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> i;</span><br><span class="line">  init();</span><br><span class="line">  init_timer();</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">      smgbuf[i] = i;  <span class="comment">//数码管一次显示0-7</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer1</span><span class="params">()</span> interrupt 3</span><br><span class="line">&#123;</span><br><span class="line">  display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是直接在Typora上面写的，没有编译，应该没有很大问题（手动滑稽）</p>
<p>这样写要改变数码管的值只要改变数组smgbuf[]中的值就行了0-9的数字是和编号一一对应的，其他的特殊符号可以自己手动加。</p>
]]></content>
      <categories>
        <category>备赛</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>脚本一键部署hexo</title>
    <url>/2020/04/29/%E8%84%9A%E6%9C%AC%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2hexo/</url>
    <content><![CDATA[<blockquote>
<p>研究了一下午Windows的批处理文件一个文件只能执行一条语句，执行完之后就直接退出了</p>
<p>解决方法是每条语句放在一个文件里面，通过call调用批处理的文件来执行里面的命令，很简单的几句话要分到好几个文件里面，很不方便。</p>
<p>于是就又看了一下shell脚本，比Windows的批处理脚本要强大太多，shell脚本要在Windows下执行需要安装相关的软件才可以，本版管理工具git的bash命令也可以运行shell脚本。</p>
<p>Windows的批处理脚本主要是不需要安装其他的东西了，可以实现一些简单的功能；但是作为一个码农电脑一般都装了这些相关的可以运行sh脚本的软件，所以用shell脚本也是没问题的，当然用Python写的脚本肯定跟强大，但是要学的东西肯定也跟多。</p>
</blockquote>
<h2 id="windows批处理bat脚本"><a href="#windows批处理bat脚本" class="headerlink" title="windows批处理bat脚本"></a>windows批处理bat脚本</h2><p>主文件</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> .\clean.bat</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 清理完毕</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> .\copyd.bat</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 图片复制完毕</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> .\push.bat</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 编译、部署完毕</span><br><span class="line"></span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>clean.bat</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 开始清理</span><br><span class="line"></span><br><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>copyd.bat</p>
<p>这个名字取成copyd主要是怕和系统的关键字或者保留字冲突</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 开始复制图片</span><br><span class="line"></span><br><span class="line"><span class="built_in">xcopy</span> E:\TanXY\Pictures\typora .\source\images\ /e /y </span><br></pre></td></tr></table></figure>

<p>push.bat</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 开始编译部署</span><br><span class="line"></span><br><span class="line">hexo generate -d</span><br></pre></td></tr></table></figure>

<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">!/bin/sh</span></span><br><span class="line">cp -r E:/TanXY/Pictures/typora/* ./source/images/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-r表示递归</span></span><br><span class="line">echo -e &quot;\e[40;33m图片复制完毕\e[0m&quot;</span><br><span class="line">hexo clean</span><br><span class="line">echo -e &quot;\e[40;33m清理完毕\e[0m&quot;</span><br><span class="line">hexo g -d</span><br><span class="line">echo -e &quot;\e[40;33m编译部署完毕\e[0m&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-e是设置输出的颜色这里40代表黑色的背景，33是黄色字体。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式是\e[背景颜色;字体颜色m显示的内容\e[0m</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不过不想搞得这么花里胡哨就直接忽略吧（滑稽）</span></span><br><span class="line"></span><br><span class="line">read -s -n 1 -p &quot;按任意键退出 ... &quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-s输内容入不显示出来  -n指定参数个数，这里是1个  -p提示语句</span>  </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯单片机按键</title>
    <url>/2020/04/03/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E6%8C%89%E9%94%AE/</url>
    <content><![CDATA[<blockquote>
<p>蓝桥杯这块板子有矩阵按键和独立按键，可以根据换跳帽来切换，下面简单介绍一下这两种按键的程序和基本的原理。</p>
<p>其他51的板子原理也基本相同，下面的代码也可以参考。</p>
</blockquote>
<h2 id="独立按键"><a href="#独立按键" class="headerlink" title="独立按键"></a>独立按键</h2><p>相对于矩阵按键，独立按键简单很多，就只有四个按钮，判断四个按键哪个被按下的情况较为简单</p>
<p>独立按键的写法也不止一种，这里就介绍两种</p>
<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a><strong>方法一：</strong></h3><p>实现比较简单，就是一个个判断，检测到为低电平的话就判断按键按下了。</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先对每个按键进行位定义</span></span><br><span class="line">sbit S7  = P3^<span class="number">0</span>;</span><br><span class="line">sbit S6  = P3^<span class="number">1</span>;</span><br><span class="line">sbit S5  = P3^<span class="number">2</span>;</span><br><span class="line">sbit S4  = P3^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//然后逐一判断哪个按键被按下</span></span><br><span class="line">  <span class="keyword">if</span>(S4 == <span class="number">0</span>)<span class="comment">//按键按下之后会检测到低电平，所以对应引脚检测到低电平就视为按键被按下了</span></span><br><span class="line">  &#123;</span><br><span class="line">    delay(<span class="number">5</span>);<span class="comment">//延时消抖</span></span><br><span class="line">    <span class="keyword">if</span>(S4 == <span class="number">0</span>)<span class="comment">//再次检测电平信号</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//按键具体功能的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(S5 == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    delay(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(S5 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//按键具体功能的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(S6 == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    delay(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(S6 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//按键具体功能的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(S7 == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    delay(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(S7 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//按键具体功能的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a><strong>方法二：</strong></h3><p>检测P3口的低四位，若S4被按下，则第四位P3^3为0，所以P3&amp;0xf的值为0x07，其他三个按键也以此类推。这种方法把按键的检测程序和功能程序分开了，如果不想要按下按键后按键里面的功能一直执行的话，按键功能每次执行完要把按键的值归零，否则单片机会一直执行那个按键里面的功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> press_flag = <span class="number">0</span>,key_value = <span class="number">0</span>;<span class="comment">//按下标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>((P3&amp;<span class="number">0x0f</span>) != <span class="number">0x0f</span>&amp;&amp;!press_flag)</span><br><span class="line">	&#123;</span><br><span class="line">    delay(<span class="number">50</span>);</span><br><span class="line">    <span class="keyword">if</span>((P3&amp;<span class="number">0x0f</span>) != <span class="number">0x0f</span>&amp;&amp;!press_flag)</span><br><span class="line">    &#123;</span><br><span class="line">      press_flag = <span class="number">1</span>;<span class="comment">//按键被按下过后将按下标志置为1</span></span><br><span class="line">      <span class="keyword">switch</span>(P3&amp;<span class="number">0x0f</span>)<span class="comment">//按下的按键对应的为0，与0x0f相与可以判断哪个按键被按下</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x07</span>: key_value = <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x0b</span>: key_value = <span class="number">5</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x0d</span>: key_value = <span class="number">6</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x0e</span>: key_value = <span class="number">7</span>; <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((P3&amp;<span class="number">0x0f</span>) == <span class="number">0x0f</span>&amp;&amp;press_flag)<span class="comment">//当没有按键按下但是按下标志为1的时候，要将按下标志置为0</span></span><br><span class="line">		press_flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_func</span><span class="params">()</span><span class="comment">//按键的功能函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span>(key_value)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">/*按键具体功能*/</span> key_value = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: <span class="comment">/*按键具体功能*/</span> key_value = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">/*按键具体功能*/</span> key_value = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: <span class="comment">/*按键具体功能*/</span> key_value = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="矩阵按键"><a href="#矩阵按键" class="headerlink" title="矩阵按键"></a>矩阵按键</h2><p>相对于独立按键来说，矩阵按键相对是要复杂一点，这里就介绍一种方法</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>这个方法和上面独立按键的方法2实现的思路差不多。因为51单片机的资源很有限，所以这里用了八个引脚来实现一个4×4的矩阵按键。这里对照一下原理图：</p>
<img data-src="/images/蓝桥杯单片机按键/OlN6gpyH14z89KR.png" alt="image.png" style="zoom: 67%;" />

<p>第一步：列扫描，先将P3的低四位置为0，高四位置为1，但是这款单片机的P36和P37被P42和P44代替了，所以P42和P44要单独位定义，然后将其置为1。初始值设置完之后就要进行检测了，因为P3的低四位为0，所以当按键按下时接到对应列的那条线会被拉到低电平P44对应的是第一列，其他参照上面的原理图以此类推。</p>
<p>第二部：行扫描，反过来，将P3的低四位置为1，高两位以及P42和P44置为0，哪一行的按键被按下对应行的值会被置为0，这一步和上面独立按键的扫描相似。</p>
<p>经过行和列的扫描就可以确定下来是那个一个按键被按下了，行和列就可以看成是横坐标和纵坐标，这里是先确定纵坐标，再确定横坐标，通过这样的一个坐标就可以确定被按下按键的位置。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sfr P3 = <span class="number">0xc0</span>;</span><br><span class="line">sbit P42 = P4^<span class="number">2</span>;</span><br><span class="line">sbit P44 = P4^<span class="number">4</span>;</span><br><span class="line">sbit P34 = P3^<span class="number">4</span>;</span><br><span class="line">sbit P35 = P3^<span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> key_value = <span class="number">0</span>,key_past = <span class="number">0</span>,key_now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  P3 = <span class="number">0xf0</span>;<span class="comment">//将低四位置为0，高四位和P42、P44置为1</span></span><br><span class="line">	P42 = <span class="number">1</span>;</span><br><span class="line">	P44 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(P42 != <span class="number">1</span>||P44 != <span class="number">1</span>||P34 != <span class="number">1</span>||P35 != <span class="number">1</span>)<span class="comment">//如果有按键被按下对应引脚会被置为0</span></span><br><span class="line">	&#123;</span><br><span class="line">		key_past = key_now;</span><br><span class="line">		key_now = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(!(key_past == <span class="number">1</span>&amp;&amp;key_now == <span class="number">1</span>))<span class="comment">//按键的松手检测</span></span><br><span class="line">			delay(<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">if</span>((P42 != <span class="number">1</span>||P44 != <span class="number">1</span>||P34 != <span class="number">1</span>||P35 != <span class="number">1</span>)&amp;&amp;!(key_past == <span class="number">1</span>&amp;&amp;key_now == <span class="number">1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(P44 == <span class="number">0</span>) key_value = <span class="number">4</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(P42 == <span class="number">0</span>) key_value = <span class="number">8</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(P35 == <span class="number">0</span>) key_value = <span class="number">12</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(P34 == <span class="number">0</span>) key_value = <span class="number">16</span>;</span><br><span class="line">			P3 = <span class="number">0x0f</span>;</span><br><span class="line">			P42 = <span class="number">0</span>;</span><br><span class="line">			P44 = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">switch</span>(P3&amp;<span class="number">0x0f</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">0x07</span>: key_value += <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">0x0b</span>: key_value += <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">0x0d</span>: key_value += <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">0x0e</span>: key_value += <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		key_past = key_now;</span><br><span class="line">		key_now = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里没有写按键的功能函数，这个就和独立按键的第二种方法类似，传入key_value的值然后执行对应的功能函数，执行完一次之后如果不想要一直执行的话就在执行完之前将key_value的值归零。</p>
]]></content>
      <categories>
        <category>备赛</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯单片机超声波模块</title>
    <url>/2020/03/13/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<blockquote>
<p>这个超声波模块的工作原理很简单，传感器像两个喇叭一样的东西，一个是负责发送超声波的，另一个负责接收超声波，根据发出到接收的时间间隔就可以算出距离了。</p>
<p>s &#x3D; v*t&#x2F;2 </p>
<p>初中物理知识哦。</p>
</blockquote>
<p>就不多说了直接上代码</p>
<span id="more"></span>

<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> sonic_counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> smgbuf[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> distance;</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(sonic_counter &gt;= <span class="number">40</span>)<span class="comment">//每隔一定的时间测量一次，必须要加否则测的数据不正确</span></span><br><span class="line">		&#123;</span><br><span class="line">			distance = measure_distance();</span><br><span class="line">			sonic_counter = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		smgbuf[<span class="number">5</span>] = distance/<span class="number">100</span>;</span><br><span class="line">		smgbuf[<span class="number">6</span>] = distance%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">		smgbuf[<span class="number">7</span>] = distance%<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer2</span><span class="params">()</span> interrupt 12<span class="comment">//定时器2（52单片机多出来的一个定时器）</span></span><br><span class="line">&#123;</span><br><span class="line">	sonic_counter++;</span><br><span class="line">	display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>common.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _COMMON_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _COMMON_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sonic.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sfr AUXR = <span class="number">0x8e</span>;</span><br><span class="line">sfr IE2 = <span class="number">0xaf</span>;</span><br><span class="line">sfr T2H = <span class="number">0xd6</span>;</span><br><span class="line">sfr T2L = <span class="number">0xd7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">select_channel</span><span class="params">(<span class="type">char</span> channel)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_timer</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>common.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> smgw[<span class="number">8</span>] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> smgd[] = &#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x07</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line"><span class="type">char</span> smgbuf[<span class="number">8</span>],num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">select_channel</span><span class="params">(<span class="type">char</span> channel)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span>(channel)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0x80</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xa0</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xc0</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xe0</span>; <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">		smgbuf[i] = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	P0 = <span class="number">0xff</span>;</span><br><span class="line">	select_channel(<span class="number">4</span>);</span><br><span class="line">	P2&amp;= <span class="number">0x1f</span>;</span><br><span class="line">	</span><br><span class="line">	P0 = <span class="number">0x00</span>;</span><br><span class="line">	select_channel(<span class="number">5</span>);</span><br><span class="line">	P2&amp;= <span class="number">0x1f</span>;</span><br><span class="line">	</span><br><span class="line">	init_timer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_timer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	AUXR = AUXR&amp;<span class="number">0x33</span>|<span class="number">0x10</span>;<span class="comment">//定时器2的配置</span></span><br><span class="line">	IE2 = <span class="number">0x04</span>;</span><br><span class="line">	T2H = <span class="number">0xf8</span>;</span><br><span class="line">	T2L = <span class="number">0x2f</span>;</span><br><span class="line">	EA = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	TMOD = <span class="number">0x01</span>;<span class="comment">//定时器1的配置，用于计算发送和接收之间的时间间隔</span></span><br><span class="line">	TH1 = <span class="number">0</span>;</span><br><span class="line">	TL1 = <span class="number">0</span>;</span><br><span class="line">	TR1 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	num++;</span><br><span class="line">	<span class="keyword">if</span>(num &gt;= <span class="number">8</span>)</span><br><span class="line">		num = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	P0 = <span class="number">0xff</span>;</span><br><span class="line">	select_channel(<span class="number">7</span>);</span><br><span class="line">	P2&amp;= <span class="number">0x1f</span>;</span><br><span class="line">	</span><br><span class="line">	P0 = <span class="number">0x00</span>;</span><br><span class="line">	select_channel(<span class="number">6</span>);</span><br><span class="line">	P0 = smgw[num];</span><br><span class="line">	P2&amp;= <span class="number">0x1f</span>;</span><br><span class="line">	</span><br><span class="line">	P0 = <span class="number">0xff</span>;</span><br><span class="line">	select_channel(<span class="number">7</span>);</span><br><span class="line">	P0 = ~smgd[smgbuf[num]];</span><br><span class="line">	P2&amp;= <span class="number">0x1f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sonic.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SONIC_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SONIC_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> somenop &#123;_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以参照原理图</span></span><br><span class="line">sbit tx = P1^<span class="number">0</span>;<span class="comment">//发送波传感器的引脚</span></span><br><span class="line">sbit rx = P1^<span class="number">1</span>;<span class="comment">//接收波传感器的引脚</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_wave</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">measure_distance</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>sonic.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sonic.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_wave</span><span class="params">()</span><span class="comment">//发送超声波</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//发送一组超声波</span></span><br><span class="line">	&#123;</span><br><span class="line">		tx = <span class="number">1</span>;</span><br><span class="line">		somenop;somenop;somenop;somenop;somenop;somenop;somenop;somenop;</span><br><span class="line">		tx = <span class="number">0</span>;</span><br><span class="line">		somenop;somenop;somenop;somenop;somenop;somenop;somenop;somenop;</span><br><span class="line">	&#125;</span><br><span class="line">	TR1 = <span class="number">1</span>;<span class="comment">//定时器1开始计时</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">measure_distance</span><span class="params">()</span><span class="comment">//计算、测量距离</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> distance;</span><br><span class="line">	send_wave();<span class="comment">//先发送</span></span><br><span class="line">	<span class="keyword">while</span>(rx == <span class="number">1</span>&amp;&amp;TF1 == <span class="number">0</span>);<span class="comment">//等待接收完毕或者定时器1溢出</span></span><br><span class="line">	TR1 = <span class="number">0</span>;<span class="comment">//定时器1停止计时</span></span><br><span class="line">	<span class="keyword">if</span>(rx == <span class="number">0</span>&amp;&amp;TF1 == <span class="number">0</span>)<span class="comment">//正常量程之内</span></span><br><span class="line">	&#123;</span><br><span class="line">		distance = ((TH1&lt;&lt;<span class="number">8</span>)+TL1)*<span class="number">0.017</span>;<span class="comment">//计算距离</span></span><br><span class="line">		TH1 = <span class="number">0</span>;</span><br><span class="line">		TL1 = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		distance = <span class="number">999</span>;<span class="comment">//超出量程</span></span><br><span class="line">		TF1 = <span class="number">0</span>;</span><br><span class="line">		TH1 = <span class="number">0</span>;</span><br><span class="line">		TL1 = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>备赛</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2024/07/19/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>观察者模式是一种行为设计模式，用于在对象之间建立一种一对多的依赖关系，当一个对象状态发生改变时，其所有依赖者都可以得到通知并自动更新。</p>
<p>通俗来说，观察者模式就是一个主题和一群订阅者之间的关系，主题会维护一个订阅者列表，党主体状态发生变化时，他会通知所有订阅者进行相应的更新操作。<br><img data-src="/../images/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/IMG-20240805173019730.png"></p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ol>
<li>当一个对象改变需要同时改变其他对象，并不确定有多少对象要改变时。</li>
<li>当一个对象需要将自己的改变通知给其他对象，而又不希望与其紧密耦合时。</li>
</ol>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><ol>
<li><p>优点</p>
<ul>
<li>解耦：观察者模式将主题和观察者解耦，使它们可以独立变化，互不影响。</li>
<li>扩展性：可以灵活地添加新的观察者，或者改变观察者的行为，而无需修改主题的代码。</li>
<li>维护一致性：主题和观察者之间建立了一种松散的依赖关系，保证了一致性。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>过多的通知：当主题对象有大量的观察者时，每次状态变化都需要通知所有观察者，可能会造成性能问题。</li>
<li>循环引用：当观察者之间相互引用时，可能导致循环引用的问题，需要注意避免。</li>
</ul>
</li>
</ol>
<p>总结来说，观察者模式适用于需要实现对象间的动态一对多关系，并且希望避免紧耦合的场景。它可以帮助我们实现松散耦合的设计，提高代码的可维护性和扩展性。</p>
<span id="more"></span>

<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img data-src="/../images/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/IMG-20240805194745103.png"></p>
<ul>
<li><code>主题Subject</code>: 一般会定义成一个接口，提供方法用于<strong>注册、删除和通知观察者</strong>，通常也包含一个状态，当状态发生改变时，通知所有的观察者。</li>
<li><code>观察者Observer</code>: 观察者也需要实现一个接口，包含一个更新方法，在接收主题通知时执行对应的操作。</li>
<li><code>具体主题ConcreteSubject</code>: 主题的具体实现, 维护一个观察者列表，包含了观察者的注册、删除和通知方法。</li>
<li><code>具体观察者ConcreteObserver</code>: 观察者接口的具体实现，每个具体观察者都注册到具体主题中，当主题状态变化并通知到具体观察者，具体观察者进行处理。</li>
</ul>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>假设有一个小镇，这个小镇上有一家天气预报中心。每天早上，天气预报中心会发布当天的天气情况，包括温度、湿度、风力等信息。同时，小镇上的几个居民对天气情况非常关注，因为天气会影响他们的日常生活。</p>
<p>在这个故事中，天气预报中心是被观察者（主题），而居民们是观察者。他们想要根据天气情况来做出相应的安排，比如选择穿什么衣服、是否要带伞等。</p>
<p>现在，我们来看一下如何使用观察者模式来实现这个故事。</p>
<p>首先定义一个主题接口，其中包含了添加观察者，移除观察者和通知观察者的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WeatherCenter</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们定义一个具体的天气预报中心（ConcreteWeatherCenter）类，实现了主题接口，并维护了一个观察者列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConcreteWeatherCenter implements WeatherCenter &#123;</span><br><span class="line">    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();</span><br><span class="line">    private WeatherData weatherData;</span><br><span class="line"></span><br><span class="line">    public void addObserver(Observer observer) &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void removeObserver(Observer observer) &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void notifyObservers() &#123;</span><br><span class="line">        for (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(weatherData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWeatherData(WeatherData weatherData) &#123;</span><br><span class="line">        this.weatherData = weatherData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>天气数据类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherData</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Double temperature;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Double humidity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer windSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getTemperature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTemperature</span><span class="params">(Double temperature)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getHumidity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> humidity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHumidity</span><span class="params">(Double humidity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getWindSpeed</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> windSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWindSpeed</span><span class="params">(Integer windSpeed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.windSpeed = windSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来定义观察者接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(WeatherData weatherData)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现一个具体的居民类，实现了观察者的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteResident</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteResident</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(WeatherData weatherData)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;今天的气温是：&quot;</span> + weatherData.getTemperature());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreteWeatherCenter</span> <span class="variable">concreteWeatherCenter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteWeatherCenter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ConcreteResident</span> <span class="variable">lisa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteResident</span>(<span class="string">&quot;Lisa&quot;</span>);</span><br><span class="line">        <span class="type">ConcreteResident</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteResident</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        concreteWeatherCenter.addObserver(lisa);</span><br><span class="line">        concreteWeatherCenter.addObserver(tom);</span><br><span class="line"></span><br><span class="line">        <span class="type">WeatherData</span> <span class="variable">weatherData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherData</span>();</span><br><span class="line">        weatherData.setTemperature(<span class="number">29.0</span>);</span><br><span class="line">        weatherData.setHumidity(<span class="number">84.0</span>);</span><br><span class="line">        weatherData.setWindSpeed(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        concreteWeatherCenter.setWeatherData(weatherData);</span><br><span class="line">        concreteWeatherCenter.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个故事中，天气预报中心是主题，居民们是观察者。当天气预报中心发布天气信息时，所有的居民都会收到通知，并根据天气情况做出相应的安排。</p>
<p>这个故事中的观察者模式展示了一个实际生活中常见的场景。通过观察者模式，天气预报中心和居民之间建立了一种松散的依赖关系，使得天气预报中心能够方便地通知居民们最新的天气情况，居民们也能够根据天气情况做出适当的调整。</p>
<p>故事中的观察者模式的优点是：</p>
<p>天气预报中心和居民之间实现了解耦，它们可以独立变化，互不影响。<br>天气预报中心可以方便地添加或移除观察者，居民们也可以灵活地订阅或取消订阅天气通知。<br>天气预报中心发布天气信息时，所有的居民都能够及时收到通知，确保信息的一致性。<br>观察者模式的缺点在这个故事中并不明显，但在实际应用中可能存在以下问题：</p>
<p>如果观察者过多或者观察者执行的操作较为耗时，可能会导致性能问题。<br>观察者之间相互引用时，可能出现循环引用的问题，需要注意避免。<br>总结来说，观察者模式在实际应用中非常有用，可以帮助我们实现对象之间的一对多关系，实现解耦、灵活性和一致性。无论是天气预报、事件通知还是其他需要实现观察者和被观察者之间关系的场景，观察者模式都是一个强大的工具。</p>
]]></content>
  </entry>
  <entry>
    <title>蓝桥杯工程模板</title>
    <url>/2020/08/14/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>工程模板主要是对一些基础设备做好初始化，比如四个锁存器的函数封装、定时器的初始化、数码管显示的初始化以及IIC，onewire和ADC的封装。</p>
<p>废话不多说，直接上代码。</p>
<h3 id="mian-c"><a href="#mian-c" class="headerlink" title="mian.c"></a>mian.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> temp_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	init();</span><br><span class="line">	init_timer();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		display_temp();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer2</span><span class="params">()</span> interrupt 12</span><br><span class="line">&#123;</span><br><span class="line">	temp_count++;</span><br><span class="line">	display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="common-h"><a href="#common-h" class="headerlink" title="common.h"></a>common.h</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _COMMON_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _COMMON_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;display.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;onewire.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sfr AUXR = <span class="number">0x8e</span>;</span><br><span class="line">sfr IE2 = <span class="number">0xaf</span>;</span><br><span class="line">sfr T2H = <span class="number">0xd6</span>;</span><br><span class="line">sfr T2L = <span class="number">0xd7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> temp_count,ADCount;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">select_channel</span><span class="params">(<span class="type">char</span> channel)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_timer</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">char</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="common-c"><a href="#common-c" class="headerlink" title="common.c"></a>common.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">select_channel</span><span class="params">(<span class="type">char</span> channel)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span>(channel)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0x80</span>; P2 &amp;= <span class="number">0x1f</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xa0</span>; P2 &amp;= <span class="number">0x1f</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xc0</span>; P2 &amp;= <span class="number">0x1f</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xe0</span>; P2 &amp;= <span class="number">0x1f</span>; <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)</span><br><span class="line">		smgbuf[i] = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	P0 = <span class="number">0xff</span>;</span><br><span class="line">	select_channel(<span class="number">4</span>);</span><br><span class="line">	</span><br><span class="line">	P0 = <span class="number">0x00</span>;</span><br><span class="line">	select_channel(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_timer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	AUXR = AUXR&amp;<span class="number">0x33</span>|<span class="number">0x10</span>;</span><br><span class="line">	IE2 = <span class="number">0x04</span>;</span><br><span class="line">	T2H = <span class="number">0xf8</span>;</span><br><span class="line">	T2L = <span class="number">0x2f</span>;</span><br><span class="line">	EA = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">char</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">while</span>(n--)</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">120</span>;i++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="display-h"><a href="#display-h" class="headerlink" title="display.h"></a>display.h</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _DISPLAY_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DISPLAY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> smgbuf[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="display-c"><a href="#display-c" class="headerlink" title="display.c"></a>display.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;display.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> smgw[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> smgd[] = &#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x07</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>,<span class="number">0x00</span>,<span class="number">0x40</span>&#125;;</span><br><span class="line"><span class="type">char</span> smgbuf[<span class="number">8</span>],num = <span class="number">0</span>,point_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	num++;</span><br><span class="line">	<span class="keyword">if</span>(num &gt;= <span class="number">8</span>)</span><br><span class="line">		num = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	P0 = <span class="number">0xff</span>;</span><br><span class="line">	select_channel(<span class="number">7</span>);</span><br><span class="line">	</span><br><span class="line">	P0 = smgw[num];</span><br><span class="line">	select_channel(<span class="number">6</span>);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(point_flag&amp;&amp;num == <span class="number">1</span>)</span><br><span class="line">		P0 = ~(smgd[smgbuf[num]] | <span class="number">0x80</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		P0 = ~smgd[smgbuf[num]];</span><br><span class="line">	select_channel(<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display_temp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	point_flag = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(temp_count &gt;= <span class="number">50</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = read_temp();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	smgbuf[<span class="number">0</span>] = temp / <span class="number">1000</span>;</span><br><span class="line">	smgbuf[<span class="number">1</span>] = temp % <span class="number">1000</span> / <span class="number">100</span>;</span><br><span class="line">	smgbuf[<span class="number">2</span>] = temp % <span class="number">100</span> / <span class="number">10</span>;</span><br><span class="line">	smgbuf[<span class="number">3</span>] = temp % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display_AData</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">  </span><br><span class="line">  point_flag = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span>(ADCount &gt;= <span class="number">50</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ADCount = <span class="number">0</span>;</span><br><span class="line">		dat = ADConvert(<span class="number">0x03</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	smgbuf[<span class="number">0</span>] = dat / <span class="number">100</span>;</span><br><span class="line">	smgbuf[<span class="number">1</span>] = dat % <span class="number">100</span> / <span class="number">10</span>;</span><br><span class="line">	smgbuf[<span class="number">2</span>] = dat % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display_ds1302</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  point_flag = <span class="number">0</span>;</span><br><span class="line">	smgbuf[<span class="number">0</span>] = Read_Ds1302(<span class="number">0x85</span>) / <span class="number">16</span>;</span><br><span class="line">	smgbuf[<span class="number">1</span>] = Read_Ds1302(<span class="number">0x85</span>) % <span class="number">16</span>;</span><br><span class="line">	smgbuf[<span class="number">2</span>] = <span class="number">11</span>;</span><br><span class="line">	smgbuf[<span class="number">3</span>] = Read_Ds1302(<span class="number">0x83</span>) / <span class="number">16</span>;</span><br><span class="line">	smgbuf[<span class="number">4</span>] = Read_Ds1302(<span class="number">0x83</span>) % <span class="number">16</span>;</span><br><span class="line">	smgbuf[<span class="number">5</span>] = <span class="number">11</span>;</span><br><span class="line">	smgbuf[<span class="number">6</span>] = Read_Ds1302(<span class="number">0x81</span>) / <span class="number">16</span>;</span><br><span class="line">	smgbuf[<span class="number">7</span>] = Read_Ds1302(<span class="number">0x81</span>) % <span class="number">16</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="onewire-h"><a href="#onewire-h" class="headerlink" title="onewire.h"></a>onewire.h</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ONEWIRE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ONEWIRE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_temp</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="onewire-c"><a href="#onewire-c" class="headerlink" title="onewire.c"></a>onewire.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;onewire.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit DQ = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_OneWire</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_DS18B20</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		DQ = <span class="number">0</span>;</span><br><span class="line">		DQ = dat&amp;<span class="number">0x01</span>;</span><br><span class="line">		Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">		DQ = <span class="number">1</span>;</span><br><span class="line">		dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_DS18B20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		DQ = <span class="number">0</span>;</span><br><span class="line">		dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		DQ = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(DQ)</span><br><span class="line">		&#123;</span><br><span class="line">			dat |= <span class="number">0x80</span>;</span><br><span class="line">		&#125;	    </span><br><span class="line">		Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bit <span class="title function_">init_ds18b20</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  	bit initflag = <span class="number">0</span>;</span><br><span class="line">  	</span><br><span class="line">  	DQ = <span class="number">1</span>;</span><br><span class="line">  	Delay_OneWire(<span class="number">12</span>);</span><br><span class="line">  	DQ = <span class="number">0</span>;</span><br><span class="line">  	Delay_OneWire(<span class="number">80</span>);</span><br><span class="line">  	DQ = <span class="number">1</span>;</span><br><span class="line">  	Delay_OneWire(<span class="number">10</span>); </span><br><span class="line">    initflag = DQ;     </span><br><span class="line">  	Delay_OneWire(<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">return</span> initflag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_temp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> TH,TL;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">	init_ds18b20();</span><br><span class="line">	Write_DS18B20(<span class="number">0xcc</span>);</span><br><span class="line">	Write_DS18B20(<span class="number">0x44</span>);</span><br><span class="line">	Delay_OneWire(<span class="number">200</span>);</span><br><span class="line">	</span><br><span class="line">	init_ds18b20();</span><br><span class="line">	Write_DS18B20(<span class="number">0xcc</span>);</span><br><span class="line">	Write_DS18B20(<span class="number">0xbe</span>);</span><br><span class="line">	</span><br><span class="line">	TL = Read_DS18B20();</span><br><span class="line">	TH = Read_DS18B20();</span><br><span class="line">	</span><br><span class="line">	temp = ((TH&lt;&lt;<span class="number">8</span>) + TL) * <span class="number">0.0625</span> * <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="iic-h"><a href="#iic-h" class="headerlink" title="iic.h"></a>iic.h</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IIC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IIC_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span>;  </span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Ack</span><span class="params">(bit ackbit)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byt)</span>; </span><br><span class="line">bit <span class="title function_">IIC_WaitAck</span><span class="params">(<span class="type">void</span>)</span>;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">IIC_RecByte</span><span class="params">(<span class="type">void</span>)</span>; </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">ADConvert</span><span class="params">(<span class="type">char</span> addr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">e2prom_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat,addr)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">e2prom_read</span><span class="params">(<span class="type">char</span> addr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="iic-c"><a href="#iic-c" class="headerlink" title="iic.c"></a>iic.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iic.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> somenop &#123;_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();&#125;    </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SlaveAddrW 0xA0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SlaveAddrR 0xA1</span></span><br><span class="line"></span><br><span class="line">sbit SDA = P2^<span class="number">1</span>;  <span class="comment">/* Êý¾ÝÏß */</span></span><br><span class="line">sbit SCL = P2^<span class="number">0</span>;  <span class="comment">/* Ê±ÖÓÏß */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	SDA = <span class="number">1</span>;</span><br><span class="line">	SCL = <span class="number">1</span>;</span><br><span class="line">	somenop;</span><br><span class="line">	SDA = <span class="number">0</span>;</span><br><span class="line">	somenop;</span><br><span class="line">	SCL = <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	SDA = <span class="number">0</span>;</span><br><span class="line">	SCL = <span class="number">1</span>;</span><br><span class="line">	somenop;</span><br><span class="line">	SDA = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Ack</span><span class="params">(bit ackbit)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(ackbit) </span><br><span class="line">	&#123;	</span><br><span class="line">		SDA = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		SDA = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	somenop;</span><br><span class="line">	SCL = <span class="number">1</span>;</span><br><span class="line">	somenop;</span><br><span class="line">	SCL = <span class="number">0</span>;</span><br><span class="line">	SDA = <span class="number">1</span>; </span><br><span class="line">	somenop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bit <span class="title function_">IIC_WaitAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	SDA = <span class="number">1</span>;</span><br><span class="line">	somenop;</span><br><span class="line">	SCL = <span class="number">1</span>;</span><br><span class="line">	somenop;</span><br><span class="line">	<span class="keyword">if</span>(SDA)    </span><br><span class="line">	&#123;   </span><br><span class="line">		SCL = <span class="number">0</span>;</span><br><span class="line">		IIC_Stop();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>  </span><br><span class="line">	&#123; </span><br><span class="line">		SCL = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;   </span><br><span class="line">		<span class="keyword">if</span>(byt&amp;<span class="number">0x80</span>) </span><br><span class="line">		&#123;	</span><br><span class="line">			SDA = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			SDA = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		somenop;</span><br><span class="line">		SCL = <span class="number">1</span>;</span><br><span class="line">		byt &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		somenop;</span><br><span class="line">		SCL = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">IIC_RecByte</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> da;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;   </span><br><span class="line">		SCL = <span class="number">1</span>;</span><br><span class="line">		somenop;</span><br><span class="line">		da &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(SDA) </span><br><span class="line">		da |= <span class="number">0x01</span>;</span><br><span class="line">		SCL = <span class="number">0</span>;</span><br><span class="line">		somenop;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> da;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">ADConvert</span><span class="params">(<span class="type">char</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">	IIC_Start();</span><br><span class="line">	IIC_SendByte(<span class="number">0x90</span>);</span><br><span class="line">	IIC_WaitAck();</span><br><span class="line">	IIC_SendByte(addr);</span><br><span class="line">	IIC_WaitAck();</span><br><span class="line">	IIC_Stop();</span><br><span class="line">	</span><br><span class="line">	IIC_Start();</span><br><span class="line">	IIC_SendByte(<span class="number">0x91</span>);</span><br><span class="line">	IIC_WaitAck();</span><br><span class="line">	dat = IIC_RecByte();</span><br><span class="line">	IIC_Ack(<span class="number">0</span>);</span><br><span class="line">	IIC_Stop();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">e2prom_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr,dat)</span></span><br><span class="line">&#123;</span><br><span class="line">	IIC_Start();</span><br><span class="line">	IIC_SendByte(<span class="number">0xa0</span>);</span><br><span class="line">	IIC_WaitAck();</span><br><span class="line">	IIC_SendByte(addr);</span><br><span class="line">	IIC_WaitAck();</span><br><span class="line">	IIC_SendByte(dat);</span><br><span class="line">	IIC_WaitAck();</span><br><span class="line">	IIC_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">e2prom_read</span><span class="params">(<span class="type">char</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">	</span><br><span class="line">	IIC_Start();</span><br><span class="line">	IIC_SendByte(<span class="number">0xa0</span>);</span><br><span class="line">	IIC_WaitAck();</span><br><span class="line">	IIC_SendByte(addr);</span><br><span class="line">	IIC_WaitAck();</span><br><span class="line">	IIC_Stop();</span><br><span class="line">	</span><br><span class="line">	IIC_Start();</span><br><span class="line">	IIC_SendByte(<span class="number">0xa1</span>);</span><br><span class="line">	IIC_WaitAck();</span><br><span class="line">	dat = IIC_RecByte();</span><br><span class="line">	IIC_Ack(<span class="number">0</span>);</span><br><span class="line">	IIC_Stop();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ds1302-h"><a href="#ds1302-h" class="headerlink" title="ds1302.h"></a>ds1302.h</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DS1302_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DS1302_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Ds1302_Byte</span><span class="params">(<span class="type">unsigned</span>  <span class="type">char</span> temp)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Ds1302</span><span class="params">( <span class="type">unsigned</span> <span class="type">char</span> address,<span class="type">unsigned</span> <span class="type">char</span> dat )</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_Ds1302</span> <span class="params">( <span class="type">unsigned</span> <span class="type">char</span> address )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_ds1302</span><span class="params">(<span class="type">char</span> h,m,s)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ds1302-c"><a href="#ds1302-c" class="headerlink" title="ds1302.c"></a>ds1302.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ds1302.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit SCK=P1^<span class="number">7</span>;		</span><br><span class="line">sbit SDA=P2^<span class="number">3</span>;		</span><br><span class="line">sbit RST = P1^<span class="number">3</span>;  			</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Ds1302_Byte</span><span class="params">(<span class="type">unsigned</span>  <span class="type">char</span> temp)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)     	</span><br><span class="line">	&#123; </span><br><span class="line">		SCK=<span class="number">0</span>;</span><br><span class="line">		SDA=temp&amp;<span class="number">0x01</span>;</span><br><span class="line">		temp&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">		SCK=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Ds1302</span><span class="params">( <span class="type">unsigned</span> <span class="type">char</span> address,<span class="type">unsigned</span> <span class="type">char</span> dat )</span>     </span><br><span class="line">&#123;</span><br><span class="line"> 	RST=<span class="number">0</span>;</span><br><span class="line">	_nop_();</span><br><span class="line"> 	SCK=<span class="number">0</span>;</span><br><span class="line">	_nop_();</span><br><span class="line"> 	RST=<span class="number">1</span>;	</span><br><span class="line">   	_nop_();  </span><br><span class="line"> 	Write_Ds1302_Byte(address);	</span><br><span class="line"> 	Write_Ds1302_Byte(dat);		</span><br><span class="line"> 	RST=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Read_Ds1302</span> <span class="params">( <span class="type">unsigned</span> <span class="type">char</span> address )</span></span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">char</span> i,temp=<span class="number">0x00</span>;</span><br><span class="line"> 	RST=<span class="number">0</span>;</span><br><span class="line">	_nop_();</span><br><span class="line"> 	SCK=<span class="number">0</span>;</span><br><span class="line">	_nop_();</span><br><span class="line"> 	RST=<span class="number">1</span>;</span><br><span class="line">	_nop_();</span><br><span class="line"> 	Write_Ds1302_Byte(address);</span><br><span class="line"> 	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) 	</span><br><span class="line"> 	&#123;		</span><br><span class="line">		SCK=<span class="number">0</span>;</span><br><span class="line">		temp&gt;&gt;=<span class="number">1</span>;	</span><br><span class="line"> 		<span class="keyword">if</span>(SDA)</span><br><span class="line"> 		temp|=<span class="number">0x80</span>;	</span><br><span class="line"> 		SCK=<span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line"> 	RST=<span class="number">0</span>;</span><br><span class="line">	_nop_();</span><br><span class="line"> 	RST=<span class="number">0</span>;</span><br><span class="line">	SCK=<span class="number">0</span>;</span><br><span class="line">	_nop_();</span><br><span class="line">	SCK=<span class="number">1</span>;</span><br><span class="line">	_nop_();</span><br><span class="line">	SDA=<span class="number">0</span>;</span><br><span class="line">	_nop_();</span><br><span class="line">	SDA=<span class="number">1</span>;</span><br><span class="line">	_nop_();</span><br><span class="line">	<span class="keyword">return</span> (temp);			</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_ds1302</span><span class="params">(<span class="type">char</span> h,m,s)</span></span><br><span class="line">&#123;</span><br><span class="line">	Write_Ds1302(<span class="number">0x8e</span>,<span class="number">0x00</span>);</span><br><span class="line">	Write_Ds1302(<span class="number">0x84</span>,h);</span><br><span class="line">	Write_Ds1302(<span class="number">0x82</span>,m);</span><br><span class="line">	Write_Ds1302(<span class="number">0x80</span>,s);</span><br><span class="line">	Write_Ds1302(<span class="number">0x8e</span>,<span class="number">0x80</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>备赛</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>Internet校验和计算示例</title>
    <url>/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A0%A1%E9%AA%8C%E5%92%8C%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<blockquote>
<p>Packet</p>
<p>01 00 F2 03 F4 F5 F6 F7 00 00</p>
<p>(00 00 is the checksum field)</p>
<p>Form the 16-bit words</p>
<p>0100 F203 F4F5 F6F7</p>
<p>Calculate 2’s complement sum</p>
<p>0100 + F203 + F4F5 + F6F7 &#x3D; 0002 DEEF (store the sum in a 32-bit word)</p>
<p>Add the carries (0002) to get the 16-bit 1’s complement sum</p>
<p>DEEF + 002 &#x3D; DEF1</p>
<p>Calculate 1’s complement of the 1’s complement sum</p>
<p>~DEF1 &#x3D; 210E</p>
<p>We send the packet including the checksum 21 0E</p>
<p>01 00 F2 03 F4 F5 F6 F7 21 0E</p>
<p>At the receiving</p>
<p>0100 + F203 + F4F5 + F6F7 + 210E &#x3D; 0002 FFFD<br>FFFD + 0002 &#x3D; FFFF</p>
<p>which checks OK.</p>
</blockquote>
<span id="more"></span>

<p>原文链接：<a href="https://blog.csdn.net/qq_34369618/java/article/details/60603867">https://blog.csdn.net/qq_34369618/java/article/details/60603867</a></p>
<p>翻译一下：</p>
<p>有一个Packet</p>
<p>01 00 F2 03 F4 F5 F6 F7 00 00</p>
<p>(最后四位 00 00 是校验和)</p>
<p>把上面十六位的数据两个两个组合</p>
<p>0100 F203 F4F5 F6F7</p>
<p>将这四个32位的16进制数相加</p>
<p>0100 + F203 + F4F5 + F6F7 &#x3D; 0002 DEEF </p>
<p>最高位进位的“1”返回到最低位继续加</p>
<p>DEEF + 0002 &#x3D; DEF1 </p>
<p>再对其结果按位取反</p>
<p>~DEF1 &#x3D; 210E</p>
<p>21 0E就是这个package的校验</p>
<p>01 00 F2 03 F4 F5 F6 F7 21 0E</p>
<p>接收端也是一样的，两个十六位的数组成一个三十二位的数，再将其全部相加</p>
<p>0100 + F203 + F4F5 + F6F7 + 210E &#x3D; 0002 FFFD<br>FFFD + 0002 &#x3D; FFFF</p>
<p>得到的结果为FFFF就没有问题</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改NexT主题</title>
    <url>/2022/07/28/%E9%AD%94%E6%94%B9NexT%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li>hexo版本：6.2.0</li>
<li>NexT版本：8.12.2</li>
<li>NodeJS版本：16.16</li>
</ul>
<h1 id="背景修改canvas-nest"><a href="#背景修改canvas-nest" class="headerlink" title="背景修改canvas-nest"></a>背景修改<a href="https://github.com/theme-next/theme-next-canvas-nest">canvas-nest</a></h1><h2 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h2><p>在next主题文件夹根目录下的<code>layout/_layout.njk</code>中加入如下代码到footer标签后面即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest.enable %&#125;</span><br><span class="line"></span><br><span class="line">&lt;script color=&quot;&#123;&#123; theme.canvas_nest.color &#125;&#125;&quot; </span><br><span class="line">        opacity=&quot;&#123;&#123; theme.canvas_nest.opacity &#125;&#125;&quot; </span><br><span class="line">        zIndex=&quot;&#123;&#123; theme.canvas_nest.zIndex &#125;&#125;&quot; </span><br><span class="line">        count=&quot;&#123;&#123; theme.canvas_nest.count &#125;&#125;&quot; </span><br><span class="line">        src=&quot;https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h2><p>在next主题的配置文件（<code>_config.yml</code>）最后面，加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Canvas-nest</span><br><span class="line"># Dependencies: https://github.com/theme-next/theme-next-canvas-nest</span><br><span class="line"># For more information: https://github.com/hustcc/canvas-nest.js</span><br><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">  color: &quot;0, 0, 0&quot; # RGB values, use `,` to separate</span><br><span class="line">  opacity: 0.7 # The opacity of line: 0~1</span><br><span class="line">  zIndex: -1 # z-index property of the background</span><br><span class="line">  count: 120 # The number of lines</span><br></pre></td></tr></table></figure>

<p>参数可以根据个人需求修改，color代表线条颜色，opacity为线条透明度，zIndex为层级，一般不需要修改，count为线条数量，数字越大线条越多。</p>
<h2 id="step3（可忽略）"><a href="#step3（可忽略）" class="headerlink" title="step3（可忽略）"></a>step3（可忽略）</h2><p>为了满足个人审美需求，还将页面主体部分透明度设为100%，侧边栏badge字体颜色透明度不与主体部分保持一致，修改如下：</p>
<h3 id="主体透明度修改"><a href="#主体透明度修改" class="headerlink" title="主体透明度修改"></a>主体透明度修改</h3><p>修改主题根目录下的<code>\source\css\_variables\base.styl</code>文件，将<code>$body-bg-color</code>和<code>$content-bg-color</code>值修改为<code>#fff0</code></p>
<h3 id="修改侧边栏badge字体颜色"><a href="#修改侧边栏badge字体颜色" class="headerlink" title="修改侧边栏badge字体颜色"></a>修改侧边栏badge字体颜色</h3><p>修改主题根目录下的<code>source\css\_schemes\Pisces\_menu.styl</code>文件，将<code> .badge</code>中的<code>color</code>修改为rgb(255, 255, 255)</p>
<p>效果如图所示：</p>
<img data-src="\images\魔改NexT主题\image-20220728113746502.png" alt="image-20220728113746502"/>



<h1 id="支持mermaid流程图显示"><a href="#支持mermaid流程图显示" class="headerlink" title="支持mermaid流程图显示"></a>支持mermaid流程图显示</h1><p>安装插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure>

<p>修改NeXt主题下的<code>_config.yml</code>文件将<code>mermaid</code>选项下的<code>enable</code>设置为true即可。</p>
<h1 id="在特定页面隐藏目录"><a href="#在特定页面隐藏目录" class="headerlink" title="在特定页面隐藏目录"></a>在特定页面隐藏目录</h1><p>修改<code>themes\next\layout\_macro\sidebar.</code>文件，将</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%- set display_toc = page.toc.enable and display_toc %&#125;</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%- set display_toc = page.toc.enable and display_toc and page.path.indexOf(&#x27;关键词&#x27;) == -1 %&#125;</span><br></pre></td></tr></table></figure>



<h1 id="搞怪标题"><a href="#搞怪标题" class="headerlink" title="搞怪标题"></a>搞怪标题</h1><p>在主题根目录<code>layout</code>文件夹下新建一个<code>custom.njk</code>，加入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;# 搞怪网页标题 #&#125; </span><br><span class="line">&#123;% if theme.title_trick.enable %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var OriginTitile = document.title;</span><br><span class="line">  var titleTime;</span><br><span class="line">  //换网站的logo</span><br><span class="line">  function selfSetIcon(url)&#123;</span><br><span class="line">		var links = document.getElementsByTagName(&#x27;link&#x27;) </span><br><span class="line">		for (var i = 0; i &lt; links.length; i++) &#123; </span><br><span class="line">			var link = links[i]</span><br><span class="line">			var rel = link.rel; </span><br><span class="line">            var count = 0;</span><br><span class="line">			rel = rel.toLowerCase(); </span><br><span class="line">			if (rel.indexOf(&#x27;icon&#x27;) == 0) &#123; </span><br><span class="line">                count++;</span><br><span class="line">				link.href = url;</span><br><span class="line">                if(count == 2)</span><br><span class="line">				    break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  document.addEventListener(&quot;visibilitychange&quot;, function() &#123;</span><br><span class="line">    if (document.hidden) &#123;</span><br><span class="line">      document.title = &quot;&#123;&#123; theme.title_trick.leave &#125;&#125;&quot; + OriginTitile;</span><br><span class="line">      selfSetIcon(&quot;&#123;&#123; theme.title_trick.logo &#125;&#125;&quot;);</span><br><span class="line">      clearTimeout(titleTime);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      selfSetIcon(&quot;&#123;&#123; theme.favicon.medium &#125;&#125;&quot;);</span><br><span class="line">      document.title = &quot;&#123;&#123; theme.title_trick.enter &#125;&#125;&quot; + OriginTitile;</span><br><span class="line">      titleTime = setTimeout(function() &#123;</span><br><span class="line">        document.title = OriginTitile;</span><br><span class="line">        </span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>修改同级目录<code>_layout.njk</code>，在<code>&#123;&#123;- next_inject('bodyEnd') &#125;&#125;</code>前面加入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% include &#x27;custom.njk&#x27; %&#125;</span><br></pre></td></tr></table></figure>

<p>在主题配置文件末尾加入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title_trick:</span><br><span class="line">  enable: true</span><br><span class="line">  leave: &quot;(●—●)喔噢，崩溃了~|&quot;</span><br><span class="line">  enter: &quot;φ(&gt;ω&lt;*) 咦！又好了！|&quot;</span><br><span class="line">  logo: &quot;https://muggletan.github.io/images/failure.ico&quot;</span><br></pre></td></tr></table></figure>



<h1 id="fancybox去掉图片标题"><a href="#fancybox去掉图片标题" class="headerlink" title="fancybox去掉图片标题"></a>fancybox去掉图片标题</h1><p>修改主题文件夹下的<code>themes\next\source\js\third-party\fancybox.js</code>文件，注释掉如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const imageTitle = $image.attr(&#x27;title&#x27;) || $image.attr(&#x27;alt&#x27;);</span><br><span class="line">if (imageTitle) &#123;</span><br><span class="line">// Do not append image-caption if pandoc has already created a figcaption</span><br><span class="line">if (!$imageWrapLink.next(&#x27;figcaption&#x27;).length) &#123;</span><br><span class="line">$imageWrapLink.append(`&lt;p class=&quot;image-caption&quot;&gt;$&#123;imageTitle&#125;&lt;/p&gt;`);</span><br><span class="line">&#125;</span><br><span class="line">// Make sure img title tag will show correctly in fancybox</span><br><span class="line">$imageWrapLink.attr(&#x27;title&#x27;, imageTitle).attr(&#x27;data-caption&#x27;, imageTitle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="修改动画时间"><a href="#修改动画时间" class="headerlink" title="修改动画时间"></a>修改动画时间</h1><p>修改主题文件夹下的<code>themes\next\source\js\motion.js</code>文件，修改第一个duration变量的值。</p>
]]></content>
      <categories>
        <category>NexT</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
